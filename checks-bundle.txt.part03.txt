===== FILE: remoteiq-minimal-e2e\agent-windows\RemoteIQ.Agent\Services\AgentService.cs (319 lines) =====
// remoteiq-minimal-e2e/agent-windows/RemoteIQ.Agent/Services/AgentService.cs
using Microsoft.Extensions.Hosting;
using Microsoft.Extensions.Logging;
using Microsoft.Extensions.Options;
using RemoteIQ.Agent.Models;
using RemoteIQ.Agent.Options;
using RemoteIQ.Agent.Services.Http;
using RemoteIQ.Agent.Services.Security;
using System.Net;
using System.Net.NetworkInformation;
using System.Net.Sockets;
using System.Runtime.InteropServices;
using System.Security.Principal;
using System.Threading;
using System.Threading.Tasks;
using System.Management;
using RemoteIQ.Agent.Services.Collectors;
using System;
using System.Linq;

namespace RemoteIQ.Agent.Services;

public class AgentService : BackgroundService
{
    private readonly ILogger<AgentService> _log;
    private readonly ApiClient _api;
    private readonly TokenStore _tokenStore;
    private readonly EnrollmentClient _enrollment;
    private readonly WebSocketClient _ws;
    private readonly AgentOptions _options;

    public AgentService(
        ILogger<AgentService> log,
        ApiClient api,
        TokenStore tokenStore,
        EnrollmentClient enrollment,
        WebSocketClient ws,
        IOptions<AgentOptions> options)
    {
        _log = log;
        _api = api;
        _tokenStore = tokenStore;
        _enrollment = enrollment;
        _ws = ws;
        _options = options.Value;
    }

    protected override async Task ExecuteAsync(CancellationToken stoppingToken)
    {
        _log.LogInformation("Agent starting…");

        // ✅ Enroll with required parameters: os, arch, version, hostname, ct
        var os = GetOsName();
        var arch = GetArch();
        var version = GetAgentVersion();
        var hostname = Environment.MachineName;
        await _enrollment.EnrollAsync(os, arch, version, hostname, stoppingToken);

        var tokenData = _tokenStore.Load();
        if (tokenData is null || string.IsNullOrWhiteSpace(tokenData.AgentToken) || tokenData.AgentId is null || tokenData.DeviceId is null)
        {
            _log.LogError("Enrollment/token missing after EnrollAsync. Agent cannot continue.");
            return;
        }

        _api.SetBearer(tokenData.AgentToken);

        try { await _ws.StartAsync(stoppingToken); } catch { /* non-fatal */ }

        var seconds = _options.PollIntervalSeconds > 0 ? _options.PollIntervalSeconds : 60;
        var period = TimeSpan.FromSeconds(seconds);
        using var timer = new PeriodicTimer(period);
        _log.LogInformation("Heartbeat every {Seconds}s", seconds);

        await SendPingOnce(stoppingToken);

        // One-shot software upload after first ping (best-effort)
        _ = Task.Run(() => SendSoftwareOnce(stoppingToken), stoppingToken);

        while (await timer.WaitForNextTickAsync(stoppingToken))
        {
            await SendPingOnce(stoppingToken);

            // Roughly hourly software refresh
            if (DateTimeOffset.UtcNow.Minute == 0)
                _ = Task.Run(() => SendSoftwareOnce(stoppingToken), stoppingToken);
        }
    }

    private async Task SendPingOnce(CancellationToken ct)
    {
        try
        {
            var os = GetOsName();
            var arch = GetArch();
            var version = GetAgentVersion();
            var primaryIp = GetPrimaryIPv4();
            var user = GetInteractiveUserViaWmi()
                       ?? GetLoggedInUserInteractive()
                       ?? GetLoggedInUserServiceContext();

            await _api.PingAsync(new PingRequest(
                Os: os,
                Arch: arch,
                Version: version,
                PrimaryIp: primaryIp,
                User: user
            ), ct);

            _log.LogDebug("Ping OK (os={Os} arch={Arch} ver={Ver} ip={Ip} user={User})",
                os, arch, version, primaryIp, user);
        }
        catch (OperationCanceledException) { }
        catch (HttpRequestException ex)
        {
            _log.LogWarning(ex, "Ping HTTP error.");
        }
        catch (Exception ex)
        {
            _log.LogError(ex, "Ping failed.");
        }
    }

    private async Task SendSoftwareOnce(CancellationToken ct)
    {
        try
        {
            var items = SoftwareCollector.Collect();
            if (items.Count == 0) return;

            await _api.SubmitSoftwareAsync(items, ct);
            _log.LogInformation("Uploaded {Count} software rows.", items.Count);
        }
        catch (OperationCanceledException) { }
        catch (HttpRequestException ex)
        {
            _log.LogWarning(ex, "Software upload HTTP error.");
        }
        catch (Exception ex)
        {
            _log.LogError(ex, "Software upload failed.");
        }
    }

    private static string GetOsName()
        => RuntimeInformation.IsOSPlatform(OSPlatform.Windows) ? "windows"
         : RuntimeInformation.IsOSPlatform(OSPlatform.Linux) ? "linux"
         : RuntimeInformation.IsOSPlatform(OSPlatform.OSX) ? "macos"
         : "unknown";

    private static string GetArch()
        => RuntimeInformation.OSArchitecture switch
        {
            Architecture.X64 => "x64",
            Architecture.X86 => "x86",
            Architecture.Arm64 => "arm64",
            _ => RuntimeInformation.OSArchitecture.ToString().ToLowerInvariant()
        };

    private static string GetAgentVersion()
    {
        try
        {
            return System.Reflection.Assembly.GetExecutingAssembly().GetName().Version?.ToString() ?? "1.0.0";
        }
        catch { return "1.0.0"; }
    }

    private static string? GetPrimaryIPv4()
    {
        try
        {
            foreach (var ni in NetworkInterface.GetAllNetworkInterfaces())
            {
                if (ni.OperationalStatus != OperationalStatus.Up) continue;
                var ipProps = ni.GetIPProperties();
                foreach (var ua in ipProps.UnicastAddresses)
                {
                    if (ua.Address.AddressFamily != AddressFamily.InterNetwork) continue;
                    var s = ua.Address.ToString();
                    if (IsPrivateIPv4(s)) return s;
                }
            }

            foreach (var addr in Dns.GetHostAddresses(Dns.GetHostName()))
            {
                if (addr.AddressFamily == AddressFamily.InterNetwork) return addr.ToString();
            }
        }
        catch { }
        return null;

        static bool IsPrivateIPv4(string ip)
        {
            if (IPAddress.TryParse(ip, out var addr))
            {
                var b = addr.GetAddressBytes();
                if (b[0] == 10) return true;
                if (b[0] == 172 && b[1] >= 16 && b[1] <= 31) return true;
                if (b[0] == 192 && b[1] == 168) return true;
            }
            return false;
        }
    }

    private static string? GetInteractiveUserViaWmi()
    {
        if (!RuntimeInformation.IsOSPlatform(OSPlatform.Windows))
            return null;

        try
        {
            using var cls = new ManagementClass("Win32_ComputerSystem");
            using var instances = cls.GetInstances();
            foreach (ManagementObject mo in instances)
            {
                var user = (mo["UserName"] as string)?.Trim();
                if (!string.IsNullOrWhiteSpace(user))
                    return user;
            }
        }
        catch { }
        return null;
    }

    private static string? GetLoggedInUserInteractive()
    {
        if (!RuntimeInformation.IsOSPlatform(OSPlatform.Windows))
            return null;

        try
        {
            uint sessionId = WTSGetActiveConsoleSessionId();
            if (sessionId == 0xFFFFFFFF) return null;

            if (!WTSQuerySessionInformation(IntPtr.Zero, sessionId, WTS_INFO_CLASS.WTSUserName, out var userPtr, out _)
                || userPtr == IntPtr.Zero) return null;

            try
            {
                var user = Marshal.PtrToStringUni(userPtr)?.Trim();
                if (string.IsNullOrWhiteSpace(user)) return null;

                string? domain = null;
                if (WTSQuerySessionInformation(IntPtr.Zero, sessionId, WTS_INFO_CLASS.WTSDomainName, out var domPtr, out _)
                    && domPtr != IntPtr.Zero)
                {
                    try { domain = Marshal.PtrToStringUni(domPtr)?.Trim(); }
                    finally { WTSFreeMemory(domPtr); }
                }

                return string.IsNullOrWhiteSpace(domain) ? user : $"{domain}\\{user}";
            }
            finally
            {
                WTSFreeMemory(userPtr);
            }
        }
        catch
        {
            return null;
        }
    }

    private static string GetLoggedInUserServiceContext()
    {
        try
        {
            using var wi = WindowsIdentity.GetCurrent();
            return wi?.Name ?? Environment.UserName;
        }
        catch
        {
            return Environment.UserName;
        }
    }

    public override async Task StopAsync(CancellationToken cancellationToken)
    {
        try { await _ws.DisposeAsync(); } catch { }
        await base.StopAsync(cancellationToken);
    }

    private enum WTS_INFO_CLASS
    {
        WTSInitialProgram = 0,
        WTSApplicationName = 1,
        WTSWorkingDirectory = 2,
        WTSOEMId = 3,
        WTSSessionId = 4,
        WTSUserName = 5,
        WTSWinStationName = 6,
        WTSDomainName = 7,
        WTSConnectState = 8,
        WTSClientBuildNumber = 9,
        WTSClientName = 10,
        WTSClientDirectory = 11,
        WTSClientProductId = 12,
        WTSClientHardwareId = 13,
        WTSClientAddress = 14,
        WTSClientDisplay = 15,
        WTSClientProtocolType = 16
    }

    [DllImport("wtsapi32.dll", CharSet = CharSet.Unicode, SetLastError = true)]
    private static extern bool WTSQuerySessionInformation(
        IntPtr hServer,
        uint sessionId,
        WTS_INFO_CLASS wtsInfoClass,
        out IntPtr ppBuffer,
        out int pBytesReturned);

    [DllImport("wtsapi32.dll")]
    private static extern void WTSFreeMemory(IntPtr pMemory);

    [DllImport("kernel32.dll")]
    private static extern uint WTSGetActiveConsoleSessionId();
}

===== END FILE remoteiq-minimal-e2e\agent-windows\RemoteIQ.Agent\Services\AgentService.cs =====

===== FILE: remoteiq-minimal-e2e\agent-windows\RemoteIQ.Agent\Services\EnrollmentClient.cs (183 lines) =====
using System.Net.Http.Json;
using System.Text.Json;
using Microsoft.Extensions.Configuration;
using Microsoft.Extensions.Logging;
using Microsoft.Win32;
using RemoteIQ.Agent.Models;             // AgentConfig.From(...)
using RemoteIQ.Agent.Services.Security;  // TokenStore
using System.Runtime.InteropServices;

namespace RemoteIQ.Agent.Services;

public class EnrollmentClient
{
    private readonly ILogger<EnrollmentClient> _log;
    private readonly IConfiguration _cfg;
    private readonly TokenStore _tokenStore;

    public EnrollmentClient(ILogger<EnrollmentClient> log, IConfiguration cfg, TokenStore tokenStore)
    {
        _log = log;
        _cfg = cfg;
        _tokenStore = tokenStore;
    }

    public async Task EnrollAsync(
        string os,
        string arch,
        string version,
        string hostname,
        CancellationToken ct)
    {
        var baseUrl = AgentConfig.From(_cfg).ApiBase.TrimEnd('/');

        var enrollmentSecret = _cfg["Agent:EnrollmentSecret"] ?? _cfg["EnrollmentSecret"] ?? "";
        if (string.IsNullOrWhiteSpace(enrollmentSecret))
            throw new InvalidOperationException("Missing Agent:EnrollmentSecret in configuration.");

        var deviceId = _cfg["Agent:DeviceId"] ?? DeriveDeviceId(hostname);
        if (string.IsNullOrWhiteSpace(deviceId))
            throw new InvalidOperationException("Unable to resolve a deviceId.");

        if (deviceId.Length > 200) deviceId = deviceId[..200];
        if (enrollmentSecret.Length > 200) enrollmentSecret = enrollmentSecret[..200];

        var candidates = new[]
        {
            $"{baseUrl}/api/agents/enroll",
            $"{baseUrl}/api/agent/enroll",
            $"{baseUrl}/api/auth/agents/enroll",
        };

        var payload = new
        {
            deviceId,
            enrollmentSecret,
            hostname,
            os,
            arch,
            version
        };

        Exception? lastErr = null;
        using var http = new HttpClient() { Timeout = TimeSpan.FromSeconds(20) };

        foreach (var url in candidates)
        {
            try
            {
                _log.LogInformation(
                    "Enrolling device {Host} (os={Os} arch={Arch} ver={Ver}) via {Url}",
                    hostname, os, arch, version, url);

                using var res = await http.PostAsJsonAsync(url, payload, ct);

                if ((int)res.StatusCode == 404)
                {
                    _log.LogDebug("Enroll endpoint {Url} returned 404; trying next candidate.", url);
                    continue;
                }

                var text = await res.Content.ReadAsStringAsync(ct);
                if (!res.IsSuccessStatusCode)
                    throw new InvalidOperationException($"Enrollment failed ( {(int)res.StatusCode} ): {text}");

                var (token, agentIdStr, deviceIdStr) = ParseEnrollResponse(text);
                if (string.IsNullOrWhiteSpace(token))
                    throw new InvalidOperationException("Enrollment succeeded but no agent token was returned.");

                _tokenStore.Save(new TokenStore.TokenData
                {
                    AgentToken = token,
                    AgentId = agentIdStr,
                    DeviceId = deviceIdStr ?? deviceId, // fall back to our request deviceId
                    RotateAfter = DateTime.UtcNow.AddDays(7)
                });

                _log.LogInformation("Enrolled as agentId={AgentId} deviceId={DeviceId}", agentIdStr, deviceIdStr);
                return;
            }
            catch (Exception ex)
            {
                lastErr = ex;
                _log.LogDebug(ex, "Enroll attempt failed.");
            }
        }

        throw new InvalidOperationException(
            $"Enrollment failed: {lastErr?.Message ?? "no enroll endpoint responded successfully"}",
            lastErr
        );
    }

    private static (string token, string? agentIdStr, string? deviceIdStr) ParseEnrollResponse(string json)
    {
        using var doc = JsonDocument.Parse(json);
        var root = doc.RootElement;

        string? token = TryString(root, "agentToken")
                        ?? TryString(root, "token")
                        ?? TryString(root, "accessToken");

        string? agentIdStr = TryString(root, "agentId")
                             ?? TryNumberAsString(root, "agentId")
                             ?? TryNestedNumberAsString(root, "agent", "id")
                             ?? TryNestedString(root, "agent", "id");

        string? deviceIdStr = TryString(root, "deviceId")
                              ?? TryNumberAsString(root, "deviceId")
                              ?? TryNestedNumberAsString(root, "device", "id")
                              ?? TryNestedString(root, "device", "id");

        return (token ?? "", agentIdStr, deviceIdStr);

        static string? TryString(JsonElement el, string key)
            => el.TryGetProperty(key, out var p) && p.ValueKind == JsonValueKind.String ? p.GetString() : null;

        static string? TryNumberAsString(JsonElement el, string key)
        {
            if (el.TryGetProperty(key, out var p) && p.ValueKind == JsonValueKind.Number && p.TryGetInt64(out var n))
                return n.ToString();
            return null;
        }

        static string? TryNestedNumberAsString(JsonElement el, string objKey, string innerKey)
        {
            if (el.TryGetProperty(objKey, out var obj) && obj.ValueKind == JsonValueKind.Object)
            {
                if (obj.TryGetProperty(innerKey, out var p))
                {
                    if (p.ValueKind == JsonValueKind.Number && p.TryGetInt64(out var n)) return n.ToString();
                    if (p.ValueKind == JsonValueKind.String) return p.GetString();
                }
            }
            return null;
        }

        static string? TryNestedString(JsonElement el, string objKey, string innerKey)
        {
            if (el.TryGetProperty(objKey, out var obj) && obj.ValueKind == JsonValueKind.Object)
            {
                if (obj.TryGetProperty(innerKey, out var p) && p.ValueKind == JsonValueKind.String)
                    return p.GetString();
            }
            return null;
        }
    }

    private static string DeriveDeviceId(string hostname)
    {
        if (RuntimeInformation.IsOSPlatform(OSPlatform.Windows))
        {
            try
            {
                using var key = Registry.LocalMachine.OpenSubKey(@"SOFTWARE\Microsoft\Cryptography");
                var mg = key?.GetValue("MachineGuid") as string;
                if (!string.IsNullOrWhiteSpace(mg)) return $"win-{mg}";
            }
            catch { /* ignore */ }
        }
        return hostname;
    }
}

===== END FILE remoteiq-minimal-e2e\agent-windows\RemoteIQ.Agent\Services\EnrollmentClient.cs =====

===== FILE: remoteiq-minimal-e2e\agent-windows\RemoteIQ.Agent\Services\WebSocketClient.cs (392 lines) =====
// remoteiq-minimal-e2e/agent-windows/RemoteIQ.Agent/Services/WebSocketClient.cs
using System.Diagnostics;
using System.Net.WebSockets;
using System.Runtime.InteropServices;
using System.Text;
using System.Text.Json;
using Microsoft.Extensions.Configuration;
using Microsoft.Extensions.Logging;
using RemoteIQ.Agent.Models;            // AgentConfig.From(...)
using RemoteIQ.Agent.Services.Security; // TokenStore

namespace RemoteIQ.Agent.Services;

/// <summary>
/// Optional WebSocket client. Connects to ws(s)://{ApiBaseHost}/ws,
/// sends an agent_hello right after connect, then listens for messages.
/// Supports "job_run_script" and replies with "job_result".
/// </summary>
public class WebSocketClient : IAsyncDisposable
{
    private readonly ILogger<WebSocketClient> _log;
    private readonly IConfiguration _configuration;
    private readonly TokenStore _tokenStore;

    private ClientWebSocket? _ws;
    private Uri? _endpoint;

    private const string AgentVersion = "1.0.0.0";

    public WebSocketClient(
        ILogger<WebSocketClient> log,
        IConfiguration configuration,
        TokenStore tokenStore)
    {
        _log = log;
        _configuration = configuration;
        _tokenStore = tokenStore;
    }

    public async Task StartAsync(CancellationToken ct)
    {
        var cfg = AgentConfig.From(_configuration);

        if (!Uri.TryCreate(cfg.ApiBase, UriKind.Absolute, out var apiBase))
        {
            _log.LogDebug("WebSocketClient: ApiBase not a valid URI; skipping WS.");
            return;
        }

        var wsScheme =
            apiBase.Scheme.Equals("https", StringComparison.OrdinalIgnoreCase) ? "wss" :
            apiBase.Scheme.Equals("http", StringComparison.OrdinalIgnoreCase) ? "ws" : null;

        if (wsScheme is null)
        {
            _log.LogDebug("WebSocketClient: ApiBase scheme not http/https; skipping WS.");
            return;
        }

        _endpoint = new UriBuilder(apiBase)
        {
            Scheme = wsScheme,
            Path = "/ws",
            Query = ""
        }.Uri;

        var tokenData = _tokenStore.Load();
        var token = tokenData?.AgentToken;
        if (string.IsNullOrWhiteSpace(token))
        {
            _log.LogDebug("WebSocketClient: no token yet; skipping WS connect.");
            return;
        }

        _ws = new ClientWebSocket();
        _ws.Options.SetRequestHeader("Authorization", $"Bearer {token}");

        try
        {
            _log.LogInformation("WebSocketClient: connecting to {Endpoint}", _endpoint);
            await _ws.ConnectAsync(_endpoint, ct);

            // Send hello immediately after connecting
            await SendHelloAsync(tokenData, token, ct);

            // Start the receive loop (fire-and-forget)
            _ = Task.Run(() => ReceiveLoopAsync(ct), ct);
        }
        catch (Exception ex)
        {
            _log.LogDebug(ex, "WebSocketClient: connect failed; continuing without WS.");
            await DisposeAsync();
        }
    }

    private async Task SendHelloAsync(TokenStore.TokenData? tokenData, string jwt, CancellationToken ct)
    {
        if (_ws is not { State: WebSocketState.Open }) return;

        var agentId = !string.IsNullOrWhiteSpace(tokenData?.AgentId)
            ? tokenData!.AgentId!
            : (TryGetClaimFromJwt(jwt, "agentId", "agent_id", "aid", "agent") ?? "unknown");

        var deviceId = !string.IsNullOrWhiteSpace(tokenData?.DeviceId)
            ? tokenData!.DeviceId!
            : (TryGetClaimFromJwt(jwt, "deviceId", "device_id", "did", "device") ?? "unknown");

        var hello = new
        {
            t = "agent_hello",
            agentId,
            deviceId,
            hostname = Environment.MachineName,
            os = "windows",
            arch = RuntimeInformation.OSArchitecture.ToString().ToLowerInvariant(),
            version = AgentVersion
        };

        await SendJsonAsync(hello, ct);
        _log.LogInformation("WebSocketClient: sent agent_hello (agentId={AgentId}, deviceId={DeviceId})", agentId, deviceId);
    }

    private static string? TryGetClaimFromJwt(string jwt, params string[] keys)
    {
        try
        {
            var parts = jwt.Split('.');
            if (parts.Length < 2) return null;

            static string Pad(string s) => s + new string('=', (4 - s.Length % 4) % 4);
            var payloadJson = Encoding.UTF8.GetString(
                Convert.FromBase64String(Pad(parts[1].Replace('-', '+').Replace('_', '/')))
            );

            using var doc = JsonDocument.Parse(payloadJson);
            var root = doc.RootElement;

            foreach (var key in keys)
            {
                if (root.TryGetProperty(key, out var el))
                {
                    return el.ValueKind switch
                    {
                        JsonValueKind.String => el.GetString(),
                        JsonValueKind.Number => el.TryGetInt64(out var n) ? n.ToString() : el.ToString(),
                        _ => el.ToString()
                    };
                }
            }

            if (root.TryGetProperty("claims", out var claims) && claims.ValueKind == JsonValueKind.Object)
            {
                foreach (var key in keys)
                {
                    if (claims.TryGetProperty(key, out var el2))
                    {
                        return el2.ValueKind == JsonValueKind.String ? el2.GetString() : el2.ToString();
                    }
                }
            }
        }
        catch { }
        return null;
    }

    private async Task ReceiveLoopAsync(CancellationToken ct)
    {
        if (_ws is null) return;

        var buffer = new byte[256 * 1024];
        var sb = new StringBuilder();

        while (!ct.IsCancellationRequested && _ws.State == WebSocketState.Open)
        {
            try
            {
                sb.Clear();
                WebSocketReceiveResult? result;
                do
                {
                    result = await _ws.ReceiveAsync(new ArraySegment<byte>(buffer), ct);
                    if (result.MessageType == WebSocketMessageType.Close)
                    {
                        _log.LogInformation("WebSocketClient: server closed connection.");
                        await DisposeAsync();
                        return;
                    }
                    sb.Append(Encoding.UTF8.GetString(buffer, 0, result.Count));
                } while (!result.EndOfMessage);

                var text = sb.ToString();
                if (string.IsNullOrWhiteSpace(text)) continue;

                HandleInbound(text, ct);
            }
            catch (OperationCanceledException) { }
            catch (Exception ex)
            {
                _log.LogDebug(ex, "WebSocketClient: receive error; closing.");
                break;
            }
        }

        await DisposeAsync();
    }

    private void HandleInbound(string json, CancellationToken ct)
    {
        try
        {
            using var doc = JsonDocument.Parse(json);
            var root = doc.RootElement;
            var t = root.TryGetProperty("t", out var tEl) && tEl.ValueKind == JsonValueKind.String ? tEl.GetString() : null;
            if (string.IsNullOrEmpty(t)) return;

            if (t == "job_run_script")
            {
                // Expected payload:
                // { t, jobId, language: "powershell" | "bash", scriptText, args?, env?, timeoutSec? }
                var jobId = root.GetProperty("jobId").GetString() ?? "";
                var language = root.GetProperty("language").GetString() ?? "powershell";
                var scriptText = root.GetProperty("scriptText").GetString() ?? "";
                var args = root.TryGetProperty("args", out var aEl) && aEl.ValueKind == JsonValueKind.Array
                    ? aEl.EnumerateArray().Select(x => x.GetString() ?? "").ToArray()
                    : Array.Empty<string>();
                var env = root.TryGetProperty("env", out var eEl) && eEl.ValueKind == JsonValueKind.Object
                    ? eEl.EnumerateObject().ToDictionary(p => p.Name, p => p.Value.GetString() ?? "")
                    : new Dictionary<string, string>();
                var timeoutSec = root.TryGetProperty("timeoutSec", out var toEl) && toEl.TryGetInt32(out var to)
                    ? to
                    : 120;

                _ = Task.Run(async () =>
                {
                    var sw = Stopwatch.StartNew();
                    int exitCode;
                    string stdout, stderr;
                    try
                    {
                        if (RuntimeInformation.IsOSPlatform(OSPlatform.Windows) && language.Equals("powershell", StringComparison.OrdinalIgnoreCase))
                        {
                            (exitCode, stdout, stderr) = await RunPowerShellAsync(scriptText, args, env, TimeSpan.FromSeconds(timeoutSec), ct);
                        }
                        else
                        {
                            (exitCode, stdout, stderr) = await RunShellAsync(scriptText, args, env, TimeSpan.FromSeconds(timeoutSec), ct);
                        }
                    }
                    catch (Exception ex)
                    {
                        exitCode = -1;
                        stdout = "";
                        stderr = $"Agent exception: {ex.Message}";
                    }
                    sw.Stop();

                    var result = new
                    {
                        t = "job_result",
                        jobId,
                        exitCode,
                        stdout,
                        stderr,
                        durationMs = (long)sw.ElapsedMilliseconds,
                        status = exitCode == 0 ? "succeeded" : "failed"
                    };
                    await SendJsonAsync(result, CancellationToken.None);
                }, ct);
            }
        }
        catch (Exception ex)
        {
            _log.LogDebug(ex, "WebSocketClient: failed to handle inbound message");
        }
    }

    private async Task SendJsonAsync(object payload, CancellationToken ct)
    {
        if (_ws is not { State: WebSocketState.Open }) return;
        var json = JsonSerializer.Serialize(payload);
        var bytes = Encoding.UTF8.GetBytes(json);
        await _ws.SendAsync(new ArraySegment<byte>(bytes), WebSocketMessageType.Text, true, ct);
    }

    private static async Task<(int exitCode, string stdout, string stderr)> RunPowerShellAsync(
        string scriptText,
        string[] args,
        Dictionary<string, string> env,
        TimeSpan timeout,
        CancellationToken ct)
    {
        // Use -NoProfile -NonInteractive for reliability; pass the script via -Command
        var psi = new ProcessStartInfo
        {
            FileName = "powershell.exe",
            Arguments = "-NoProfile -NonInteractive -ExecutionPolicy Bypass -Command -",
            RedirectStandardInput = true,
            RedirectStandardOutput = true,
            RedirectStandardError = true,
            UseShellExecute = false,
            CreateNoWindow = true,
        };

        foreach (var kv in env) psi.Environment[kv.Key] = kv.Value;

        using var proc = new Process { StartInfo = psi };
        proc.Start();

        await proc.StandardInput.WriteAsync(scriptText);
        await proc.StandardInput.FlushAsync();
        proc.StandardInput.Close();

        var stdoutTask = proc.StandardOutput.ReadToEndAsync();
        var stderrTask = proc.StandardError.ReadToEndAsync();

        using var cts = CancellationTokenSource.CreateLinkedTokenSource(ct);
        cts.CancelAfter(timeout);

        var exited = await Task.Run(() => proc.WaitForExit((int)timeout.TotalMilliseconds), cts.Token);
        if (!exited)
        {
            try { proc.Kill(true); } catch { }
            return (124, "", "Timeout");
        }

        var stdout = await stdoutTask;
        var stderr = await stderrTask;
        return (proc.ExitCode, stdout, stderr);
    }

    private static async Task<(int exitCode, string stdout, string stderr)> RunShellAsync(
        string scriptText,
        string[] args,
        Dictionary<string, string> env,
        TimeSpan timeout,
        CancellationToken ct)
    {
        // Generic /bin/bash -c 'script'
        var psi = new ProcessStartInfo
        {
            FileName = "/bin/bash",
            Arguments = "-c \"$@\" bash _ " + EscapeForBash(scriptText),
            RedirectStandardOutput = true,
            RedirectStandardError = true,
            UseShellExecute = false,
            CreateNoWindow = true,
        };

        foreach (var kv in env) psi.Environment[kv.Key] = kv.Value;

        using var proc = new Process { StartInfo = psi };
        proc.Start();

        var stdoutTask = proc.StandardOutput.ReadToEndAsync();
        var stderrTask = proc.StandardError.ReadToEndAsync();

        using var cts = CancellationTokenSource.CreateLinkedTokenSource(ct);
        cts.CancelAfter(timeout);

        var exited = await Task.Run(() => proc.WaitForExit((int)timeout.TotalMilliseconds), cts.Token);
        if (!exited)
        {
            try { proc.Kill(true); } catch { }
            return (124, "", "Timeout");
        }

        var stdout = await stdoutTask;
        var stderr = await stderrTask;
        return (proc.ExitCode, stdout, stderr);
    }

    private static string EscapeForBash(string s)
        => s.Replace("\\", "\\\\").Replace("\"", "\\\"").Replace("$", "\\$").Replace("`", "\\`");

    public async ValueTask DisposeAsync()
    {
        try
        {
            if (_ws is { State: WebSocketState.Open })
            {
                await _ws.CloseAsync(WebSocketCloseStatus.NormalClosure, "bye", CancellationToken.None);
            }
        }
        catch { }
        finally
        {
            _ws?.Dispose();
            _ws = null;
        }
    }
}

===== END FILE remoteiq-minimal-e2e\agent-windows\RemoteIQ.Agent\Services\WebSocketClient.cs =====

===== FILE: remoteiq-minimal-e2e\agent-windows\RemoteIQ.Agent\Models\Contracts.cs (116 lines) =====
// remoteiq-minimal-e2e/agent-windows/RemoteIQ.Agent/Models/Contracts.cs
using System;
using System.Collections.Generic;

namespace RemoteIQ.Agent.Models
{
    // ----- Enrollment -----
    // Backend expects: { enrollmentSecret, deviceId, hostname, os, arch, version }
    public record EnrollRequest(
        string EnrollmentSecret,
        string DeviceId,
        string Hostname,
        string Os,
        string Arch,
        string Version
    );

    public record EnrollResponse(
        string AgentId,
        string AgentToken,
        DateTime? RotateAfter
    );

    // ----- Ping (facts) -----
    // Sent by agent to /api/agent/ping (auth via Agent token)
    public record PingRequest(
        string? Os,
        string? Arch,
        string? Version,
        string? PrimaryIp,
        string? User
    );

    // ====== Legacy / future types (kept for later features) ======

    // OS/Agent info shapes you might reuse later for richer inventory
    public record OsInfo(string Family, string Edition, string Version, string Build, string Arch);
    public record AgentInfo(string Version, string Platform);

    // Optional: earlier heartbeat/inventory/metrics/logs contracts.
    // Safe to keep; they’re not used by the current flow.
    public record HeartbeatRequest(
        string AgentId,
        long UptimeSec,
        List<string> IpAddrs,
        string? LastInventoryHash,
        string AgentVersion
    );

    public record InventoryRequest(
        string AgentId,
        Hardware Hardware,
        OsInfo Os,
        Network Network,
        List<SoftwareItem> Software,
        List<ServiceItem> Services,
        List<ProcessItem> Processes
    );

    public record MetricsRequest(
        string AgentId,
        DateTime SampleTs,
        double CpuPct,
        double MemPct,
        Dictionary<string, double> DiskPct,
        List<TopProcess> TopProcesses
    );

    public record LogsRequest(
        string AgentId,
        string Source,
        string Level,
        List<LogEvent> Events
    );

    public record JobFetchResponse(
        string JobId,
        string Type,
        int TimeoutSec,
        string Command
    );

    public record JobResultRequest(
        string Status,
        int ExitCode,
        string Stdout,
        string Stderr
    );

    // ----- Inventory subtypes -----
    public record Hardware(
        Cpu Cpu,
        long RamBytes,
        List<Disk> Disks,
        List<Gpu> Gpu,
        Motherboard Motherboard,
        Bios Bios
    );
    public record Cpu(string Model, int Cores, int LogicalCpus);
    public record Disk(string Name, long SizeBytes, string Type);
    public record Gpu(string Name, string? DriverVersion);
    public record Motherboard(string Manufacturer, string Product);
    public record Bios(string Vendor, string Version, string? Date);

    public record Network(List<NetIf> Interfaces);
    public record NetIf(string Name, string Mac, List<string> Ipv4, List<string> Ipv6, string? Gateway, List<string> Dns);

    public record SoftwareItem(string DisplayName, string? Version, string? Publisher, string? InstallDate);
    public record ServiceItem(string Name, string DisplayName, string Status, string StartType);
    public record ProcessItem(int Pid, string Name, double CpuPct, long MemBytes);

    // ----- Metrics / Logs -----
    public record TopProcess(int Pid, string Name, double CpuPct, long MemBytes);
    public record LogEvent(int EventId, string Provider, DateTime Time, string Message);
}

===== END FILE remoteiq-minimal-e2e\agent-windows\RemoteIQ.Agent\Models\Contracts.cs =====

===== FILE: remoteiq-minimal-e2e\backend\src\checks\checks.controller.ts (150 lines) =====
//remoteiq-minimal-e2e\backend\src\checks\checks.controller.ts

import {
    Body,
    Controller,
    Delete,
    Get,
    HttpCode,
    HttpStatus,
    Param,
    ParseUUIDPipe,
    Post,
    Put,
    Query,
} from '@nestjs/common';
import { IsBoolean, IsEnum, IsInt, IsOptional, IsString, IsUUID, Max, Min, ValidateIf } from 'class-validator';
import { ChecksService, CheckScope, CheckType } from './checks.service';

/* ========================= DTOs for /api/checks ========================== */

class ListChecksQuery {
    @IsOptional() @IsEnum(CheckScope) scope?: CheckScope;
    @IsOptional() @IsEnum(CheckType) type?: CheckType;
    @IsOptional() @IsBoolean() enabled?: boolean;
    @IsOptional() @IsUUID() clientId?: string;
    @IsOptional() @IsUUID() siteId?: string;
    @IsOptional() @IsUUID() deviceId?: string;
    @IsOptional() @IsInt() @Min(1) @Max(200) limit?: number;
    @IsOptional() @IsString() cursor?: string;
}

class CreateCheckDto {
    @IsEnum(CheckScope) scope!: CheckScope;
    @ValidateIf((o) => o.scope !== CheckScope.GLOBAL) @IsUUID() @IsOptional() scopeId?: string;

    @IsEnum(CheckType) type!: CheckType;

    @IsString() name!: string;
    @IsString() @IsOptional() description?: string;

    @IsOptional() config?: unknown;     // per-type JSON schema validated in service
    @IsOptional() threshold?: unknown;  // per-type JSON schema validated in service

    @IsString() severityDefault!: 'WARN' | 'CRIT';

    @IsInt() @Min(15) @Max(86400) intervalSec!: number;
    @IsInt() @Min(1) @Max(600) timeoutSec!: number;

    @IsBoolean() enabled!: boolean;
}

class UpdateCheckDto {
    @IsOptional() @IsEnum(CheckScope) scope?: CheckScope;
    @ValidateIf((o) => o.scope && o.scope !== CheckScope.GLOBAL) @IsUUID() @IsOptional() scopeId?: string;

    @IsOptional() @IsEnum(CheckType) type?: CheckType;
    @IsOptional() @IsString() name?: string;
    @IsOptional() @IsString() description?: string;
    @IsOptional() config?: unknown;
    @IsOptional() threshold?: unknown;
    @IsOptional() @IsString() severityDefault?: 'WARN' | 'CRIT';
    @IsOptional() @IsInt() @Min(15) @Max(86400) intervalSec?: number;
    @IsOptional() @IsInt() @Min(1) @Max(600) timeoutSec?: number;
    @IsOptional() @IsBoolean() enabled?: boolean;
}

class RunOnDemandDto {
    @IsOptional() deviceIds?: string[] | null;
}

/* ===================== Existing /api/checks controller ==================== */

@Controller('api/checks')
export class ChecksController {
    constructor(private readonly checks: ChecksService) { }

    // TODO: add @UseGuards(AuthGuard) once your authZ guard is ready.

    @Get()
    async list(@Query() query: ListChecksQuery) {
        return this.checks.list(query);
    }

    @Post()
    async create(@Body() dto: CreateCheckDto) {
        // NOTE: Service will perform per-type schema validation server-side.
        return this.checks.create({
            ...dto,
            createdBy: 'system', // TODO: replace with req.user.id
            updatedBy: null,
            createdAt: new Date().toISOString(),
            updatedAt: new Date().toISOString(),
            id: '00000000-0000-0000-0000-000000000000', // placeholder, service should generate
        } as any);
    }

    @Put(':id')
    async update(@Param('id', new ParseUUIDPipe()) id: string, @Body() dto: UpdateCheckDto) {
        return this.checks.update(id, dto as any);
    }

    @Delete(':id')
    @HttpCode(HttpStatus.NO_CONTENT)
    async remove(@Param('id', new ParseUUIDPipe()) id: string) {
        await this.checks.remove(id);
        return;
    }

    @Post(':id/assignments/rebuild')
    async rebuild(@Param('id', new ParseUUIDPipe()) id: string) {
        return this.checks.rebuildAssignments(id);
    }

    @Post(':id/run')
    async runOnDemand(@Param('id', new ParseUUIDPipe()) id: string, @Body() dto: RunOnDemandDto) {
        return this.checks.runOnDemand(id, dto);
    }
}

/* ================= New device-scoped /api/devices/:id/checks route ========= */

function clamp(n: any, min: number, max: number, def: number): number {
    const x = Number(n);
    if (!Number.isFinite(x)) return def;
    return Math.max(min, Math.min(max, Math.trunc(x)));
}

@Controller('api/devices')
export class DeviceChecksController {
    constructor(private readonly checks: ChecksService) { }

    /**
     * Device-scoped checks for the UI:
     * GET /api/devices/:deviceId/checks?limit=100
     *
     * Returns:
     *  { items: Array<{ id, name, status, lastRun, output, ...optional fields }> }
     *  Optional advanced fields (type, severity, metrics, thresholds, tags, maintenance, dedupeKey)
     *  will be included by the service when available.
     */
    @Get(':deviceId/checks')
    async deviceChecks(
        @Param('deviceId', new ParseUUIDPipe()) deviceId: string,
        @Query('limit') limit?: string,
    ) {
        const lim = clamp(limit, 1, 200, 100);
        return this.checks.listByDevice(deviceId, lim);
    }
}

===== END FILE remoteiq-minimal-e2e\backend\src\checks\checks.controller.ts =====

===== FILE: remoteiq-minimal-e2e\backend\src\checks\checks.module.ts (20 lines) =====
// backend/src/checks/checks.module.ts
import { Module, forwardRef } from '@nestjs/common';
import { ChecksService } from './checks.service';
import { ChecksController, DeviceChecksController } from './checks.controller';
import { StorageModule } from '../storage/storage.module';
import { CommonModule } from '../common/common.module'; // <-- add
import { WsModule } from '../ws/ws.module';             // (optional, only if you also use DashboardGateway)

@Module({
    imports: [
        StorageModule,
        CommonModule,               // <-- needed for UiSocketRegistry
        forwardRef(() => WsModule), // ok to keep if you’re also using DashboardGateway elsewhere
    ],
    controllers: [ChecksController, DeviceChecksController],
    providers: [ChecksService],
    exports: [ChecksService],
})
export class ChecksModule { }

===== END FILE remoteiq-minimal-e2e\backend\src\checks\checks.module.ts =====

===== FILE: remoteiq-minimal-e2e\backend\src\checks\checks.service.ts (450 lines) =====
// backend/src/checks/checks.service.ts
import { Injectable, Logger, NotImplementedException } from '@nestjs/common';
import { PgPoolService } from '../storage/pg-pool.service';
import { UiSocketRegistry } from '../common/ui-socket-registry.service';

/* ========================= Types / helpers ========================= */

export enum CheckScope {
    DEVICE = 'DEVICE',
    SITE = 'SITE',
    CLIENT = 'CLIENT',
    GLOBAL = 'GLOBAL',
}

export enum CheckType {
    PING = 'PING',
    CPU = 'CPU',
    MEMORY = 'MEMORY',
    DISK = 'DISK',
    SERVICE = 'SERVICE',
    PROCESS = 'PROCESS',
    PORT = 'PORT',
    WINEVENT = 'WINEVENT',
    SOFTWARE = 'SOFTWARE',
    SECURITY = 'SECURITY',
    SCRIPT = 'SCRIPT',
    PATCH = 'PATCH',
    CERT = 'CERT',
    SMART = 'SMART',
    RDP = 'RDP',
    SMB = 'SMB',
    FIREWALL = 'FIREWALL',
}

export type DeviceCheckDTO = {
    id: string; // assignment id (device-scoped)
    name: string;
    status: 'Passing' | 'Warning' | 'Failing';
    lastRun: string | null;
    output: string;
};

type NormalizedRunStatus = 'OK' | 'WARN' | 'CRIT' | 'TIMEOUT' | 'UNKNOWN';

function normalizeStatus(s?: string | null): NormalizedRunStatus {
    const t = String(s || '').trim().toUpperCase();
    if (t === 'OK' || t === 'PASS' || t === 'PASSING') return 'OK';
    if (t === 'WARN' || t === 'WARNING') return 'WARN';
    if (t === 'TIMEOUT') return 'TIMEOUT';
    if (t === 'CRIT' || t === 'ERROR' || t === 'FAIL' || t === 'FAILING') return 'CRIT';
    return 'UNKNOWN';
}

function toUiStatus(s?: string | null): DeviceCheckDTO['status'] {
    switch (normalizeStatus(s)) {
        case 'OK': return 'Passing';
        case 'WARN': return 'Warning';
        default: return 'Failing';
    }
}

/* =============================== Service =============================== */

@Injectable()
export class ChecksService {
    private readonly logger = new Logger(ChecksService.name);

    // per-device debounce to avoid floods; value is NodeJS.Timeout in Node
    private readonly deviceDebounce = new Map<string, ReturnType<typeof setTimeout>>();

    constructor(
        private readonly pg: PgPoolService,
        private readonly uiSockets: UiSocketRegistry,
    ) { }

    /* ================= Schema guard (idempotent) ================= */

    /** Ensure minimal schema for checks exists (TEXT device_id). Safe to call often. */
    private async ensureSchema() {
        await this.pg.query(`
      CREATE EXTENSION IF NOT EXISTS pgcrypto;

      CREATE TABLE IF NOT EXISTS public.check_assignments (
        id          uuid PRIMARY KEY DEFAULT gen_random_uuid(),
        device_id   text NOT NULL,
        dedupe_key  text,
        check_type  text,
        check_name  text,
        created_at  timestamptz DEFAULT now(),
        updated_at  timestamptz DEFAULT now()
      );

      CREATE TABLE IF NOT EXISTS public.check_runs (
        id            uuid PRIMARY KEY DEFAULT gen_random_uuid(),
        assignment_id uuid,
        device_id     text NOT NULL,
        status        text NOT NULL,
        severity      text,
        metrics       jsonb,
        output        text,
        started_at    timestamptz,
        finished_at   timestamptz,
        created_at    timestamptz DEFAULT now()
      );

      -- Unique dedupe per device: explicit key OR type|name fallback
      CREATE UNIQUE INDEX IF NOT EXISTS check_assignments_uk
        ON public.check_assignments (
          device_id,
          COALESCE(
            NULLIF(dedupe_key, ''),
            LOWER(COALESCE(check_type,'')) || '|' || LOWER(COALESCE(check_name,''))
          )
        );

      CREATE INDEX IF NOT EXISTS check_assignments_device_id_idx ON public.check_assignments (device_id);
      CREATE INDEX IF NOT EXISTS check_runs_assignment_id_idx    ON public.check_runs (assignment_id);
      CREATE INDEX IF NOT EXISTS check_runs_device_id_idx        ON public.check_runs (device_id);
      CREATE INDEX IF NOT EXISTS check_runs_created_at_idx       ON public.check_runs (created_at);
    `);
    }

    /* ====================== Public read for UI ====================== */

    async listByDevice(deviceId: string, limit = 100): Promise<{ items: DeviceCheckDTO[] }> {
        if (!Number.isFinite(limit) || limit < 1) limit = 1;
        if (limit > 200) limit = 200;

        await this.ensureSchema();

        // Latest run per assignment + assignment name (no dependency on separate "checks" table)
        const sql = `
      WITH latest_run AS (
        SELECT
          cr.assignment_id,
          cr.status,
          cr.output,
          cr.finished_at AS last_run,
          ROW_NUMBER() OVER (PARTITION BY cr.assignment_id ORDER BY cr.finished_at DESC NULLS LAST) AS rn
        FROM public.check_runs cr
        WHERE cr.device_id = $1
      )
      SELECT
        a.id                      AS assignment_id,
        COALESCE(NULLIF(a.check_name,''), NULLIF(a.check_type,''), 'Check') AS check_name,
        lr.status                 AS run_status,
        lr.output                 AS run_output,
        lr.last_run               AS last_run
      FROM public.check_assignments a
      LEFT JOIN latest_run lr ON lr.assignment_id = a.id AND lr.rn = 1
      WHERE a.device_id = $1
      ORDER BY lr.last_run DESC NULLS LAST, check_name ASC
      LIMIT $2
    `;

        try {
            const { rows } = await this.pg.query<{
                assignment_id: string;
                check_name: string | null;
                run_status: string | null;
                run_output: string | null;
                last_run: Date | string | null;
            }>(sql, [deviceId, limit]);

            const items: DeviceCheckDTO[] = (rows || []).map((r) => ({
                id: r.assignment_id,
                name: r.check_name ?? 'Check',
                status: toUiStatus(r.run_status),
                lastRun: r.last_run ? new Date(r.last_run as any).toISOString() : null,
                output:
                    (r.run_output ?? '').length > 8192
                        ? (r.run_output ?? '').slice(0, 8192) + '…'
                        : r.run_output ?? '',
            }));

            return { items };
        } catch (err: any) {
            const msg = String(err?.message || '').toLowerCase();
            const code = String((err && (err.code || err?.original?.code)) || '');
            if (code === '42P01' || code === '42703' || (msg.includes('relation') && msg.includes('does not exist'))) {
                this.logger.warn('ChecksService.listByDevice: schema not ready; returning empty items.');
                return { items: [] };
            }
            this.logger.error('ChecksService.listByDevice failed', err?.stack || err);
            return { items: [] };
        }
    }

    /* ======================= Agent ingestion ====================== */

    /**
     * Ingest runs from an agent (TEXT deviceId).
     * - Upsert assignment per device using dedupeKey or (type|name) tuple
     * - Insert runs
     * Returns counts for observability.
     */
    async ingestAgentRuns(input: {
        agentId: string;
        deviceId: string; // TEXT (e.g., "win-...")
        runs: Array<{
            assignmentId?: string;
            dedupeKey?: string;
            checkType?: string;
            checkName?: string;
            status: string;
            severity?: 'WARN' | 'CRIT';
            metrics?: Record<string, any>;
            output?: string;
            startedAt?: string;
            finishedAt?: string;
        }>;
    }): Promise<{ inserted: number; assignmentsCreated: number }> {
        if (!input?.runs?.length) return { inserted: 0, assignmentsCreated: 0 };

        await this.ensureSchema();

        const MAX_OUTPUT = 64 * 1024; // 64 KiB

        // ---------- 1) Prepare src rows with a stable ordinal ----------
        const srcValues: string[] = [];
        const srcParams: any[] = [];
        let p = 1;

        for (let i = 0; i < input.runs.length; i++) {
            const r = input.runs[i];
            const dk = r.dedupeKey ?? null;
            const ct = (r.checkType || '').trim().toUpperCase() || null;
            const cn = (r.checkName || ct || 'Agent Check').trim().substring(0, 200) || 'Agent Check';

            // (ord, device_id, dedupe_key, check_type, check_name)
            srcValues.push(`($${p++}::int, $${p++}::text, $${p++}::text, $${p++}::text, $${p++}::text)`);
            srcParams.push(i + 1, input.deviceId, dk, ct, cn);
        }

        // ---------- 2) Insert missing assignments; count inserted via RETURNING ----------
        const insertSql = `
      WITH src(ord, device_id, dedupe_key, check_type, check_name) AS (
        VALUES ${srcValues.join(',')}
      )
      INSERT INTO public.check_assignments (device_id, dedupe_key, check_type, check_name)
      SELECT s.device_id, s.dedupe_key, s.check_type, s.check_name
      FROM src s
      ON CONFLICT (device_id,
        COALESCE(
          NULLIF(dedupe_key,''),
          LOWER(COALESCE(check_type,'')) || '|' || LOWER(COALESCE(check_name,''))
        ))
      DO NOTHING
      RETURNING id;
    `;
        const insertRes = await this.pg.query<{ id: string }>(insertSql, srcParams);
        const assignmentsCreated = (insertRes.rows || []).length;

        // ---------- 3) Resolve assignment ids for each src row in order ----------
        const mapSql = `
      WITH src(ord, device_id, dedupe_key, check_type, check_name) AS (
        VALUES ${srcValues.join(',')}
      )
      SELECT
        s.ord,
        ca.id::text AS assignment_id
      FROM src s
      JOIN public.check_assignments ca
        ON ca.device_id = s.device_id
       AND COALESCE(NULLIF(ca.dedupe_key,''),
            LOWER(COALESCE(ca.check_type,'')) || '|' || LOWER(COALESCE(ca.check_name,'')))
        = COALESCE(NULLIF(s.dedupe_key,''),
            LOWER(COALESCE(s.check_type,'')) || '|' || LOWER(COALESCE(s.check_name,'')))
      ORDER BY s.ord ASC;
    `;
        const mapRes = await this.pg.query<{ ord: number; assignment_id: string }>(mapSql, srcParams);
        const assignmentByOrd = new Map<number, string>();
        for (const r of mapRes.rows) assignmentByOrd.set(r.ord, r.assignment_id);

        // ---------- 4) Build runs aligned to the original order ----------
        const runValues: string[] = [];
        const runParams: any[] = [];
        p = 1;

        for (let i = 0; i < input.runs.length; i++) {
            const r = input.runs[i];
            const assignmentIdFromMap = assignmentByOrd.get(i + 1);

            const assignmentId =
                (r.assignmentId && /^[0-9a-fA-F-]{8}-[0-9a-fA-F-]{4}-[1-5][0-9a-fA-F-]{3}-[89abAB][0-9a-fA-F-]{3}-[0-9a-fA-F-]{12}$/.test(r.assignmentId))
                    ? r.assignmentId
                    : assignmentIdFromMap;

            if (!assignmentId) continue; // should not happen, but be defensive

            const status = normalizeStatus(r.status);
            const severity = r.severity === 'CRIT' ? 'CRIT' : r.severity === 'WARN' ? 'WARN' : null;
            const output = (r.output ?? '').slice(0, MAX_OUTPUT);
            const startedAt = r.startedAt ? new Date(r.startedAt) : new Date();
            const finishedAt = r.finishedAt ? new Date(r.finishedAt) : new Date();

            runValues.push(`(
        $${p++}::uuid,        -- assignment_id
        $${p++}::text,        -- device_id
        $${p++}::text,        -- status
        $${p++}::text,        -- severity
        $${p++}::jsonb,       -- metrics
        $${p++}::text,        -- output
        $${p++}::timestamptz, -- started_at
        $${p++}::timestamptz  -- finished_at
      )`);

            runParams.push(
                assignmentId,
                input.deviceId,
                status,
                severity,
                r.metrics ? JSON.stringify(r.metrics) : null,
                output,
                startedAt.toISOString(),
                finishedAt.toISOString(),
            );
        }

        let inserted = 0;
        if (runValues.length) {
            const insSql = `
        INSERT INTO public.check_runs
          (assignment_id, device_id, status, severity, metrics, output, started_at, finished_at)
        VALUES ${runValues.join(',')}
        RETURNING id;
      `;
            const ins = await this.pg.query<{ id: string }>(insSql, runParams);
            inserted = (ins.rows || []).length;
        }

        // Debounced UI broadcast per device
        if (inserted > 0) this.scheduleDeviceBroadcast(input.deviceId, inserted);

        this.logger.log(`ingested ${inserted} run(s) for device ${input.deviceId}; new assignments: ${assignmentsCreated}`);
        return { inserted, assignmentsCreated };
    }

    /** Debounce + emit device_checks_updated to subscribed UI sockets */
    private scheduleDeviceBroadcast(deviceId: string, changed: number) {
        const key = String(deviceId);
        const existing = this.deviceDebounce.get(key);
        if (existing) clearTimeout(existing as any);

        const handle = setTimeout(() => {
            try {
                const payload = {
                    t: 'device_checks_updated',
                    deviceId: key,
                    changed,
                    at: new Date().toISOString(),
                };
                const sent = this.uiSockets.broadcastToDevice(key, payload);
                this.logger.debug(`Broadcast device_checks_updated to ${sent} UI socket(s) for device ${key}`);
            } catch (e: any) {
                this.logger.warn(`Broadcast failed for device ${key}: ${e?.message ?? e}`);
            } finally {
                this.deviceDebounce.delete(key);
            }
        }, 750);

        this.deviceDebounce.set(key, handle);
    }

    /* ============== Server-driven assignments for agent (optional) ============ */

    async getAssignmentsForDevice(deviceId: string): Promise<{
        items: Array<{
            assignmentId: string;
            type: string | null;
            name: string | null;
            intervalSec: number; // static defaults for now
            timeoutSec: number;  // static defaults for now
            enabled: boolean;
            dedupeKey?: string | null;
            config?: any;
            thresholds?: any;
        }>;
    }> {
        await this.ensureSchema();

        // We don’t maintain a separate checks catalog here; return lightweight rows
        const { rows } = await this.pg.query(
            `
      SELECT
        a.id::text            AS assignment_id,
        a.check_type          AS check_type,
        a.check_name          AS check_name,
        a.dedupe_key          AS dedupe_key,
        a.created_at,
        a.updated_at
      FROM public.check_assignments a
      WHERE a.device_id = $1
      ORDER BY a.created_at DESC
      `,
            [deviceId]
        );

        return {
            items: rows.map((r: any) => ({
                assignmentId: r.assignment_id,
                type: r.check_type ?? null,
                name: r.check_name ?? null,
                // simple defaults (agents can override via config if/when you add it)
                intervalSec: 60,
                timeoutSec: 10,
                enabled: true,
                dedupeKey: r.dedupe_key,
                config: null,
                thresholds: null,
            })),
        };
    }

    /* ======================== Placeholders (unchanged) ======================== */

    async list(_params: {
        scope?: CheckScope;
        type?: CheckType;
        enabled?: boolean;
        clientId?: string;
        siteId?: string;
        deviceId?: string;
        limit?: number;
        cursor?: string;
    }): Promise<{ items: any[]; nextCursor?: string | null }> {
        throw new NotImplementedException('ChecksService.list not implemented yet');
    }

    async create(_payload: any): Promise<any> {
        throw new NotImplementedException('ChecksService.create not implemented yet');
    }

    async update(_id: string, _payload: any): Promise<any> {
        throw new NotImplementedException('ChecksService.update not implemented yet');
    }

    async remove(_id: string): Promise<{ id: string; deleted: boolean }> {
        throw new NotImplementedException('ChecksService.remove not implemented yet');
    }

    async rebuildAssignments(_id: string): Promise<{ checkId: string; assignmentsRebuilt: number }> {
        throw new NotImplementedException('ChecksService.rebuildAssignments not implemented yet');
    }

    async runOnDemand(_id: string, _params?: { deviceIds?: string[] | null }): Promise<{ enqueued: number }> {
        throw new NotImplementedException('ChecksService.runOnDemand not implemented yet');
    }
}

===== END FILE remoteiq-minimal-e2e\backend\src\checks\checks.service.ts =====

===== FILE: remoteiq-minimal-e2e\backend\src\devices\devices.service.ts (276 lines) =====
// backend/src/devices/devices.service.ts
import { Injectable, NotFoundException } from "@nestjs/common";
import { PgPoolService } from "../storage/pg-pool.service";

export type Device = {
  id: string;
  hostname: string;
  os: string;
  arch?: string | null;
  lastSeen: string | null;
  status: "online" | "offline";
  client?: string | null;
  site?: string | null;
  user?: string | null;
  version?: string | null;
  primaryIp?: string | null;
  agentUuid?: string | null; // <-- NEW
};

function decodeCursor(cur?: string | null) {
  if (!cur) return 0;
  try {
    const n = parseInt(Buffer.from(cur, "base64url").toString("utf8"), 10);
    return Number.isFinite(n) && n >= 0 ? n : 0;
  } catch {
    return 0;
  }
}
function encodeCursor(n: number) {
  return Buffer.from(String(n), "utf8").toString("base64url");
}

@Injectable()
export class DevicesService {
  constructor(private readonly pg: PgPoolService) { }

  async list(opts: {
    pageSize: number;
    cursor?: string | null;
    q?: string;
    status?: "online" | "offline";
    os?: string[];
  }): Promise<{ items: Device[]; nextCursor: string | null }> {
    const { pageSize, cursor, q, status, os } = opts;
    const offset = decodeCursor(cursor);

    const where: string[] = [];
    const params: any[] = [];
    let p = 1;

    if (q && q.trim()) {
      where.push(`hostname ILIKE $${p++}`);
      params.push(`%${q.trim()}%`);
    }
    if (status) {
      where.push(`status = $${p++}`);
      params.push(status);
    }
    if (os && os.length) {
      where.push(`lower(os) = ANY($${p++})`);
      params.push(os.map((o) => String(o).toLowerCase()));
    }

    const limit = pageSize + 1;
    const whereSql = where.length ? `WHERE ${where.join(" AND ")}` : "";

    const sql = `
      WITH agent_rows AS (
        SELECT
          a.id::text                                   AS id,
          COALESCE(a.hostname, a.device_id, 'unknown') AS hostname,
          COALESCE(NULLIF(a.os, ''), 'unknown')        AS os,
          a.arch                                       AS arch,
          a.last_seen_at                               AS last_seen,
          CASE
            WHEN a.last_seen_at IS NOT NULL
             AND a.last_seen_at > NOW() - INTERVAL '5 minutes'
            THEN 'online' ELSE 'offline'
          END                                          AS status,
          a.client                                     AS client,
          a.site                                       AS site,
          NULLIF(a.logged_in_user, '')                 AS "user",
          NULLIF(a.version, '')                        AS version,
          NULLIF(a.primary_ip, '')                     AS primary_ip,
          a.agent_uuid::text                           AS agent_uuid   -- <-- NEW
        FROM public.agents a
      ),
      device_rows AS (
        SELECT
          d.id::text            AS id,
          d.hostname            AS hostname,
          d.os                  AS os,
          d.arch                AS arch,
          d.last_seen           AS last_seen,
          d.status              AS status,
          d.client              AS client,
          d.site                AS site,
          NULLIF(d."user", '')  AS "user",
          NULL::text            AS version,
          NULL::text            AS primary_ip,
          NULL::text            AS agent_uuid                          -- <-- NEW
        FROM devices d
        WHERE NOT EXISTS (
          SELECT 1 FROM public.agents a
          WHERE COALESCE(a.hostname, a.device_id, 'unknown') = d.hostname
        )
      ),
      all_devs AS (
        SELECT * FROM agent_rows
        UNION ALL
        SELECT * FROM device_rows
      )
      SELECT id, hostname, os, arch, last_seen, status, client, site, "user", version, primary_ip, agent_uuid
      FROM all_devs
      ${whereSql}
      ORDER BY hostname ASC
      LIMIT ${limit} OFFSET ${offset};
    `;

    const { rows } = await this.pg.query(sql, params);
    const hasNext = rows.length > pageSize;

    const items = rows.slice(0, pageSize).map((r: any) => ({
      id: r.id,
      hostname: r.hostname,
      os: r.os,
      arch: r.arch ?? null,
      lastSeen: r.last_seen ? new Date(r.last_seen).toISOString() : null,
      status: r.status as "online" | "offline",
      client: r.client ?? null,
      site: r.site ?? null,
      user: r.user ?? null,
      version: r.version ?? null,
      primaryIp: r.primary_ip ?? null,
      agentUuid: r.agent_uuid ?? null, // <-- NEW
    })) as Device[];

    return { items, nextCursor: hasNext ? encodeCursor(offset + pageSize) : null };
  }

  async getOne(id: string): Promise<Device | null> {
    const sql = `
      WITH rows AS (
        SELECT
          0                                                AS pref,
          a.id::text                                      AS id,
          COALESCE(a.hostname, a.device_id, 'unknown')    AS hostname,
          COALESCE(NULLIF(a.os, ''), 'unknown')           AS os,
          a.arch                                          AS arch,
          a.last_seen_at                                  AS last_seen,
          CASE
            WHEN a.last_seen_at IS NOT NULL
             AND a.last_seen_at > NOW() - INTERVAL '5 minutes'
            THEN 'online' ELSE 'offline'
          END                                             AS status,
          a.client                                        AS client,
          a.site                                          AS site,
          NULLIF(a.logged_in_user, '')                    AS "user",
          NULLIF(a.version, '')                           AS version,
          NULLIF(a.primary_ip, '')                        AS primary_ip,
          a.agent_uuid::text                              AS agent_uuid  -- <-- NEW
        FROM public.agents a
        WHERE a.id::text = $1

        UNION ALL

        SELECT
          1                        AS pref,
          d.id::text               AS id,
          d.hostname               AS hostname,
          d.os                     AS os,
          d.arch                   AS arch,
          d.last_seen              AS last_seen,
          d.status                 AS status,
          d.client                 AS client,
          d.site                   AS site,
          NULLIF(d."user", '')     AS "user",
          NULL::text               AS version,
          NULL::text               AS primary_ip,
          NULL::text               AS agent_uuid                         -- <-- NEW
        FROM devices d
        WHERE d.id::text = $1
      )
      SELECT id, hostname, os, arch, last_seen, status, client, site, "user", version, primary_ip, agent_uuid
      FROM rows
      ORDER BY pref ASC
      LIMIT 1;
    `;
    const { rows } = await this.pg.query(sql, [id]);
    const r = rows[0];
    if (!r) return null;

    return {
      id: r.id,
      hostname: r.hostname,
      os: r.os,
      arch: r.arch ?? null,
      lastSeen: r.last_seen ? new Date(r.last_seen).toISOString() : null,
      status: r.status as "online" | "offline",
      client: r.client ?? null,
      site: r.site ?? null,
      user: r.user ?? null,
      version: r.version ?? null,
      primaryIp: r.primary_ip ?? null,
      agentUuid: r.agent_uuid ?? null, // <-- NEW
    };
  }

  async listSoftware(
    id: string
  ): Promise<
    Array<{
      id: string;
      name: string;
      version: string;
      publisher?: string | null;
      installDate?: string | null;
    }>
  > {
    const { rows } = await this.pg.query(
      `
      SELECT
        s.id::text            AS id,
        s.name,
        s.version,
        s.publisher,
        s.install_date        AS install_date
      FROM public.agent_software s
      JOIN public.agents a ON a.id = s.agent_id
      WHERE a.id::text = $1
      ORDER BY lower(s.name) ASC, COALESCE(s.version,'') ASC
      `,
      [id]
    );

    return rows.map((r: any) => ({
      id: r.id,
      name: r.name,
      version: r.version ?? "",
      publisher: r.publisher ?? null,
      installDate: r.install_date ?? null,
    }));
  }

  // NEW: create uninstall job in a simple job queue
  async requestUninstall(
    id: string,
    body: { name: string; version?: string | null }
  ): Promise<string> {
    // ensure agent exists
    const { rows: arows } = await this.pg.query(
      `SELECT id FROM public.agents WHERE id::text = $1`,
      [id]
    );
    const agentId: number | undefined = arows[0]?.id;
    if (!agentId) throw new NotFoundException("Agent not found");

    const payload = {
      action: "uninstall_software",
      name: body.name,
      version: body.version ?? null,
    };

    const { rows } = await this.pg.query(
      `
      INSERT INTO public.agent_jobs (agent_id, kind, payload)
      VALUES ($1, $2, $3::jsonb)
      RETURNING id::text AS id
      `,
      [agentId, "uninstall_software", JSON.stringify(payload)]
    );

    return rows[0].id as string;
  }
}

===== END FILE remoteiq-minimal-e2e\backend\src\devices\devices.service.ts =====

===== FILE: remoteiq-minimal-e2e\backend\src\agents\agents.controller.ts (223 lines) =====
// src/agents/agents.controller.ts
import {
  Body, Controller, Get, Post, Query, Req,
  UseGuards, UsePipes, ValidationPipe, BadRequestException, ForbiddenException,
} from '@nestjs/common';
import { AuthService } from '../auth/auth.service';
import { EnrollAgentDto } from './dto/enroll-agent.dto';
import { AgentsService } from './agents.service';
import { AgentTokenGuard, getAgentFromRequest } from '../common/agent-token.util';
import { UpdateAgentFactsDto } from './dto/update-agent-facts.dto';
import { SubmitSoftwareDto } from './dto/submit-software.dto';
import { ChecksService } from '../checks/checks.service';
import {
  IsArray, IsDateString, IsObject, IsOptional, IsString,
  MaxLength, ValidateNested, ArrayMinSize,
} from 'class-validator';
import { Type } from 'class-transformer';

/* ----------------------------- DTOs for runs ----------------------------- */

export enum AgentRunStatus {
  OK = 'OK',
  PASS = 'PASS',
  PASSING = 'PASSING',
  WARN = 'WARN',
  WARNING = 'WARNING',
  CRIT = 'CRIT',
  ERROR = 'ERROR',
  FAIL = 'FAIL',
  FAILING = 'FAILING',
  TIMEOUT = 'TIMEOUT',
  UNKNOWN = 'UNKNOWN',
}

export class SubmitCheckRunItemDto {
  @IsOptional()
  @IsString()
  @MaxLength(36)
  assignmentId?: string; // uuid string (not strictly validated to allow empty envs)

  @IsOptional()
  @IsString()
  @MaxLength(256)
  dedupeKey?: string;

  @IsOptional()
  @IsString()
  @MaxLength(64)
  checkType?: string;

  @IsOptional()
  @IsString()
  @MaxLength(200)
  checkName?: string;

  @IsString()
  status!: string;

  @IsOptional()
  @IsString()
  @MaxLength(8)
  severity?: 'WARN' | 'CRIT';

  @IsOptional()
  @IsObject()
  metrics?: Record<string, any>;

  @IsOptional()
  @IsString()
  @MaxLength(200000)
  output?: string;

  @IsOptional()
  @IsDateString()
  startedAt?: string;

  @IsOptional()
  @IsDateString()
  finishedAt?: string;
}

export class SubmitCheckRunsDto {
  @IsOptional()
  @IsString() // <— accepts "win-..." style ids
  deviceId?: string;

  @IsArray()
  @ArrayMinSize(1)
  @ValidateNested({ each: true })
  @Type(() => SubmitCheckRunItemDto)
  runs!: SubmitCheckRunItemDto[];
}

/* ----------------------------- Rate limiter ------------------------------ */
const rlWindowMs = 10_000; // 10s
const rlMaxRequests = 20;  // 20 per window
const rlState = new Map<string, number[]>();

function checkRate(agentIdStr: string) {
  const now = Date.now();
  const arr = rlState.get(agentIdStr) ?? [];
  const fresh = arr.filter(ts => now - ts < rlWindowMs);
  fresh.push(now);
  rlState.set(agentIdStr, fresh);
  if (fresh.length > rlMaxRequests) {
    throw new ForbiddenException('Agent is sending check data too fast; back off and retry later.');
  }
}

@Controller('/api/agent')
@UsePipes(new ValidationPipe({ whitelist: true, transform: true, forbidNonWhitelisted: true }))
export class AgentsController {
  constructor(
    private readonly auth: AuthService,
    private readonly agents: AgentsService,
    private readonly checks: ChecksService,
  ) { }

  @Post('/enroll')
  async enroll(
    @Body() body: EnrollAgentDto
  ): Promise<{ agentId: string; agentUuid: string | null; deviceId: string; agentToken: string }> {
    const res: any = await this.auth.enrollAgent(body);

    const agentId = String(res?.agentId ?? res?.agent?.id ?? '');
    const deviceId = String(res?.deviceId ?? res?.device?.id ?? body?.deviceId ?? '');
    const agentToken = String(res?.agentToken ?? res?.token ?? res?.accessToken ?? '');

    if (!agentToken || !agentId) {
      throw new Error('Enrollment succeeded but missing token or agentId in response.');
    }

    let agentUuid: string | null = null;
    try {
      agentUuid = await this.agents.getAgentUuidById(Number(agentId));
    } catch {
      agentUuid = null;
    }

    return { agentId, agentUuid, deviceId, agentToken };
  }

  @Post('/ping')
  @UseGuards(AgentTokenGuard)
  async ping(@Req() req: any, @Body() body: UpdateAgentFactsDto) {
    const agent = getAgentFromRequest(req);
    await this.agents.updateFacts(Number((agent as any).id), body ?? {});
    return { ok: true };
  }

  @Post('/software')
  @UseGuards(AgentTokenGuard)
  async submitSoftware(@Req() req: any, @Body() body: SubmitSoftwareDto) {
    const agent = getAgentFromRequest(req);
    await this.agents.upsertSoftware(Number((agent as any).id), body?.items ?? []);
    return { ok: true, count: body?.items?.length ?? 0 };
  }

  // ===================== Check runs ingestion ======================
  @Post('/check-runs')
  @UseGuards(AgentTokenGuard)
  async submitCheckRuns(@Req() req: any, @Body() body: SubmitCheckRunsDto) {
    const agent = getAgentFromRequest(req);

    checkRate(String((agent as any).id));

    const tokenDeviceRaw = (agent as any)?.deviceId ?? (agent as any)?.device_id;
    const deviceIdFromToken: string | undefined =
      tokenDeviceRaw != null ? String(tokenDeviceRaw) : undefined;

    const deviceIdFromBody: string | undefined =
      body?.deviceId ? String(body.deviceId) : undefined;

    const deviceId = deviceIdFromBody ?? deviceIdFromToken;

    if (!deviceId) {
      throw new BadRequestException('deviceId is required (bind agent to device first, or include in body).');
    }
    if (deviceIdFromBody && deviceIdFromToken && deviceIdFromBody !== deviceIdFromToken) {
      throw new ForbiddenException('deviceId in body does not match the agent binding.');
    }
    if (!Array.isArray(body?.runs) || body.runs.length === 0) {
      throw new BadRequestException('runs is required and must be a non-empty array');
    }

    const result = await this.checks.ingestAgentRuns({
      agentId: String((agent as any).id),
      deviceId, // TEXT id
      runs: body.runs.map(r => ({
        assignmentId: r.assignmentId,
        dedupeKey: r.dedupeKey,
        checkType: r.checkType,
        checkName: r.checkName,
        status: r.status,
        severity: r.severity,
        metrics: r.metrics,
        output: r.output,
        startedAt: r.startedAt,
        finishedAt: r.finishedAt,
      })),
    });

    return { ok: true, inserted: result.inserted, assignmentsCreated: result.assignmentsCreated };
  }

  @Get('/assignments')
  @UseGuards(AgentTokenGuard)
  async getAssignments(@Req() req: any, @Query('deviceId') deviceId?: string) {
    const agent = getAgentFromRequest(req);
    const tokenDeviceRaw = (agent as any)?.deviceId ?? (agent as any)?.device_id;
    const boundDevice: string | undefined =
      tokenDeviceRaw != null ? String(tokenDeviceRaw) : undefined;

    const effective = deviceId ?? boundDevice;
    if (!effective) {
      throw new BadRequestException('deviceId is required (either query param or bound to agent).');
    }

    const { items } = await this.checks.getAssignmentsForDevice(effective);
    return { items };
  }
}

===== END FILE remoteiq-minimal-e2e\backend\src\agents\agents.controller.ts =====

===== FILE: remoteiq-minimal-e2e\backend\src\agents\agents.module.ts (17 lines) =====
// remoteiq-minimal-e2e\backend\src\agents\agents.module.ts
import { Module } from '@nestjs/common';
import { AgentsController } from './agents.controller';
import { AgentsService } from './agents.service';
import { AuthModule } from '../auth/auth.module';
import { StorageModule } from '../storage/storage.module'; // provides PgPoolService
import { CommonModule } from '../common/common.module';    // provides AgentTokenGuard utilities
import { ChecksModule } from '../checks/checks.module';    // <-- provides ChecksService to controller

@Module({
  imports: [AuthModule, StorageModule, CommonModule, ChecksModule],
  controllers: [AgentsController],
  providers: [AgentsService],
  exports: [AgentsService],
})
export class AgentsModule { }

===== END FILE remoteiq-minimal-e2e\backend\src\agents\agents.module.ts =====

===== FILE: remoteiq-minimal-e2e\backend\src\agents\agents.service.ts (142 lines) =====
// backend/src/agents/agents.service.ts
import { Injectable } from "@nestjs/common";
import { PgPoolService } from "../storage/pg-pool.service";

// DTOs are validated in controllers; here we accept partials safely.
type UpdateAgentFacts = Partial<{
    hostname: string;
    os: string;
    arch: string | null;         // NOT NULL in DB → we will ignore null updates
    version: string | null;      // nullable
    primaryIp: string | null;    // nullable
    client: string | null;       // nullable
    site: string | null;         // nullable
    user: string | null;         // alias accepted from agent payloads
    loggedInUser: string | null; // alias (both map to logged_in_user)
}>;

type SoftwareItem = {
    name: string;
    version?: string | null;
    publisher?: string | null;
    installDate?: string | null;
};

@Injectable()
export class AgentsService {
    constructor(private readonly pg: PgPoolService) { }

    /** Return the stable UUID mirror for a numeric agent id (or null if absent). */
    async getAgentUuidById(agentId: number): Promise<string | null> {
        try {
            const { rows } = await this.pg.query<{ agent_uuid: string | null }>(
                `SELECT agent_uuid FROM public.agents WHERE id = $1 LIMIT 1`,
                [agentId]
            );
            return rows[0]?.agent_uuid ?? null;
        } catch {
            return null;
        }
    }

    /**
     * Update agent facts and bump last_seen_at.
     * - Only updates provided fields.
     * - Never sets NOT NULL columns to NULL.
     */
    async updateFacts(agentId: number, facts: UpdateAgentFacts): Promise<void> {
        const sets: string[] = [`last_seen_at = NOW()`];
        const params: any[] = [];
        let p = 1;

        // For columns that are NOT NULL in your schema, do not accept null writes.
        const setIfDefined = (col: string, val: any) => {
            if (val !== undefined) {
                sets.push(`${col} = $${p++}`);
                params.push(val);
            }
        };
        const setIfNullable = (col: string, val: any) => {
            if (val !== undefined) {
                sets.push(`${col} = $${p++}`);
                params.push(val); // can be null; that’s fine for nullable cols
            }
        };
        const setIfNotNull = (col: string, val: any) => {
            if (val !== undefined && val !== null) {
                sets.push(`${col} = $${p++}`);
                params.push(val);
            }
        };

        // Likely NOT NULL in table
        setIfDefined("hostname", facts.hostname);
        setIfDefined("os", facts.os);
        setIfNotNull("arch", facts.arch); // skip if null/undefined

        // Nullable fields
        setIfNullable("version", facts.version ?? undefined);
        setIfNullable("primary_ip", facts.primaryIp ?? undefined);
        setIfNullable("client", facts.client ?? undefined);
        setIfNullable("site", facts.site ?? undefined);

        // Accept both 'user' and 'loggedInUser' from payloads → store in logged_in_user
        const loginUser = facts.user ?? facts.loggedInUser;
        setIfNullable("logged_in_user", loginUser ?? undefined);

        const sql = `
      UPDATE public.agents
      SET ${sets.join(", ")}
      WHERE id = $${p}
    `;
        params.push(agentId);

        await this.pg.query(sql, params);
    }

    /** Upsert full software inventory for an agent. */
    async upsertSoftware(agentId: number, items: SoftwareItem[]): Promise<void> {
        if (!Array.isArray(items) || items.length === 0) return;

        const valuesSql: string[] = [];
        const params: any[] = [];
        let p = 1;

        for (const it of items) {
            const name = (it.name || "").trim();
            if (!name) continue;

            valuesSql.push(`(
        $${p++}::integer,
        $${p++}::text,
        $${p++}::text,
        $${p++}::text,
        $${p++}::timestamptz
      )`);

            params.push(
                agentId,
                name,
                it.version ?? null,
                it.publisher ?? null,
                it.installDate ? new Date(it.installDate) : null
            );
        }

        if (valuesSql.length === 0) return;

        // Requires a matching unique index/constraint in DB:
        // CREATE UNIQUE INDEX IF NOT EXISTS agent_software_uk ON public.agent_software (agent_id, lower(name), COALESCE(version,''));
        const sql = `
      INSERT INTO public.agent_software (agent_id, name, version, publisher, install_date)
      VALUES ${valuesSql.join(",")}
      ON CONFLICT (agent_id, lower(name), COALESCE(version,'')) DO UPDATE
      SET
        publisher = EXCLUDED.publisher,
        install_date = EXCLUDED.install_date
    `;
        await this.pg.query(sql, params);
    }
}


===== END FILE remoteiq-minimal-e2e\backend\src\agents\agents.service.ts =====

===== FILE: remoteiq-minimal-e2e\backend\src\common\admin-api.guard.ts (14 lines) =====
import { CanActivate, ExecutionContext, Injectable, UnauthorizedException } from "@nestjs/common";

@Injectable()
export class AdminApiGuard implements CanActivate {
  canActivate(ctx: ExecutionContext): boolean {
    const req = ctx.switchToHttp().getRequest();
    const key = req.header("x-admin-api-key");
    const expected = process.env.ADMIN_API_KEY || "";
    if (!expected || key !== expected) {
      throw new UnauthorizedException("Invalid or missing x-admin-api-key");
    }
    return true;
  }
}
===== END FILE remoteiq-minimal-e2e\backend\src\common\admin-api.guard.ts =====

===== FILE: remoteiq-minimal-e2e\backend\src\common\agent-token.util.ts (98 lines) =====
// remoteiq-minimal-e2e/backend/src/common/agent-token.util.ts
import { Injectable, CanActivate, ExecutionContext, UnauthorizedException } from '@nestjs/common';
import type { Request } from 'express';
import crypto from 'node:crypto';
import jwt from 'jsonwebtoken';
import { PgPoolService } from '../storage/pg-pool.service';

/** ───────────────────────────
 *  Crypto helpers
 *  ─────────────────────────── */
const algo = 'sha256';

export function hashToken(token: string): string {
  return crypto.createHash(algo).update(token, 'utf8').digest('hex');
}

export function newOpaqueToken(): string {
  return crypto.randomBytes(24).toString('base64url');
}

export function signAgentJwt(agentId: string): string {
  const secret = process.env.JWT_SECRET || 'dev';
  return jwt.sign({ sub: agentId, typ: 'agent' }, secret, { algorithm: 'HS256' });
}

export function verifyAgentJwt(token: string): string | null {
  try {
    const secret = process.env.JWT_SECRET || 'dev';
    const payload = jwt.verify(token, secret) as any;
    return payload?.sub as string;
  } catch {
    return null;
  }
}

/** ───────────────────────────
 *  Request augmentation helper
 *  ─────────────────────────── */
export type AgentAuthContext = {
  id: number;
  token?: string;
};

export function getAgentFromRequest(req: any): AgentAuthContext {
  return (req as any).agent as AgentAuthContext;
}

/** ───────────────────────────
 *  DB row shape(s)
 *  ─────────────────────────── */
type AgentRow = {
  id: number;
  token_hash: string | null;
};

/** ───────────────────────────
 *  Bearer token guard for agents
 *  ─────────────────────────── */
@Injectable()
export class AgentTokenGuard implements CanActivate {
  constructor(private readonly db: PgPoolService) { }

  async canActivate(context: ExecutionContext): Promise<boolean> {
    const req = context.switchToHttp().getRequest<Request>();

    const authHeader = req.headers['authorization'];
    if (!authHeader || Array.isArray(authHeader)) {
      throw new UnauthorizedException('Missing Authorization header');
    }

    const match = /^Bearer\s+(.+)$/.exec(authHeader);
    if (!match) {
      throw new UnauthorizedException('Invalid Authorization header format');
    }

    const token = match[1];
    const tokenHash = hashToken(token);

    // Use the typed query helper (no private pool access)
    const { rows } = await this.db.query<AgentRow>(
      `SELECT id, token_hash
         FROM public.agents
        WHERE token_hash = $1
        LIMIT 1`,
      [tokenHash],
    );

    if (rows.length === 0) {
      throw new UnauthorizedException('Invalid or unknown agent token');
    }

    // Stash minimal agent context on the request
    (req as any).agent = { id: rows[0].id, token } as AgentAuthContext;

    return true;
  }
}

===== END FILE remoteiq-minimal-e2e\backend\src\common\agent-token.util.ts =====

===== FILE: remoteiq-minimal-e2e\backend\src\common\auth-cookie.middleware.ts (42 lines) =====
import { Injectable, NestMiddleware } from "@nestjs/common";
import type { Request, Response, NextFunction } from "express";
import { JwtService } from "@nestjs/jwt";

type AnyReq = Request & { user?: any };

@Injectable()
export class AuthCookieMiddleware implements NestMiddleware {
    constructor(private readonly jwt: JwtService) { }

    use(req: AnyReq, _res: Response, next: NextFunction) {
        try {
            const cookieName = process.env.AUTH_COOKIE_NAME || "auth_token";
            const token = (req as any).cookies?.[cookieName];

            if (!token) {
                return next();
            }

            // If tokens were signed with "sub" as user id (recommended)
            const payload = this.jwt.verify(token, {
                secret: process.env.JWT_SECRET ?? "dev-secret",
            });

            // Normalize a common shape for controllers:
            // prefer `sub`, but support `id` for older tokens
            const id = (payload as any).sub ?? (payload as any).id;
            if (id) {
                req.user = {
                    id,
                    email: (payload as any).email,
                    name: (payload as any).name,
                    role: (payload as any).role,
                };
            }
        } catch {
            // ignore invalid/expired token; route can still be public
        }
        next();
    }
}

===== END FILE remoteiq-minimal-e2e\backend\src\common\auth-cookie.middleware.ts =====

===== FILE: remoteiq-minimal-e2e\backend\src\common\common.module.ts (14 lines) =====
// backend/src/common/common.module.ts
import { Module } from '@nestjs/common';
import { SocketRegistry } from './socket-registry.service';
import { UiSocketRegistry } from './ui-socket-registry.service';
import { AgentTokenGuard } from './agent-token.util';
import { StorageModule } from '../storage/storage.module';

@Module({
    imports: [StorageModule],
    providers: [SocketRegistry, UiSocketRegistry, AgentTokenGuard],
    exports: [SocketRegistry, UiSocketRegistry, AgentTokenGuard],
})
export class CommonModule { }

===== END FILE remoteiq-minimal-e2e\backend\src\common\common.module.ts =====

===== FILE: remoteiq-minimal-e2e\backend\src\common\health.controller.ts (8 lines) =====
// src/common/health.controller.ts
import { Controller, Get } from '@nestjs/common';

@Controller('/healthz')
export class HealthController {
    @Get() get() { return { ok: true, ts: Date.now() }; }
}

===== END FILE remoteiq-minimal-e2e\backend\src\common\health.controller.ts =====

===== FILE: remoteiq-minimal-e2e\backend\src\common\online.util.ts (6 lines) =====
// src/common/online.util.ts
export function isAgentOnline(lastHeartbeatAt?: Date | null, thresholdMs = 30_000): boolean {
    if (!lastHeartbeatAt) return false;
    return Date.now() - new Date(lastHeartbeatAt).getTime() < thresholdMs;
}

===== END FILE remoteiq-minimal-e2e\backend\src\common\online.util.ts =====

===== FILE: remoteiq-minimal-e2e\backend\src\common\pagination.ts (11 lines) =====
// src/common/pagination.ts
export function encodeCursor(val: string | number | Date): string {
  const s = typeof val === "string" ? val : (val instanceof Date ? val.toISOString() : String(val));
  return Buffer.from(s, "utf8").toString("base64url");
}
export function decodeCursor(cursor?: string): string | undefined {
  if (!cursor) return undefined;
  try { return Buffer.from(cursor, "base64url").toString("utf8"); }
  catch { return undefined; }
}

===== END FILE remoteiq-minimal-e2e\backend\src\common\pagination.ts =====

===== FILE: remoteiq-minimal-e2e\backend\src\common\socket-registry.service.ts (61 lines) =====
//remoteiq-minimal-e2e\backend\src\common\socket-registry.service.ts

import { Injectable } from "@nestjs/common";
import type { WebSocket } from "ws";

export type AgentSocket = WebSocket & {
    agentId?: string;
    deviceId?: string;
};

@Injectable()
export class SocketRegistry {
    private socketsByAgent = new Map<string, AgentSocket>();
    private socketsByDevice = new Map<string, AgentSocket>();

    // --- Primary API ---
    getByAgent(agentId: string): AgentSocket | undefined {
        return this.socketsByAgent.get(agentId);
    }

    getByDevice(deviceId: string): AgentSocket | undefined {
        return this.socketsByDevice.get(deviceId);
    }

    set(agentId: string | undefined, deviceId: string | undefined, socket: AgentSocket) {
        if (agentId) {
            this.socketsByAgent.set(agentId, socket);
            socket.agentId = agentId;
        }
        if (deviceId) {
            this.socketsByDevice.set(deviceId, socket);
            socket.deviceId = deviceId;
        }
    }

    deleteByAgent(agentId: string) {
        const sock = this.socketsByAgent.get(agentId);
        if (sock?.deviceId) this.socketsByDevice.delete(sock.deviceId);
        this.socketsByAgent.delete(agentId);
    }

    deleteByDevice(deviceId: string) {
        const sock = this.socketsByDevice.get(deviceId);
        if (sock?.agentId) this.socketsByAgent.delete(sock.agentId);
        this.socketsByDevice.delete(deviceId);
    }

    // --- Back-compat aliases (so older callers like dispatcher.service can keep using .get) ---
    /** Alias for getByAgent */
    get(agentId: string): AgentSocket | undefined {
        return this.getByAgent(agentId);
    }
    /** Aliases in case other code uses these names */
    setByAgent(agentId: string, socket: AgentSocket) {
        this.set(agentId, /*deviceId*/ undefined, socket);
    }
    setByDevice(deviceId: string, socket: AgentSocket) {
        this.set(/*agentId*/ undefined, deviceId, socket);
    }
}

===== END FILE remoteiq-minimal-e2e\backend\src\common\socket-registry.service.ts =====

===== FILE: remoteiq-minimal-e2e\backend\src\common\types.ts (17 lines) =====
export type WSIncoming =
  | { t: "hello"; agentId: string; capabilities: string[]; os: string; arch: string; hostname: string; version: string }
  | { t: "hb"; at: string; metrics?: { cpu?: number; mem?: number } }
  | { t: "job_result"; jobId: string; exitCode: number; stdout: string; stderr: string; startedAt: string; finishedAt: string };

export type WSOutgoing =
  | { t: "ack"; id: string }
  | {
    t: "job_run_script";
    jobId: string;
    language: "powershell" | "bash";
    scriptText: string;
    args?: string[];
    env?: Record<string, string>;
    timeoutSec?: number;
  };

===== END FILE remoteiq-minimal-e2e\backend\src\common\types.ts =====

===== FILE: remoteiq-minimal-e2e\backend\src\common\ui-socket-registry.service.ts (200 lines) =====
// backend/src/common/ui-socket-registry.service.ts
import { Injectable, Logger } from "@nestjs/common";
import type { WebSocket } from "ws";

/**
 * UI (dashboard) socket with metadata.
 * - userId: authenticated user identifier (string)
 * - subscriptions: deviceIds this socket has subscribed to
 */
export type UiSocket = WebSocket & {
    userId?: string;
    subscriptions?: Set<string>;
};

function isOpen(ws: WebSocket): boolean {
    // 'OPEN' is a numeric const on ws WebSocket instances
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    return (ws as any).readyState === (ws as any).OPEN;
}

/**
 * Registry for **dashboard/user** WebSocket connections and their subscriptions.
 * Isolation from the Agent socket registry keeps privileges and broadcasting clean.
 *
 * Notes:
 * - In-memory only (per-process). For multi-node deployments, back this with Redis or a message bus.
 * - Broadcast methods return the number of sockets that were attempted (best-effort).
 */
@Injectable()
export class UiSocketRegistry {
    private readonly log = new Logger("UiSocketRegistry");

    /** All sockets for a given user */
    private socketsByUser = new Map<string, Set<UiSocket>>();

    /** Subscribers for a given deviceId */
    private socketsByDevice = new Map<string, Set<UiSocket>>();

    /** Track every active socket for cleanup/metrics */
    private allSockets = new Set<UiSocket>();

    /* ---------------------------- Socket lifecycle ---------------------------- */

    /** Register a new UI socket for a specific user (auth already verified). */
    add(userId: string, socket: UiSocket): void {
        socket.userId = String(userId);
        socket.subscriptions = socket.subscriptions ?? new Set<string>();

        // Per-user index
        if (!this.socketsByUser.has(userId)) this.socketsByUser.set(userId, new Set());
        this.socketsByUser.get(userId)!.add(socket);

        // Global index
        this.allSockets.add(socket);
    }

    /** Remove a UI socket from all indexes (called on close/error). */
    remove(socket: UiSocket): void {
        // Unsubscribe from all device topics first
        if (socket.subscriptions && socket.subscriptions.size) {
            for (const deviceId of socket.subscriptions) {
                this.unsubscribe(socket, deviceId);
            }
            socket.subscriptions.clear();
        }

        // Detach from per-user map
        const uid = socket.userId;
        if (uid && this.socketsByUser.has(uid)) {
            const set = this.socketsByUser.get(uid)!;
            set.delete(socket);
            if (set.size === 0) this.socketsByUser.delete(uid);
        }

        // Global index
        this.allSockets.delete(socket);
    }

    /** Remove all sockets for a given user (e.g., on logout/revoke). */
    removeAllForUser(userId: string): number {
        const set = this.socketsByUser.get(userId);
        if (!set || !set.size) return 0;
        let n = 0;
        for (const s of Array.from(set)) {
            try {
                // Close with policy code; UI can auto-reconnect if appropriate
                // eslint-disable-next-line @typescript-eslint/no-explicit-any
                (s as any).close?.(4401, "User sessions revoked");
            } catch {
                /* ignore */
            }
            this.remove(s);
            n++;
        }
        return n;
    }

    /* ----------------------------- Subscriptions ------------------------------ */

    /** Subscribe a socket to a device topic (idempotent). */
    subscribe(socket: UiSocket, deviceId: string): void {
        const id = String(deviceId);
        socket.subscriptions = socket.subscriptions ?? new Set<string>();
        if (socket.subscriptions.has(id)) return;

        socket.subscriptions.add(id);

        if (!this.socketsByDevice.has(id)) this.socketsByDevice.set(id, new Set());
        this.socketsByDevice.get(id)!.add(socket);
    }

    /** Unsubscribe a socket from a device topic (no-op if not subscribed). */
    unsubscribe(socket: UiSocket, deviceId: string): void {
        const id = String(deviceId);
        if (socket.subscriptions && socket.subscriptions.has(id)) {
            socket.subscriptions.delete(id);
        }
        const set = this.socketsByDevice.get(id);
        if (set) {
            set.delete(socket);
            if (set.size === 0) this.socketsByDevice.delete(id);
        }
    }

    /** Unsubscribe a socket from all topics. */
    unsubscribeAll(socket: UiSocket): void {
        if (!socket.subscriptions) return;
        for (const id of Array.from(socket.subscriptions)) {
            this.unsubscribe(socket, id);
        }
    }

    /* -------------------------------- Broadcasts ------------------------------ */

    /** Broadcast to all UI sockets (rare; prefer topic broadcasts). */
    broadcastAll(payload: unknown): number {
        const msg = JSON.stringify(payload);
        let sent = 0;
        for (const s of this.allSockets) {
            if (!isOpen(s)) continue;
            try {
                s.send(msg);
                sent++;
            } catch {
                /* ignore per-socket send errors */
            }
        }
        return sent;
    }

    /** Broadcast to all sockets subscribed to a specific deviceId. */
    broadcastToDevice(deviceId: string, payload: unknown): number {
        const set = this.socketsByDevice.get(String(deviceId));
        if (!set || set.size === 0) return 0;
        const msg = JSON.stringify(payload);
        let sent = 0;
        for (const s of set) {
            if (!isOpen(s)) continue;
            try {
                s.send(msg);
                sent++;
            } catch {
                /* ignore per-socket send errors */
            }
        }
        return sent;
    }

    /** Broadcast to all sockets for a given userId (e.g., personal notices). */
    broadcastToUser(userId: string, payload: unknown): number {
        const set = this.socketsByUser.get(String(userId));
        if (!set || set.size === 0) return 0;
        const msg = JSON.stringify(payload);
        let sent = 0;
        for (const s of set) {
            if (!isOpen(s)) continue;
            try {
                s.send(msg);
                sent++;
            } catch {
                /* ignore per-socket send errors */
            }
        }
        return sent;
    }

    /* --------------------------------- Metrics -------------------------------- */

    countAll(): number {
        return this.allSockets.size;
    }
    countUsers(): number {
        return this.socketsByUser.size;
    }
    countDeviceSubscribers(deviceId: string): number {
        const set = this.socketsByDevice.get(String(deviceId));
        return set ? set.size : 0;
    }
}

===== END FILE remoteiq-minimal-e2e\backend\src\common\ui-socket-registry.service.ts =====

