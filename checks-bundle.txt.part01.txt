### RemoteIQ Checks Bundle
# Generated: 2025-10-30 20:55:55Z
# Repo root: C:\Users\Last Stop\Documents\Programming Projects\RemoteIQ V6
# Files found: 51

===== FILE: remoteiq-minimal-e2e\backend\src\checks\checks.module.ts (20 lines) =====
// backend/src/checks/checks.module.ts
import { Module, forwardRef } from '@nestjs/common';
import { ChecksService } from './checks.service';
import { ChecksController, DeviceChecksController } from './checks.controller';
import { StorageModule } from '../storage/storage.module';
import { CommonModule } from '../common/common.module'; // <-- add
import { WsModule } from '../ws/ws.module';             // (optional, only if you also use DashboardGateway)

@Module({
    imports: [
        StorageModule,
        CommonModule,               // <-- needed for UiSocketRegistry
        forwardRef(() => WsModule), // ok to keep if you’re also using DashboardGateway elsewhere
    ],
    controllers: [ChecksController, DeviceChecksController],
    providers: [ChecksService],
    exports: [ChecksService],
})
export class ChecksModule { }

===== END FILE remoteiq-minimal-e2e\backend\src\checks\checks.module.ts =====

===== FILE: remoteiq-minimal-e2e\backend\src\checks\checks.controller.ts (150 lines) =====
//remoteiq-minimal-e2e\backend\src\checks\checks.controller.ts

import {
    Body,
    Controller,
    Delete,
    Get,
    HttpCode,
    HttpStatus,
    Param,
    ParseUUIDPipe,
    Post,
    Put,
    Query,
} from '@nestjs/common';
import { IsBoolean, IsEnum, IsInt, IsOptional, IsString, IsUUID, Max, Min, ValidateIf } from 'class-validator';
import { ChecksService, CheckScope, CheckType } from './checks.service';

/* ========================= DTOs for /api/checks ========================== */

class ListChecksQuery {
    @IsOptional() @IsEnum(CheckScope) scope?: CheckScope;
    @IsOptional() @IsEnum(CheckType) type?: CheckType;
    @IsOptional() @IsBoolean() enabled?: boolean;
    @IsOptional() @IsUUID() clientId?: string;
    @IsOptional() @IsUUID() siteId?: string;
    @IsOptional() @IsUUID() deviceId?: string;
    @IsOptional() @IsInt() @Min(1) @Max(200) limit?: number;
    @IsOptional() @IsString() cursor?: string;
}

class CreateCheckDto {
    @IsEnum(CheckScope) scope!: CheckScope;
    @ValidateIf((o) => o.scope !== CheckScope.GLOBAL) @IsUUID() @IsOptional() scopeId?: string;

    @IsEnum(CheckType) type!: CheckType;

    @IsString() name!: string;
    @IsString() @IsOptional() description?: string;

    @IsOptional() config?: unknown;     // per-type JSON schema validated in service
    @IsOptional() threshold?: unknown;  // per-type JSON schema validated in service

    @IsString() severityDefault!: 'WARN' | 'CRIT';

    @IsInt() @Min(15) @Max(86400) intervalSec!: number;
    @IsInt() @Min(1) @Max(600) timeoutSec!: number;

    @IsBoolean() enabled!: boolean;
}

class UpdateCheckDto {
    @IsOptional() @IsEnum(CheckScope) scope?: CheckScope;
    @ValidateIf((o) => o.scope && o.scope !== CheckScope.GLOBAL) @IsUUID() @IsOptional() scopeId?: string;

    @IsOptional() @IsEnum(CheckType) type?: CheckType;
    @IsOptional() @IsString() name?: string;
    @IsOptional() @IsString() description?: string;
    @IsOptional() config?: unknown;
    @IsOptional() threshold?: unknown;
    @IsOptional() @IsString() severityDefault?: 'WARN' | 'CRIT';
    @IsOptional() @IsInt() @Min(15) @Max(86400) intervalSec?: number;
    @IsOptional() @IsInt() @Min(1) @Max(600) timeoutSec?: number;
    @IsOptional() @IsBoolean() enabled?: boolean;
}

class RunOnDemandDto {
    @IsOptional() deviceIds?: string[] | null;
}

/* ===================== Existing /api/checks controller ==================== */

@Controller('api/checks')
export class ChecksController {
    constructor(private readonly checks: ChecksService) { }

    // TODO: add @UseGuards(AuthGuard) once your authZ guard is ready.

    @Get()
    async list(@Query() query: ListChecksQuery) {
        return this.checks.list(query);
    }

    @Post()
    async create(@Body() dto: CreateCheckDto) {
        // NOTE: Service will perform per-type schema validation server-side.
        return this.checks.create({
            ...dto,
            createdBy: 'system', // TODO: replace with req.user.id
            updatedBy: null,
            createdAt: new Date().toISOString(),
            updatedAt: new Date().toISOString(),
            id: '00000000-0000-0000-0000-000000000000', // placeholder, service should generate
        } as any);
    }

    @Put(':id')
    async update(@Param('id', new ParseUUIDPipe()) id: string, @Body() dto: UpdateCheckDto) {
        return this.checks.update(id, dto as any);
    }

    @Delete(':id')
    @HttpCode(HttpStatus.NO_CONTENT)
    async remove(@Param('id', new ParseUUIDPipe()) id: string) {
        await this.checks.remove(id);
        return;
    }

    @Post(':id/assignments/rebuild')
    async rebuild(@Param('id', new ParseUUIDPipe()) id: string) {
        return this.checks.rebuildAssignments(id);
    }

    @Post(':id/run')
    async runOnDemand(@Param('id', new ParseUUIDPipe()) id: string, @Body() dto: RunOnDemandDto) {
        return this.checks.runOnDemand(id, dto);
    }
}

/* ================= New device-scoped /api/devices/:id/checks route ========= */

function clamp(n: any, min: number, max: number, def: number): number {
    const x = Number(n);
    if (!Number.isFinite(x)) return def;
    return Math.max(min, Math.min(max, Math.trunc(x)));
}

@Controller('api/devices')
export class DeviceChecksController {
    constructor(private readonly checks: ChecksService) { }

    /**
     * Device-scoped checks for the UI:
     * GET /api/devices/:deviceId/checks?limit=100
     *
     * Returns:
     *  { items: Array<{ id, name, status, lastRun, output, ...optional fields }> }
     *  Optional advanced fields (type, severity, metrics, thresholds, tags, maintenance, dedupeKey)
     *  will be included by the service when available.
     */
    @Get(':deviceId/checks')
    async deviceChecks(
        @Param('deviceId', new ParseUUIDPipe()) deviceId: string,
        @Query('limit') limit?: string,
    ) {
        const lim = clamp(limit, 1, 200, 100);
        return this.checks.listByDevice(deviceId, lim);
    }
}

===== END FILE remoteiq-minimal-e2e\backend\src\checks\checks.controller.ts =====

===== FILE: remoteiq-minimal-e2e\backend\src\checks\checks.service.ts (450 lines) =====
// backend/src/checks/checks.service.ts
import { Injectable, Logger, NotImplementedException } from '@nestjs/common';
import { PgPoolService } from '../storage/pg-pool.service';
import { UiSocketRegistry } from '../common/ui-socket-registry.service';

/* ========================= Types / helpers ========================= */

export enum CheckScope {
    DEVICE = 'DEVICE',
    SITE = 'SITE',
    CLIENT = 'CLIENT',
    GLOBAL = 'GLOBAL',
}

export enum CheckType {
    PING = 'PING',
    CPU = 'CPU',
    MEMORY = 'MEMORY',
    DISK = 'DISK',
    SERVICE = 'SERVICE',
    PROCESS = 'PROCESS',
    PORT = 'PORT',
    WINEVENT = 'WINEVENT',
    SOFTWARE = 'SOFTWARE',
    SECURITY = 'SECURITY',
    SCRIPT = 'SCRIPT',
    PATCH = 'PATCH',
    CERT = 'CERT',
    SMART = 'SMART',
    RDP = 'RDP',
    SMB = 'SMB',
    FIREWALL = 'FIREWALL',
}

export type DeviceCheckDTO = {
    id: string; // assignment id (device-scoped)
    name: string;
    status: 'Passing' | 'Warning' | 'Failing';
    lastRun: string | null;
    output: string;
};

type NormalizedRunStatus = 'OK' | 'WARN' | 'CRIT' | 'TIMEOUT' | 'UNKNOWN';

function normalizeStatus(s?: string | null): NormalizedRunStatus {
    const t = String(s || '').trim().toUpperCase();
    if (t === 'OK' || t === 'PASS' || t === 'PASSING') return 'OK';
    if (t === 'WARN' || t === 'WARNING') return 'WARN';
    if (t === 'TIMEOUT') return 'TIMEOUT';
    if (t === 'CRIT' || t === 'ERROR' || t === 'FAIL' || t === 'FAILING') return 'CRIT';
    return 'UNKNOWN';
}

function toUiStatus(s?: string | null): DeviceCheckDTO['status'] {
    switch (normalizeStatus(s)) {
        case 'OK': return 'Passing';
        case 'WARN': return 'Warning';
        default: return 'Failing';
    }
}

/* =============================== Service =============================== */

@Injectable()
export class ChecksService {
    private readonly logger = new Logger(ChecksService.name);

    // per-device debounce to avoid floods; value is NodeJS.Timeout in Node
    private readonly deviceDebounce = new Map<string, ReturnType<typeof setTimeout>>();

    constructor(
        private readonly pg: PgPoolService,
        private readonly uiSockets: UiSocketRegistry,
    ) { }

    /* ================= Schema guard (idempotent) ================= */

    /** Ensure minimal schema for checks exists (TEXT device_id). Safe to call often. */
    private async ensureSchema() {
        await this.pg.query(`
      CREATE EXTENSION IF NOT EXISTS pgcrypto;

      CREATE TABLE IF NOT EXISTS public.check_assignments (
        id          uuid PRIMARY KEY DEFAULT gen_random_uuid(),
        device_id   text NOT NULL,
        dedupe_key  text,
        check_type  text,
        check_name  text,
        created_at  timestamptz DEFAULT now(),
        updated_at  timestamptz DEFAULT now()
      );

      CREATE TABLE IF NOT EXISTS public.check_runs (
        id            uuid PRIMARY KEY DEFAULT gen_random_uuid(),
        assignment_id uuid,
        device_id     text NOT NULL,
        status        text NOT NULL,
        severity      text,
        metrics       jsonb,
        output        text,
        started_at    timestamptz,
        finished_at   timestamptz,
        created_at    timestamptz DEFAULT now()
      );

      -- Unique dedupe per device: explicit key OR type|name fallback
      CREATE UNIQUE INDEX IF NOT EXISTS check_assignments_uk
        ON public.check_assignments (
          device_id,
          COALESCE(
            NULLIF(dedupe_key, ''),
            LOWER(COALESCE(check_type,'')) || '|' || LOWER(COALESCE(check_name,''))
          )
        );

      CREATE INDEX IF NOT EXISTS check_assignments_device_id_idx ON public.check_assignments (device_id);
      CREATE INDEX IF NOT EXISTS check_runs_assignment_id_idx    ON public.check_runs (assignment_id);
      CREATE INDEX IF NOT EXISTS check_runs_device_id_idx        ON public.check_runs (device_id);
      CREATE INDEX IF NOT EXISTS check_runs_created_at_idx       ON public.check_runs (created_at);
    `);
    }

    /* ====================== Public read for UI ====================== */

    async listByDevice(deviceId: string, limit = 100): Promise<{ items: DeviceCheckDTO[] }> {
        if (!Number.isFinite(limit) || limit < 1) limit = 1;
        if (limit > 200) limit = 200;

        await this.ensureSchema();

        // Latest run per assignment + assignment name (no dependency on separate "checks" table)
        const sql = `
      WITH latest_run AS (
        SELECT
          cr.assignment_id,
          cr.status,
          cr.output,
          cr.finished_at AS last_run,
          ROW_NUMBER() OVER (PARTITION BY cr.assignment_id ORDER BY cr.finished_at DESC NULLS LAST) AS rn
        FROM public.check_runs cr
        WHERE cr.device_id = $1
      )
      SELECT
        a.id                      AS assignment_id,
        COALESCE(NULLIF(a.check_name,''), NULLIF(a.check_type,''), 'Check') AS check_name,
        lr.status                 AS run_status,
        lr.output                 AS run_output,
        lr.last_run               AS last_run
      FROM public.check_assignments a
      LEFT JOIN latest_run lr ON lr.assignment_id = a.id AND lr.rn = 1
      WHERE a.device_id = $1
      ORDER BY lr.last_run DESC NULLS LAST, check_name ASC
      LIMIT $2
    `;

        try {
            const { rows } = await this.pg.query<{
                assignment_id: string;
                check_name: string | null;
                run_status: string | null;
                run_output: string | null;
                last_run: Date | string | null;
            }>(sql, [deviceId, limit]);

            const items: DeviceCheckDTO[] = (rows || []).map((r) => ({
                id: r.assignment_id,
                name: r.check_name ?? 'Check',
                status: toUiStatus(r.run_status),
                lastRun: r.last_run ? new Date(r.last_run as any).toISOString() : null,
                output:
                    (r.run_output ?? '').length > 8192
                        ? (r.run_output ?? '').slice(0, 8192) + '…'
                        : r.run_output ?? '',
            }));

            return { items };
        } catch (err: any) {
            const msg = String(err?.message || '').toLowerCase();
            const code = String((err && (err.code || err?.original?.code)) || '');
            if (code === '42P01' || code === '42703' || (msg.includes('relation') && msg.includes('does not exist'))) {
                this.logger.warn('ChecksService.listByDevice: schema not ready; returning empty items.');
                return { items: [] };
            }
            this.logger.error('ChecksService.listByDevice failed', err?.stack || err);
            return { items: [] };
        }
    }

    /* ======================= Agent ingestion ====================== */

    /**
     * Ingest runs from an agent (TEXT deviceId).
     * - Upsert assignment per device using dedupeKey or (type|name) tuple
     * - Insert runs
     * Returns counts for observability.
     */
    async ingestAgentRuns(input: {
        agentId: string;
        deviceId: string; // TEXT (e.g., "win-...")
        runs: Array<{
            assignmentId?: string;
            dedupeKey?: string;
            checkType?: string;
            checkName?: string;
            status: string;
            severity?: 'WARN' | 'CRIT';
            metrics?: Record<string, any>;
            output?: string;
            startedAt?: string;
            finishedAt?: string;
        }>;
    }): Promise<{ inserted: number; assignmentsCreated: number }> {
        if (!input?.runs?.length) return { inserted: 0, assignmentsCreated: 0 };

        await this.ensureSchema();

        const MAX_OUTPUT = 64 * 1024; // 64 KiB

        // ---------- 1) Prepare src rows with a stable ordinal ----------
        const srcValues: string[] = [];
        const srcParams: any[] = [];
        let p = 1;

        for (let i = 0; i < input.runs.length; i++) {
            const r = input.runs[i];
            const dk = r.dedupeKey ?? null;
            const ct = (r.checkType || '').trim().toUpperCase() || null;
            const cn = (r.checkName || ct || 'Agent Check').trim().substring(0, 200) || 'Agent Check';

            // (ord, device_id, dedupe_key, check_type, check_name)
            srcValues.push(`($${p++}::int, $${p++}::text, $${p++}::text, $${p++}::text, $${p++}::text)`);
            srcParams.push(i + 1, input.deviceId, dk, ct, cn);
        }

        // ---------- 2) Insert missing assignments; count inserted via RETURNING ----------
        const insertSql = `
      WITH src(ord, device_id, dedupe_key, check_type, check_name) AS (
        VALUES ${srcValues.join(',')}
      )
      INSERT INTO public.check_assignments (device_id, dedupe_key, check_type, check_name)
      SELECT s.device_id, s.dedupe_key, s.check_type, s.check_name
      FROM src s
      ON CONFLICT (device_id,
        COALESCE(
          NULLIF(dedupe_key,''),
          LOWER(COALESCE(check_type,'')) || '|' || LOWER(COALESCE(check_name,''))
        ))
      DO NOTHING
      RETURNING id;
    `;
        const insertRes = await this.pg.query<{ id: string }>(insertSql, srcParams);
        const assignmentsCreated = (insertRes.rows || []).length;

        // ---------- 3) Resolve assignment ids for each src row in order ----------
        const mapSql = `
      WITH src(ord, device_id, dedupe_key, check_type, check_name) AS (
        VALUES ${srcValues.join(',')}
      )
      SELECT
        s.ord,
        ca.id::text AS assignment_id
      FROM src s
      JOIN public.check_assignments ca
        ON ca.device_id = s.device_id
       AND COALESCE(NULLIF(ca.dedupe_key,''),
            LOWER(COALESCE(ca.check_type,'')) || '|' || LOWER(COALESCE(ca.check_name,'')))
        = COALESCE(NULLIF(s.dedupe_key,''),
            LOWER(COALESCE(s.check_type,'')) || '|' || LOWER(COALESCE(s.check_name,'')))
      ORDER BY s.ord ASC;
    `;
        const mapRes = await this.pg.query<{ ord: number; assignment_id: string }>(mapSql, srcParams);
        const assignmentByOrd = new Map<number, string>();
        for (const r of mapRes.rows) assignmentByOrd.set(r.ord, r.assignment_id);

        // ---------- 4) Build runs aligned to the original order ----------
        const runValues: string[] = [];
        const runParams: any[] = [];
        p = 1;

        for (let i = 0; i < input.runs.length; i++) {
            const r = input.runs[i];
            const assignmentIdFromMap = assignmentByOrd.get(i + 1);

            const assignmentId =
                (r.assignmentId && /^[0-9a-fA-F-]{8}-[0-9a-fA-F-]{4}-[1-5][0-9a-fA-F-]{3}-[89abAB][0-9a-fA-F-]{3}-[0-9a-fA-F-]{12}$/.test(r.assignmentId))
                    ? r.assignmentId
                    : assignmentIdFromMap;

            if (!assignmentId) continue; // should not happen, but be defensive

            const status = normalizeStatus(r.status);
            const severity = r.severity === 'CRIT' ? 'CRIT' : r.severity === 'WARN' ? 'WARN' : null;
            const output = (r.output ?? '').slice(0, MAX_OUTPUT);
            const startedAt = r.startedAt ? new Date(r.startedAt) : new Date();
            const finishedAt = r.finishedAt ? new Date(r.finishedAt) : new Date();

            runValues.push(`(
        $${p++}::uuid,        -- assignment_id
        $${p++}::text,        -- device_id
        $${p++}::text,        -- status
        $${p++}::text,        -- severity
        $${p++}::jsonb,       -- metrics
        $${p++}::text,        -- output
        $${p++}::timestamptz, -- started_at
        $${p++}::timestamptz  -- finished_at
      )`);

            runParams.push(
                assignmentId,
                input.deviceId,
                status,
                severity,
                r.metrics ? JSON.stringify(r.metrics) : null,
                output,
                startedAt.toISOString(),
                finishedAt.toISOString(),
            );
        }

        let inserted = 0;
        if (runValues.length) {
            const insSql = `
        INSERT INTO public.check_runs
          (assignment_id, device_id, status, severity, metrics, output, started_at, finished_at)
        VALUES ${runValues.join(',')}
        RETURNING id;
      `;
            const ins = await this.pg.query<{ id: string }>(insSql, runParams);
            inserted = (ins.rows || []).length;
        }

        // Debounced UI broadcast per device
        if (inserted > 0) this.scheduleDeviceBroadcast(input.deviceId, inserted);

        this.logger.log(`ingested ${inserted} run(s) for device ${input.deviceId}; new assignments: ${assignmentsCreated}`);
        return { inserted, assignmentsCreated };
    }

    /** Debounce + emit device_checks_updated to subscribed UI sockets */
    private scheduleDeviceBroadcast(deviceId: string, changed: number) {
        const key = String(deviceId);
        const existing = this.deviceDebounce.get(key);
        if (existing) clearTimeout(existing as any);

        const handle = setTimeout(() => {
            try {
                const payload = {
                    t: 'device_checks_updated',
                    deviceId: key,
                    changed,
                    at: new Date().toISOString(),
                };
                const sent = this.uiSockets.broadcastToDevice(key, payload);
                this.logger.debug(`Broadcast device_checks_updated to ${sent} UI socket(s) for device ${key}`);
            } catch (e: any) {
                this.logger.warn(`Broadcast failed for device ${key}: ${e?.message ?? e}`);
            } finally {
                this.deviceDebounce.delete(key);
            }
        }, 750);

        this.deviceDebounce.set(key, handle);
    }

    /* ============== Server-driven assignments for agent (optional) ============ */

    async getAssignmentsForDevice(deviceId: string): Promise<{
        items: Array<{
            assignmentId: string;
            type: string | null;
            name: string | null;
            intervalSec: number; // static defaults for now
            timeoutSec: number;  // static defaults for now
            enabled: boolean;
            dedupeKey?: string | null;
            config?: any;
            thresholds?: any;
        }>;
    }> {
        await this.ensureSchema();

        // We don’t maintain a separate checks catalog here; return lightweight rows
        const { rows } = await this.pg.query(
            `
      SELECT
        a.id::text            AS assignment_id,
        a.check_type          AS check_type,
        a.check_name          AS check_name,
        a.dedupe_key          AS dedupe_key,
        a.created_at,
        a.updated_at
      FROM public.check_assignments a
      WHERE a.device_id = $1
      ORDER BY a.created_at DESC
      `,
            [deviceId]
        );

        return {
            items: rows.map((r: any) => ({
                assignmentId: r.assignment_id,
                type: r.check_type ?? null,
                name: r.check_name ?? null,
                // simple defaults (agents can override via config if/when you add it)
                intervalSec: 60,
                timeoutSec: 10,
                enabled: true,
                dedupeKey: r.dedupe_key,
                config: null,
                thresholds: null,
            })),
        };
    }

    /* ======================== Placeholders (unchanged) ======================== */

    async list(_params: {
        scope?: CheckScope;
        type?: CheckType;
        enabled?: boolean;
        clientId?: string;
        siteId?: string;
        deviceId?: string;
        limit?: number;
        cursor?: string;
    }): Promise<{ items: any[]; nextCursor?: string | null }> {
        throw new NotImplementedException('ChecksService.list not implemented yet');
    }

    async create(_payload: any): Promise<any> {
        throw new NotImplementedException('ChecksService.create not implemented yet');
    }

    async update(_id: string, _payload: any): Promise<any> {
        throw new NotImplementedException('ChecksService.update not implemented yet');
    }

    async remove(_id: string): Promise<{ id: string; deleted: boolean }> {
        throw new NotImplementedException('ChecksService.remove not implemented yet');
    }

    async rebuildAssignments(_id: string): Promise<{ checkId: string; assignmentsRebuilt: number }> {
        throw new NotImplementedException('ChecksService.rebuildAssignments not implemented yet');
    }

    async runOnDemand(_id: string, _params?: { deviceIds?: string[] | null }): Promise<{ enqueued: number }> {
        throw new NotImplementedException('ChecksService.runOnDemand not implemented yet');
    }
}

===== END FILE remoteiq-minimal-e2e\backend\src\checks\checks.service.ts =====

===== FILE: remoteiq-minimal-e2e\backend\src\devices\devices.service.ts (276 lines) =====
// backend/src/devices/devices.service.ts
import { Injectable, NotFoundException } from "@nestjs/common";
import { PgPoolService } from "../storage/pg-pool.service";

export type Device = {
  id: string;
  hostname: string;
  os: string;
  arch?: string | null;
  lastSeen: string | null;
  status: "online" | "offline";
  client?: string | null;
  site?: string | null;
  user?: string | null;
  version?: string | null;
  primaryIp?: string | null;
  agentUuid?: string | null; // <-- NEW
};

function decodeCursor(cur?: string | null) {
  if (!cur) return 0;
  try {
    const n = parseInt(Buffer.from(cur, "base64url").toString("utf8"), 10);
    return Number.isFinite(n) && n >= 0 ? n : 0;
  } catch {
    return 0;
  }
}
function encodeCursor(n: number) {
  return Buffer.from(String(n), "utf8").toString("base64url");
}

@Injectable()
export class DevicesService {
  constructor(private readonly pg: PgPoolService) { }

  async list(opts: {
    pageSize: number;
    cursor?: string | null;
    q?: string;
    status?: "online" | "offline";
    os?: string[];
  }): Promise<{ items: Device[]; nextCursor: string | null }> {
    const { pageSize, cursor, q, status, os } = opts;
    const offset = decodeCursor(cursor);

    const where: string[] = [];
    const params: any[] = [];
    let p = 1;

    if (q && q.trim()) {
      where.push(`hostname ILIKE $${p++}`);
      params.push(`%${q.trim()}%`);
    }
    if (status) {
      where.push(`status = $${p++}`);
      params.push(status);
    }
    if (os && os.length) {
      where.push(`lower(os) = ANY($${p++})`);
      params.push(os.map((o) => String(o).toLowerCase()));
    }

    const limit = pageSize + 1;
    const whereSql = where.length ? `WHERE ${where.join(" AND ")}` : "";

    const sql = `
      WITH agent_rows AS (
        SELECT
          a.id::text                                   AS id,
          COALESCE(a.hostname, a.device_id, 'unknown') AS hostname,
          COALESCE(NULLIF(a.os, ''), 'unknown')        AS os,
          a.arch                                       AS arch,
          a.last_seen_at                               AS last_seen,
          CASE
            WHEN a.last_seen_at IS NOT NULL
             AND a.last_seen_at > NOW() - INTERVAL '5 minutes'
            THEN 'online' ELSE 'offline'
          END                                          AS status,
          a.client                                     AS client,
          a.site                                       AS site,
          NULLIF(a.logged_in_user, '')                 AS "user",
          NULLIF(a.version, '')                        AS version,
          NULLIF(a.primary_ip, '')                     AS primary_ip,
          a.agent_uuid::text                           AS agent_uuid   -- <-- NEW
        FROM public.agents a
      ),
      device_rows AS (
        SELECT
          d.id::text            AS id,
          d.hostname            AS hostname,
          d.os                  AS os,
          d.arch                AS arch,
          d.last_seen           AS last_seen,
          d.status              AS status,
          d.client              AS client,
          d.site                AS site,
          NULLIF(d."user", '')  AS "user",
          NULL::text            AS version,
          NULL::text            AS primary_ip,
          NULL::text            AS agent_uuid                          -- <-- NEW
        FROM devices d
        WHERE NOT EXISTS (
          SELECT 1 FROM public.agents a
          WHERE COALESCE(a.hostname, a.device_id, 'unknown') = d.hostname
        )
      ),
      all_devs AS (
        SELECT * FROM agent_rows
        UNION ALL
        SELECT * FROM device_rows
      )
      SELECT id, hostname, os, arch, last_seen, status, client, site, "user", version, primary_ip, agent_uuid
      FROM all_devs
      ${whereSql}
      ORDER BY hostname ASC
      LIMIT ${limit} OFFSET ${offset};
    `;

    const { rows } = await this.pg.query(sql, params);
    const hasNext = rows.length > pageSize;

    const items = rows.slice(0, pageSize).map((r: any) => ({
      id: r.id,
      hostname: r.hostname,
      os: r.os,
      arch: r.arch ?? null,
      lastSeen: r.last_seen ? new Date(r.last_seen).toISOString() : null,
      status: r.status as "online" | "offline",
      client: r.client ?? null,
      site: r.site ?? null,
      user: r.user ?? null,
      version: r.version ?? null,
      primaryIp: r.primary_ip ?? null,
      agentUuid: r.agent_uuid ?? null, // <-- NEW
    })) as Device[];

    return { items, nextCursor: hasNext ? encodeCursor(offset + pageSize) : null };
  }

  async getOne(id: string): Promise<Device | null> {
    const sql = `
      WITH rows AS (
        SELECT
          0                                                AS pref,
          a.id::text                                      AS id,
          COALESCE(a.hostname, a.device_id, 'unknown')    AS hostname,
          COALESCE(NULLIF(a.os, ''), 'unknown')           AS os,
          a.arch                                          AS arch,
          a.last_seen_at                                  AS last_seen,
          CASE
            WHEN a.last_seen_at IS NOT NULL
             AND a.last_seen_at > NOW() - INTERVAL '5 minutes'
            THEN 'online' ELSE 'offline'
          END                                             AS status,
          a.client                                        AS client,
          a.site                                          AS site,
          NULLIF(a.logged_in_user, '')                    AS "user",
          NULLIF(a.version, '')                           AS version,
          NULLIF(a.primary_ip, '')                        AS primary_ip,
          a.agent_uuid::text                              AS agent_uuid  -- <-- NEW
        FROM public.agents a
        WHERE a.id::text = $1

        UNION ALL

        SELECT
          1                        AS pref,
          d.id::text               AS id,
          d.hostname               AS hostname,
          d.os                     AS os,
          d.arch                   AS arch,
          d.last_seen              AS last_seen,
          d.status                 AS status,
          d.client                 AS client,
          d.site                   AS site,
          NULLIF(d."user", '')     AS "user",
          NULL::text               AS version,
          NULL::text               AS primary_ip,
          NULL::text               AS agent_uuid                         -- <-- NEW
        FROM devices d
        WHERE d.id::text = $1
      )
      SELECT id, hostname, os, arch, last_seen, status, client, site, "user", version, primary_ip, agent_uuid
      FROM rows
      ORDER BY pref ASC
      LIMIT 1;
    `;
    const { rows } = await this.pg.query(sql, [id]);
    const r = rows[0];
    if (!r) return null;

    return {
      id: r.id,
      hostname: r.hostname,
      os: r.os,
      arch: r.arch ?? null,
      lastSeen: r.last_seen ? new Date(r.last_seen).toISOString() : null,
      status: r.status as "online" | "offline",
      client: r.client ?? null,
      site: r.site ?? null,
      user: r.user ?? null,
      version: r.version ?? null,
      primaryIp: r.primary_ip ?? null,
      agentUuid: r.agent_uuid ?? null, // <-- NEW
    };
  }

  async listSoftware(
    id: string
  ): Promise<
    Array<{
      id: string;
      name: string;
      version: string;
      publisher?: string | null;
      installDate?: string | null;
    }>
  > {
    const { rows } = await this.pg.query(
      `
      SELECT
        s.id::text            AS id,
        s.name,
        s.version,
        s.publisher,
        s.install_date        AS install_date
      FROM public.agent_software s
      JOIN public.agents a ON a.id = s.agent_id
      WHERE a.id::text = $1
      ORDER BY lower(s.name) ASC, COALESCE(s.version,'') ASC
      `,
      [id]
    );

    return rows.map((r: any) => ({
      id: r.id,
      name: r.name,
      version: r.version ?? "",
      publisher: r.publisher ?? null,
      installDate: r.install_date ?? null,
    }));
  }

  // NEW: create uninstall job in a simple job queue
  async requestUninstall(
    id: string,
    body: { name: string; version?: string | null }
  ): Promise<string> {
    // ensure agent exists
    const { rows: arows } = await this.pg.query(
      `SELECT id FROM public.agents WHERE id::text = $1`,
      [id]
    );
    const agentId: number | undefined = arows[0]?.id;
    if (!agentId) throw new NotFoundException("Agent not found");

    const payload = {
      action: "uninstall_software",
      name: body.name,
      version: body.version ?? null,
    };

    const { rows } = await this.pg.query(
      `
      INSERT INTO public.agent_jobs (agent_id, kind, payload)
      VALUES ($1, $2, $3::jsonb)
      RETURNING id::text AS id
      `,
      [agentId, "uninstall_software", JSON.stringify(payload)]
    );

    return rows[0].id as string;
  }
}

===== END FILE remoteiq-minimal-e2e\backend\src\devices\devices.service.ts =====

===== FILE: remoteiq-minimal-e2e\backend\src\agents\agents.module.ts (17 lines) =====
// remoteiq-minimal-e2e\backend\src\agents\agents.module.ts
import { Module } from '@nestjs/common';
import { AgentsController } from './agents.controller';
import { AgentsService } from './agents.service';
import { AuthModule } from '../auth/auth.module';
import { StorageModule } from '../storage/storage.module'; // provides PgPoolService
import { CommonModule } from '../common/common.module';    // provides AgentTokenGuard utilities
import { ChecksModule } from '../checks/checks.module';    // <-- provides ChecksService to controller

@Module({
  imports: [AuthModule, StorageModule, CommonModule, ChecksModule],
  controllers: [AgentsController],
  providers: [AgentsService],
  exports: [AgentsService],
})
export class AgentsModule { }

===== END FILE remoteiq-minimal-e2e\backend\src\agents\agents.module.ts =====

===== FILE: remoteiq-minimal-e2e\backend\src\agents\agents.controller.ts (223 lines) =====
// src/agents/agents.controller.ts
import {
  Body, Controller, Get, Post, Query, Req,
  UseGuards, UsePipes, ValidationPipe, BadRequestException, ForbiddenException,
} from '@nestjs/common';
import { AuthService } from '../auth/auth.service';
import { EnrollAgentDto } from './dto/enroll-agent.dto';
import { AgentsService } from './agents.service';
import { AgentTokenGuard, getAgentFromRequest } from '../common/agent-token.util';
import { UpdateAgentFactsDto } from './dto/update-agent-facts.dto';
import { SubmitSoftwareDto } from './dto/submit-software.dto';
import { ChecksService } from '../checks/checks.service';
import {
  IsArray, IsDateString, IsObject, IsOptional, IsString,
  MaxLength, ValidateNested, ArrayMinSize,
} from 'class-validator';
import { Type } from 'class-transformer';

/* ----------------------------- DTOs for runs ----------------------------- */

export enum AgentRunStatus {
  OK = 'OK',
  PASS = 'PASS',
  PASSING = 'PASSING',
  WARN = 'WARN',
  WARNING = 'WARNING',
  CRIT = 'CRIT',
  ERROR = 'ERROR',
  FAIL = 'FAIL',
  FAILING = 'FAILING',
  TIMEOUT = 'TIMEOUT',
  UNKNOWN = 'UNKNOWN',
}

export class SubmitCheckRunItemDto {
  @IsOptional()
  @IsString()
  @MaxLength(36)
  assignmentId?: string; // uuid string (not strictly validated to allow empty envs)

  @IsOptional()
  @IsString()
  @MaxLength(256)
  dedupeKey?: string;

  @IsOptional()
  @IsString()
  @MaxLength(64)
  checkType?: string;

  @IsOptional()
  @IsString()
  @MaxLength(200)
  checkName?: string;

  @IsString()
  status!: string;

  @IsOptional()
  @IsString()
  @MaxLength(8)
  severity?: 'WARN' | 'CRIT';

  @IsOptional()
  @IsObject()
  metrics?: Record<string, any>;

  @IsOptional()
  @IsString()
  @MaxLength(200000)
  output?: string;

  @IsOptional()
  @IsDateString()
  startedAt?: string;

  @IsOptional()
  @IsDateString()
  finishedAt?: string;
}

export class SubmitCheckRunsDto {
  @IsOptional()
  @IsString() // <— accepts "win-..." style ids
  deviceId?: string;

  @IsArray()
  @ArrayMinSize(1)
  @ValidateNested({ each: true })
  @Type(() => SubmitCheckRunItemDto)
  runs!: SubmitCheckRunItemDto[];
}

/* ----------------------------- Rate limiter ------------------------------ */
const rlWindowMs = 10_000; // 10s
const rlMaxRequests = 20;  // 20 per window
const rlState = new Map<string, number[]>();

function checkRate(agentIdStr: string) {
  const now = Date.now();
  const arr = rlState.get(agentIdStr) ?? [];
  const fresh = arr.filter(ts => now - ts < rlWindowMs);
  fresh.push(now);
  rlState.set(agentIdStr, fresh);
  if (fresh.length > rlMaxRequests) {
    throw new ForbiddenException('Agent is sending check data too fast; back off and retry later.');
  }
}

@Controller('/api/agent')
@UsePipes(new ValidationPipe({ whitelist: true, transform: true, forbidNonWhitelisted: true }))
export class AgentsController {
  constructor(
    private readonly auth: AuthService,
    private readonly agents: AgentsService,
    private readonly checks: ChecksService,
  ) { }

  @Post('/enroll')
  async enroll(
    @Body() body: EnrollAgentDto
  ): Promise<{ agentId: string; agentUuid: string | null; deviceId: string; agentToken: string }> {
    const res: any = await this.auth.enrollAgent(body);

    const agentId = String(res?.agentId ?? res?.agent?.id ?? '');
    const deviceId = String(res?.deviceId ?? res?.device?.id ?? body?.deviceId ?? '');
    const agentToken = String(res?.agentToken ?? res?.token ?? res?.accessToken ?? '');

    if (!agentToken || !agentId) {
      throw new Error('Enrollment succeeded but missing token or agentId in response.');
    }

    let agentUuid: string | null = null;
    try {
      agentUuid = await this.agents.getAgentUuidById(Number(agentId));
    } catch {
      agentUuid = null;
    }

    return { agentId, agentUuid, deviceId, agentToken };
  }

  @Post('/ping')
  @UseGuards(AgentTokenGuard)
  async ping(@Req() req: any, @Body() body: UpdateAgentFactsDto) {
    const agent = getAgentFromRequest(req);
    await this.agents.updateFacts(Number((agent as any).id), body ?? {});
    return { ok: true };
  }

  @Post('/software')
  @UseGuards(AgentTokenGuard)
  async submitSoftware(@Req() req: any, @Body() body: SubmitSoftwareDto) {
    const agent = getAgentFromRequest(req);
    await this.agents.upsertSoftware(Number((agent as any).id), body?.items ?? []);
    return { ok: true, count: body?.items?.length ?? 0 };
  }

  // ===================== Check runs ingestion ======================
  @Post('/check-runs')
  @UseGuards(AgentTokenGuard)
  async submitCheckRuns(@Req() req: any, @Body() body: SubmitCheckRunsDto) {
    const agent = getAgentFromRequest(req);

    checkRate(String((agent as any).id));

    const tokenDeviceRaw = (agent as any)?.deviceId ?? (agent as any)?.device_id;
    const deviceIdFromToken: string | undefined =
      tokenDeviceRaw != null ? String(tokenDeviceRaw) : undefined;

    const deviceIdFromBody: string | undefined =
      body?.deviceId ? String(body.deviceId) : undefined;

    const deviceId = deviceIdFromBody ?? deviceIdFromToken;

    if (!deviceId) {
      throw new BadRequestException('deviceId is required (bind agent to device first, or include in body).');
    }
    if (deviceIdFromBody && deviceIdFromToken && deviceIdFromBody !== deviceIdFromToken) {
      throw new ForbiddenException('deviceId in body does not match the agent binding.');
    }
    if (!Array.isArray(body?.runs) || body.runs.length === 0) {
      throw new BadRequestException('runs is required and must be a non-empty array');
    }

    const result = await this.checks.ingestAgentRuns({
      agentId: String((agent as any).id),
      deviceId, // TEXT id
      runs: body.runs.map(r => ({
        assignmentId: r.assignmentId,
        dedupeKey: r.dedupeKey,
        checkType: r.checkType,
        checkName: r.checkName,
        status: r.status,
        severity: r.severity,
        metrics: r.metrics,
        output: r.output,
        startedAt: r.startedAt,
        finishedAt: r.finishedAt,
      })),
    });

    return { ok: true, inserted: result.inserted, assignmentsCreated: result.assignmentsCreated };
  }

  @Get('/assignments')
  @UseGuards(AgentTokenGuard)
  async getAssignments(@Req() req: any, @Query('deviceId') deviceId?: string) {
    const agent = getAgentFromRequest(req);
    const tokenDeviceRaw = (agent as any)?.deviceId ?? (agent as any)?.device_id;
    const boundDevice: string | undefined =
      tokenDeviceRaw != null ? String(tokenDeviceRaw) : undefined;

    const effective = deviceId ?? boundDevice;
    if (!effective) {
      throw new BadRequestException('deviceId is required (either query param or bound to agent).');
    }

    const { items } = await this.checks.getAssignmentsForDevice(effective);
    return { items };
  }
}

===== END FILE remoteiq-minimal-e2e\backend\src\agents\agents.controller.ts =====

===== FILE: remoteiq-minimal-e2e\backend\src\agents\agents.service.ts (142 lines) =====
// backend/src/agents/agents.service.ts
import { Injectable } from "@nestjs/common";
import { PgPoolService } from "../storage/pg-pool.service";

// DTOs are validated in controllers; here we accept partials safely.
type UpdateAgentFacts = Partial<{
    hostname: string;
    os: string;
    arch: string | null;         // NOT NULL in DB → we will ignore null updates
    version: string | null;      // nullable
    primaryIp: string | null;    // nullable
    client: string | null;       // nullable
    site: string | null;         // nullable
    user: string | null;         // alias accepted from agent payloads
    loggedInUser: string | null; // alias (both map to logged_in_user)
}>;

type SoftwareItem = {
    name: string;
    version?: string | null;
    publisher?: string | null;
    installDate?: string | null;
};

@Injectable()
export class AgentsService {
    constructor(private readonly pg: PgPoolService) { }

    /** Return the stable UUID mirror for a numeric agent id (or null if absent). */
    async getAgentUuidById(agentId: number): Promise<string | null> {
        try {
            const { rows } = await this.pg.query<{ agent_uuid: string | null }>(
                `SELECT agent_uuid FROM public.agents WHERE id = $1 LIMIT 1`,
                [agentId]
            );
            return rows[0]?.agent_uuid ?? null;
        } catch {
            return null;
        }
    }

    /**
     * Update agent facts and bump last_seen_at.
     * - Only updates provided fields.
     * - Never sets NOT NULL columns to NULL.
     */
    async updateFacts(agentId: number, facts: UpdateAgentFacts): Promise<void> {
        const sets: string[] = [`last_seen_at = NOW()`];
        const params: any[] = [];
        let p = 1;

        // For columns that are NOT NULL in your schema, do not accept null writes.
        const setIfDefined = (col: string, val: any) => {
            if (val !== undefined) {
                sets.push(`${col} = $${p++}`);
                params.push(val);
            }
        };
        const setIfNullable = (col: string, val: any) => {
            if (val !== undefined) {
                sets.push(`${col} = $${p++}`);
                params.push(val); // can be null; that’s fine for nullable cols
            }
        };
        const setIfNotNull = (col: string, val: any) => {
            if (val !== undefined && val !== null) {
                sets.push(`${col} = $${p++}`);
                params.push(val);
            }
        };

        // Likely NOT NULL in table
        setIfDefined("hostname", facts.hostname);
        setIfDefined("os", facts.os);
        setIfNotNull("arch", facts.arch); // skip if null/undefined

        // Nullable fields
        setIfNullable("version", facts.version ?? undefined);
        setIfNullable("primary_ip", facts.primaryIp ?? undefined);
        setIfNullable("client", facts.client ?? undefined);
        setIfNullable("site", facts.site ?? undefined);

        // Accept both 'user' and 'loggedInUser' from payloads → store in logged_in_user
        const loginUser = facts.user ?? facts.loggedInUser;
        setIfNullable("logged_in_user", loginUser ?? undefined);

        const sql = `
      UPDATE public.agents
      SET ${sets.join(", ")}
      WHERE id = $${p}
    `;
        params.push(agentId);

        await this.pg.query(sql, params);
    }

    /** Upsert full software inventory for an agent. */
    async upsertSoftware(agentId: number, items: SoftwareItem[]): Promise<void> {
        if (!Array.isArray(items) || items.length === 0) return;

        const valuesSql: string[] = [];
        const params: any[] = [];
        let p = 1;

        for (const it of items) {
            const name = (it.name || "").trim();
            if (!name) continue;

            valuesSql.push(`(
        $${p++}::integer,
        $${p++}::text,
        $${p++}::text,
        $${p++}::text,
        $${p++}::timestamptz
      )`);

            params.push(
                agentId,
                name,
                it.version ?? null,
                it.publisher ?? null,
                it.installDate ? new Date(it.installDate) : null
            );
        }

        if (valuesSql.length === 0) return;

        // Requires a matching unique index/constraint in DB:
        // CREATE UNIQUE INDEX IF NOT EXISTS agent_software_uk ON public.agent_software (agent_id, lower(name), COALESCE(version,''));
        const sql = `
      INSERT INTO public.agent_software (agent_id, name, version, publisher, install_date)
      VALUES ${valuesSql.join(",")}
      ON CONFLICT (agent_id, lower(name), COALESCE(version,'')) DO UPDATE
      SET
        publisher = EXCLUDED.publisher,
        install_date = EXCLUDED.install_date
    `;
        await this.pg.query(sql, params);
    }
}


===== END FILE remoteiq-minimal-e2e\backend\src\agents\agents.service.ts =====

===== FILE: remoteiq-minimal-e2e\backend\src\agents\dto\enroll-agent.dto.ts (23 lines) =====
// src/agents/dto/enroll-agent.dto.ts
import { IsIn, IsString, IsNotEmpty, MaxLength } from 'class-validator';

export class EnrollAgentDto {
    @IsString() @IsNotEmpty() @MaxLength(200)
    enrollmentSecret!: string;

    @IsString() @IsNotEmpty() @MaxLength(200)
    deviceId!: string;

    @IsString() @IsNotEmpty() @MaxLength(200)
    hostname!: string;

    @IsIn(['windows', 'linux', 'macos'])
    os!: 'windows' | 'linux' | 'macos';

    @IsIn(['x64', 'arm64', 'x86'])
    arch!: 'x64' | 'arm64' | 'x86';

    @IsString() @IsNotEmpty() @MaxLength(50)
    version!: string;
}

===== END FILE remoteiq-minimal-e2e\backend\src\agents\dto\enroll-agent.dto.ts =====

===== FILE: remoteiq-minimal-e2e\backend\src\agents\dto\submit-software.dto.ts (31 lines) =====
import { Type } from 'class-transformer';
import { IsArray, IsOptional, IsString, Length, Matches, ValidateNested } from 'class-validator';

export class SubmitSoftwareItemDto {
    @IsString()
    @Length(1, 256)
    name!: string;

    @IsOptional()
    @IsString()
    @Length(1, 128)
    version?: string;

    @IsOptional()
    @IsString()
    @Length(1, 256)
    publisher?: string;

    // YYYY-MM-DD
    @IsOptional()
    @Matches(/^\d{4}-\d{2}-\d{2}$/, { message: 'installDate must be YYYY-MM-DD' })
    installDate?: string;
}

export class SubmitSoftwareDto {
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => SubmitSoftwareItemDto)
    items!: SubmitSoftwareItemDto[];
}

===== END FILE remoteiq-minimal-e2e\backend\src\agents\dto\submit-software.dto.ts =====

===== FILE: remoteiq-minimal-e2e\backend\src\agents\dto\update-agent-facts.dto.ts (35 lines) =====
// backend/src/agents/dto/update-agent-facts.dto.ts
import { IsIn, IsOptional, IsString, MaxLength } from 'class-validator';

export class UpdateAgentFactsDto {
    @IsOptional()
    @IsIn(['windows', 'linux', 'macos'])
    os?: 'windows' | 'linux' | 'macos';

    @IsOptional()
    @IsIn(['x64', 'arm64', 'x86'])
    arch?: 'x64' | 'arm64' | 'x86';

    @IsOptional()
    @IsString()
    @MaxLength(50)
    version?: string;

    @IsOptional()
    @IsString()
    @MaxLength(100)
    primaryIp?: string;

    // agent sends this today
    @IsOptional()
    @IsString()
    @MaxLength(200)
    user?: string;

    // optional alias: some agents might send this name
    @IsOptional()
    @IsString()
    @MaxLength(200)
    loggedInUser?: string;
}

===== END FILE remoteiq-minimal-e2e\backend\src\agents\dto\update-agent-facts.dto.ts =====

===== FILE: remoteiq-minimal-e2e\backend\src\common\common.module.ts (14 lines) =====
// backend/src/common/common.module.ts
import { Module } from '@nestjs/common';
import { SocketRegistry } from './socket-registry.service';
import { UiSocketRegistry } from './ui-socket-registry.service';
import { AgentTokenGuard } from './agent-token.util';
import { StorageModule } from '../storage/storage.module';

@Module({
    imports: [StorageModule],
    providers: [SocketRegistry, UiSocketRegistry, AgentTokenGuard],
    exports: [SocketRegistry, UiSocketRegistry, AgentTokenGuard],
})
export class CommonModule { }

===== END FILE remoteiq-minimal-e2e\backend\src\common\common.module.ts =====

===== FILE: remoteiq-minimal-e2e\backend\src\common\socket-registry.service.ts (61 lines) =====
//remoteiq-minimal-e2e\backend\src\common\socket-registry.service.ts

import { Injectable } from "@nestjs/common";
import type { WebSocket } from "ws";

export type AgentSocket = WebSocket & {
    agentId?: string;
    deviceId?: string;
};

@Injectable()
export class SocketRegistry {
    private socketsByAgent = new Map<string, AgentSocket>();
    private socketsByDevice = new Map<string, AgentSocket>();

    // --- Primary API ---
    getByAgent(agentId: string): AgentSocket | undefined {
        return this.socketsByAgent.get(agentId);
    }

    getByDevice(deviceId: string): AgentSocket | undefined {
        return this.socketsByDevice.get(deviceId);
    }

    set(agentId: string | undefined, deviceId: string | undefined, socket: AgentSocket) {
        if (agentId) {
            this.socketsByAgent.set(agentId, socket);
            socket.agentId = agentId;
        }
        if (deviceId) {
            this.socketsByDevice.set(deviceId, socket);
            socket.deviceId = deviceId;
        }
    }

    deleteByAgent(agentId: string) {
        const sock = this.socketsByAgent.get(agentId);
        if (sock?.deviceId) this.socketsByDevice.delete(sock.deviceId);
        this.socketsByAgent.delete(agentId);
    }

    deleteByDevice(deviceId: string) {
        const sock = this.socketsByDevice.get(deviceId);
        if (sock?.agentId) this.socketsByAgent.delete(sock.agentId);
        this.socketsByDevice.delete(deviceId);
    }

    // --- Back-compat aliases (so older callers like dispatcher.service can keep using .get) ---
    /** Alias for getByAgent */
    get(agentId: string): AgentSocket | undefined {
        return this.getByAgent(agentId);
    }
    /** Aliases in case other code uses these names */
    setByAgent(agentId: string, socket: AgentSocket) {
        this.set(agentId, /*deviceId*/ undefined, socket);
    }
    setByDevice(deviceId: string, socket: AgentSocket) {
        this.set(/*agentId*/ undefined, deviceId, socket);
    }
}

===== END FILE remoteiq-minimal-e2e\backend\src\common\socket-registry.service.ts =====

===== FILE: remoteiq-minimal-e2e\backend\src\common\ui-socket-registry.service.ts (200 lines) =====
// backend/src/common/ui-socket-registry.service.ts
import { Injectable, Logger } from "@nestjs/common";
import type { WebSocket } from "ws";

/**
 * UI (dashboard) socket with metadata.
 * - userId: authenticated user identifier (string)
 * - subscriptions: deviceIds this socket has subscribed to
 */
export type UiSocket = WebSocket & {
    userId?: string;
    subscriptions?: Set<string>;
};

function isOpen(ws: WebSocket): boolean {
    // 'OPEN' is a numeric const on ws WebSocket instances
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    return (ws as any).readyState === (ws as any).OPEN;
}

/**
 * Registry for **dashboard/user** WebSocket connections and their subscriptions.
 * Isolation from the Agent socket registry keeps privileges and broadcasting clean.
 *
 * Notes:
 * - In-memory only (per-process). For multi-node deployments, back this with Redis or a message bus.
 * - Broadcast methods return the number of sockets that were attempted (best-effort).
 */
@Injectable()
export class UiSocketRegistry {
    private readonly log = new Logger("UiSocketRegistry");

    /** All sockets for a given user */
    private socketsByUser = new Map<string, Set<UiSocket>>();

    /** Subscribers for a given deviceId */
    private socketsByDevice = new Map<string, Set<UiSocket>>();

    /** Track every active socket for cleanup/metrics */
    private allSockets = new Set<UiSocket>();

    /* ---------------------------- Socket lifecycle ---------------------------- */

    /** Register a new UI socket for a specific user (auth already verified). */
    add(userId: string, socket: UiSocket): void {
        socket.userId = String(userId);
        socket.subscriptions = socket.subscriptions ?? new Set<string>();

        // Per-user index
        if (!this.socketsByUser.has(userId)) this.socketsByUser.set(userId, new Set());
        this.socketsByUser.get(userId)!.add(socket);

        // Global index
        this.allSockets.add(socket);
    }

    /** Remove a UI socket from all indexes (called on close/error). */
    remove(socket: UiSocket): void {
        // Unsubscribe from all device topics first
        if (socket.subscriptions && socket.subscriptions.size) {
            for (const deviceId of socket.subscriptions) {
                this.unsubscribe(socket, deviceId);
            }
            socket.subscriptions.clear();
        }

        // Detach from per-user map
        const uid = socket.userId;
        if (uid && this.socketsByUser.has(uid)) {
            const set = this.socketsByUser.get(uid)!;
            set.delete(socket);
            if (set.size === 0) this.socketsByUser.delete(uid);
        }

        // Global index
        this.allSockets.delete(socket);
    }

    /** Remove all sockets for a given user (e.g., on logout/revoke). */
    removeAllForUser(userId: string): number {
        const set = this.socketsByUser.get(userId);
        if (!set || !set.size) return 0;
        let n = 0;
        for (const s of Array.from(set)) {
            try {
                // Close with policy code; UI can auto-reconnect if appropriate
                // eslint-disable-next-line @typescript-eslint/no-explicit-any
                (s as any).close?.(4401, "User sessions revoked");
            } catch {
                /* ignore */
            }
            this.remove(s);
            n++;
        }
        return n;
    }

    /* ----------------------------- Subscriptions ------------------------------ */

    /** Subscribe a socket to a device topic (idempotent). */
    subscribe(socket: UiSocket, deviceId: string): void {
        const id = String(deviceId);
        socket.subscriptions = socket.subscriptions ?? new Set<string>();
        if (socket.subscriptions.has(id)) return;

        socket.subscriptions.add(id);

        if (!this.socketsByDevice.has(id)) this.socketsByDevice.set(id, new Set());
        this.socketsByDevice.get(id)!.add(socket);
    }

    /** Unsubscribe a socket from a device topic (no-op if not subscribed). */
    unsubscribe(socket: UiSocket, deviceId: string): void {
        const id = String(deviceId);
        if (socket.subscriptions && socket.subscriptions.has(id)) {
            socket.subscriptions.delete(id);
        }
        const set = this.socketsByDevice.get(id);
        if (set) {
            set.delete(socket);
            if (set.size === 0) this.socketsByDevice.delete(id);
        }
    }

    /** Unsubscribe a socket from all topics. */
    unsubscribeAll(socket: UiSocket): void {
        if (!socket.subscriptions) return;
        for (const id of Array.from(socket.subscriptions)) {
            this.unsubscribe(socket, id);
        }
    }

    /* -------------------------------- Broadcasts ------------------------------ */

    /** Broadcast to all UI sockets (rare; prefer topic broadcasts). */
    broadcastAll(payload: unknown): number {
        const msg = JSON.stringify(payload);
        let sent = 0;
        for (const s of this.allSockets) {
            if (!isOpen(s)) continue;
            try {
                s.send(msg);
                sent++;
            } catch {
                /* ignore per-socket send errors */
            }
        }
        return sent;
    }

    /** Broadcast to all sockets subscribed to a specific deviceId. */
    broadcastToDevice(deviceId: string, payload: unknown): number {
        const set = this.socketsByDevice.get(String(deviceId));
        if (!set || set.size === 0) return 0;
        const msg = JSON.stringify(payload);
        let sent = 0;
        for (const s of set) {
            if (!isOpen(s)) continue;
            try {
                s.send(msg);
                sent++;
            } catch {
                /* ignore per-socket send errors */
            }
        }
        return sent;
    }

    /** Broadcast to all sockets for a given userId (e.g., personal notices). */
    broadcastToUser(userId: string, payload: unknown): number {
        const set = this.socketsByUser.get(String(userId));
        if (!set || set.size === 0) return 0;
        const msg = JSON.stringify(payload);
        let sent = 0;
        for (const s of set) {
            if (!isOpen(s)) continue;
            try {
                s.send(msg);
                sent++;
            } catch {
                /* ignore per-socket send errors */
            }
        }
        return sent;
    }

    /* --------------------------------- Metrics -------------------------------- */

    countAll(): number {
        return this.allSockets.size;
    }
    countUsers(): number {
        return this.socketsByUser.size;
    }
    countDeviceSubscribers(deviceId: string): number {
        const set = this.socketsByDevice.get(String(deviceId));
        return set ? set.size : 0;
    }
}

===== END FILE remoteiq-minimal-e2e\backend\src\common\ui-socket-registry.service.ts =====

===== FILE: remoteiq-minimal-e2e\backend\src\common\agent-token.util.ts (98 lines) =====
// remoteiq-minimal-e2e/backend/src/common/agent-token.util.ts
import { Injectable, CanActivate, ExecutionContext, UnauthorizedException } from '@nestjs/common';
import type { Request } from 'express';
import crypto from 'node:crypto';
import jwt from 'jsonwebtoken';
import { PgPoolService } from '../storage/pg-pool.service';

/** ───────────────────────────
 *  Crypto helpers
 *  ─────────────────────────── */
const algo = 'sha256';

export function hashToken(token: string): string {
  return crypto.createHash(algo).update(token, 'utf8').digest('hex');
}

export function newOpaqueToken(): string {
  return crypto.randomBytes(24).toString('base64url');
}

export function signAgentJwt(agentId: string): string {
  const secret = process.env.JWT_SECRET || 'dev';
  return jwt.sign({ sub: agentId, typ: 'agent' }, secret, { algorithm: 'HS256' });
}

export function verifyAgentJwt(token: string): string | null {
  try {
    const secret = process.env.JWT_SECRET || 'dev';
    const payload = jwt.verify(token, secret) as any;
    return payload?.sub as string;
  } catch {
    return null;
  }
}

/** ───────────────────────────
 *  Request augmentation helper
 *  ─────────────────────────── */
export type AgentAuthContext = {
  id: number;
  token?: string;
};

export function getAgentFromRequest(req: any): AgentAuthContext {
  return (req as any).agent as AgentAuthContext;
}

/** ───────────────────────────
 *  DB row shape(s)
 *  ─────────────────────────── */
type AgentRow = {
  id: number;
  token_hash: string | null;
};

/** ───────────────────────────
 *  Bearer token guard for agents
 *  ─────────────────────────── */
@Injectable()
export class AgentTokenGuard implements CanActivate {
  constructor(private readonly db: PgPoolService) { }

  async canActivate(context: ExecutionContext): Promise<boolean> {
    const req = context.switchToHttp().getRequest<Request>();

    const authHeader = req.headers['authorization'];
    if (!authHeader || Array.isArray(authHeader)) {
      throw new UnauthorizedException('Missing Authorization header');
    }

    const match = /^Bearer\s+(.+)$/.exec(authHeader);
    if (!match) {
      throw new UnauthorizedException('Invalid Authorization header format');
    }

    const token = match[1];
    const tokenHash = hashToken(token);

    // Use the typed query helper (no private pool access)
    const { rows } = await this.db.query<AgentRow>(
      `SELECT id, token_hash
         FROM public.agents
        WHERE token_hash = $1
        LIMIT 1`,
      [tokenHash],
    );

    if (rows.length === 0) {
      throw new UnauthorizedException('Invalid or unknown agent token');
    }

    // Stash minimal agent context on the request
    (req as any).agent = { id: rows[0].id, token } as AgentAuthContext;

    return true;
  }
}

===== END FILE remoteiq-minimal-e2e\backend\src\common\agent-token.util.ts =====

===== FILE: remoteiq-minimal-e2e\backend\src\ws\ws.module.ts (29 lines) =====
// backend/src/ws/ws.module.ts
import { Module, forwardRef } from "@nestjs/common";
import { JwtModule } from "@nestjs/jwt";

import { AgentGateway } from "./agent.gateway";
import { DashboardGateway } from "./dashboard.gateway";

import { JobsModule } from "../jobs/jobs.module";
import { CommonModule } from "../common/common.module";
import { StorageModule } from "../storage/storage.module";

@Module({
  imports: [
    CommonModule,                  // SocketRegistry + UiSocketRegistry
    StorageModule,                 // PgPoolService (Agent/Dashboard gateways)
    forwardRef(() => JobsModule),  // circular with jobs <-> ws is fine

    // Provide JwtService for DashboardGateway auth (typing-safe for ms StringValue)
    JwtModule.register({
      secret: process.env.JWT_SECRET ?? "dev-secret",
      // jsonwebtoken accepts number (seconds) or ms-format string; cast to satisfy strict types
      signOptions: { expiresIn: ((process.env.JWT_EXPIRES as any) ?? ("7d" as any)) },
    }),
  ],
  providers: [AgentGateway, DashboardGateway],
  exports: [AgentGateway, DashboardGateway],
})
export class WsModule { }

===== END FILE remoteiq-minimal-e2e\backend\src\ws\ws.module.ts =====

===== FILE: remoteiq-minimal-e2e\backend\src\ws\agent.gateway.ts (192 lines) =====
// backend/src/ws/agent.gateway.ts
import {
  Inject,
  Injectable,
  Logger,
  OnModuleDestroy,
  OnModuleInit,
  forwardRef,
} from "@nestjs/common";
import { WebSocketGateway, WebSocketServer } from "@nestjs/websockets";
import type { Server as WsServer, WebSocket, RawData } from "ws";

import { SocketRegistry, type AgentSocket } from "../common/socket-registry.service";
import { DispatcherService } from "../jobs/dispatcher.service";
import { JobsService } from "../jobs/jobs.service";

type JobResultMsg = {
  t: "job_result";
  jobId: string;
  exitCode?: number;
  stdout?: string;
  stderr?: string;
  durationMs?: number;
  status?: string; // agent may send custom text, we will map to our enum
};

type AgentHelloMsg = {
  t: "agent_hello";
  agentId?: string;
  deviceId?: string;
  hostname?: string;
  os?: string;
  arch?: string;
  version?: string;
};

function rawToString(data: RawData): string {
  if (typeof data === "string") return data;
  if (Buffer.isBuffer(data)) return data.toString("utf8");
  if (Array.isArray(data)) return Buffer.concat(data as Buffer[]).toString("utf8");
  if (data instanceof ArrayBuffer) return Buffer.from(data).toString("utf8");
  return "";
}

@WebSocketGateway({ path: "/ws" })
@Injectable()
export class AgentGateway implements OnModuleInit, OnModuleDestroy {
  private readonly log = new Logger("AgentGateway");

  @WebSocketServer()
  private ws!: WsServer;

  constructor(
    private readonly sockets: SocketRegistry,
    @Inject(forwardRef(() => DispatcherService))
    private readonly dispatcher: DispatcherService,
    @Inject(forwardRef(() => JobsService))
    private readonly jobs: JobsService,
  ) { }

  onModuleInit() {
    if (!this.ws) {
      this.log.warn("WS server not initialized by adapter; ensure a WS adapter is configured.");
      return;
    }

    this.ws.on("connection", (socket: WebSocket & Partial<AgentSocket>) => {
      this.log.debug("Agent WS connected (awaiting hello)");

      socket.on("message", async (data: RawData) => {
        const text = rawToString(data);
        if (!text) return;

        let msg: any;
        try {
          msg = JSON.parse(text);
        } catch {
          return;
        }
        const t = msg?.t as string | undefined;
        if (!t) return;

        if (t === "agent_hello") {
          const hello = msg as AgentHelloMsg;
          const agentId = String(hello.agentId ?? "").trim();
          const deviceId = String(hello.deviceId ?? "").trim();
          const hostname = String(hello.hostname ?? "").trim();

          if (!agentId) {
            this.log.warn("agent_hello missing agentId; closing socket.");
            socket.close(1008, "agentId required");
            return;
          }

          // Persist identifiers on the socket so cleanup works
          (socket as AgentSocket).agentId = agentId;
          (socket as AgentSocket).deviceId = deviceId || undefined;
          // AgentSocket doesn't declare hostname; store it loosely for logs/debug
          (socket as any).hostname = hostname || undefined;

          // Register into the registry
          this.sockets.set(agentId, deviceId || undefined, socket as AgentSocket);

          this.log.log(
            `Registered agent socket: agentId=${agentId}` +
            (deviceId ? ` deviceId=${deviceId}` : "") +
            (hostname ? ` host=${hostname}` : ""),
          );

          try {
            await this.dispatcher.dispatchQueuedForAgent(agentId);
          } catch (e: any) {
            this.log.warn(`dispatchQueuedForAgent failed: ${e?.message ?? e}`);
          }
          return;
        }

        if (t === "job_result") {
          const jr = msg as JobResultMsg;
          if (!jr.jobId) {
            this.log.warn("job_result missing jobId; ignoring");
            return;
          }

          const exitCode = Number.isFinite(jr.exitCode) ? Number(jr.exitCode) : -1;
          const stdout = typeof jr.stdout === "string" ? jr.stdout : "";
          const stderr = typeof jr.stderr === "string" ? jr.stderr : "";
          const durationMs = Number.isFinite(jr.durationMs) ? Number(jr.durationMs) : 0;

          // Map to our JobsService status enum: "succeeded" | "failed" | "timeout"
          let status: "succeeded" | "failed" | "timeout";
          const s = (jr.status ?? "").toLowerCase();
          if (s === "timeout") status = "timeout";
          else if (s === "succeeded" || (s === "finished" && exitCode === 0) || exitCode === 0) status = "succeeded";
          else status = "failed";

          try {
            await this.jobs.finishJob(
              jr.jobId,
              { exitCode, stdout, stderr, durationMs },
              status,
            );
          } catch (e: any) {
            this.log.warn(`finishJob failed for ${jr.jobId}: ${e?.message ?? e}`);
          }
          return;
        }
      });

      socket.on("close", () => {
        const s = socket as AgentSocket;
        if (s.agentId) this.sockets.deleteByAgent(s.agentId);
        if (s.deviceId) this.sockets.deleteByDevice(s.deviceId);
      });

      socket.on("error", () => {
        // close handler will clean up
      });
    });
  }

  onModuleDestroy() {
    try {
      this.ws?.close();
    } catch {
      /* ignore */
    }
  }

  /**
   * Broadcast a JSON message to all connected agent sockets.
   * automation.controller.ts expects this to exist.
   */
  public broadcast(payload: unknown, filter?: (s: AgentSocket) => boolean): number {
    if (!this.ws?.clients) return 0;
    let sent = 0;
    for (const client of this.ws.clients) {
      const sock = client as AgentSocket;
      // 'OPEN' is a numeric const on ws WebSocket instances
      if ((client as any).readyState !== (client as any).OPEN) continue;
      if (filter && !filter(sock)) continue;
      try {
        client.send(JSON.stringify(payload));
        sent++;
      } catch {
        // ignore per-socket send errors
      }
    }
    return sent;
  }
}

===== END FILE remoteiq-minimal-e2e\backend\src\ws\agent.gateway.ts =====

===== FILE: remoteiq-minimal-e2e\backend\src\ws\dashboard.gateway.ts (251 lines) =====
// backend/src/ws/dashboard.gateway.ts
import {
    Injectable,
    Logger,
    OnModuleDestroy,
    OnModuleInit,
} from "@nestjs/common";
import { WebSocketGateway, WebSocketServer } from "@nestjs/websockets";
import type { Server as WsServer, WebSocket, RawData } from "ws";
import type { IncomingMessage } from "http";
import { JwtService } from "@nestjs/jwt";

import {
    UiSocketRegistry,
    type UiSocket,
} from "../common/ui-socket-registry.service";

/**
 * Minimal cookie parser (avoids external deps).
 */
function parseCookieHeader(h?: string): Record<string, string> {
    const out: Record<string, string> = {};
    if (!h) return out;
    for (const p of h.split(";")) {
        const i = p.indexOf("=");
        if (i > -1) out[p.slice(0, i).trim()] = decodeURIComponent(p.slice(i + 1));
    }
    return out;
}

/**
 * Safely stringify payloads for WS.
 */
function safeJson(data: unknown): string {
    try {
        return JSON.stringify(data);
    } catch {
        return "{}";
    }
}

/**
 * UI (dashboard) WebSocket gateway.
 * - Authenticates users by JWT cookie (same cookie as HTTP)
 * - Registers sockets into UiSocketRegistry
 * - Supports per-device subscriptions: {t:"subscribe", deviceId}, {t:"unsubscribe", deviceId}
 * - Heartbeat: {t:"ping"} -> {t:"pong"}
 *
 * NOTE: Remember to add DashboardGateway to WsModule.providers.
 */
@WebSocketGateway({ path: "/ws-ui" })
@Injectable()
export class DashboardGateway implements OnModuleInit, OnModuleDestroy {
    private readonly log = new Logger("DashboardGateway");

    @WebSocketServer()
    private ws!: WsServer;

    private readonly cookieName =
        process.env.AUTH_COOKIE_NAME?.trim() || "auth_token";
    private readonly jwtSecret =
        process.env.JWT_SECRET?.trim() || "dev-secret"; // dev fallback

    constructor(
        private readonly uiSockets: UiSocketRegistry,
        private readonly jwt: JwtService
    ) { }

    onModuleInit() {
        if (!this.ws) {
            this.log.warn(
                "WS server not initialized by adapter; ensure a WS adapter is configured."
            );
            return;
        }

        this.ws.on(
            "connection",
            async (rawSocket: WebSocket, req: IncomingMessage) => {
                const socket = rawSocket as UiSocket;

                // ---- Authenticate user from cookie JWT ----
                const cookies = parseCookieHeader(
                    (req.headers && (req.headers as any).cookie) || ""
                );
                const token = cookies[this.cookieName];
                if (!token) {
                    this.closeWithPolicy(socket, 4401, "Missing auth cookie");
                    return;
                }

                let userId = "";
                try {
                    const payload: any = await this.jwt.verifyAsync(token, {
                        secret: this.jwtSecret,
                    });
                    // Expect standard fields from your login flow
                    userId = String(payload?.sub || payload?.id || "");
                    if (!userId) throw new Error("No sub in JWT");
                } catch (e: any) {
                    this.closeWithPolicy(
                        socket,
                        4401,
                        `Invalid auth token: ${e?.message || e}`
                    );
                    return;
                }

                // ---- Register socket ----
                try {
                    // Ensure subscriptions set exists for this socket
                    socket.subscriptions = socket.subscriptions ?? new Set<string>();
                    this.uiSockets.add(userId, socket);

                    // Ack the connection
                    socket.send(
                        safeJson({
                            t: "ack",
                            userId,
                            subscriptions: Array.from(socket.subscriptions),
                            totals: {
                                sockets: this.uiSockets.countAll(),
                                users: this.uiSockets.countUsers(),
                            },
                        })
                    );
                } catch (e: any) {
                    this.log.warn(
                        `Failed to register UI socket for user ${userId}: ${e?.message || e}`
                    );
                    this.closeWithPolicy(socket, 1011, "Registration failed");
                    return;
                }

                // ---- Message handling ----
                socket.on("message", (data: RawData) => {
                    const text = this.rawToString(data);
                    if (!text) return;

                    let msg: any;
                    try {
                        msg = JSON.parse(text);
                    } catch {
                        return;
                    }
                    const t: string = String(msg?.t || "");

                    // Ping/Pong
                    if (t === "ping") {
                        socket.send(safeJson({ t: "pong", at: new Date().toISOString() }));
                        return;
                    }

                    // Subscribe to a deviceId
                    if (t === "subscribe") {
                        const deviceId = String(msg?.deviceId || "").trim();
                        if (!deviceId) return;

                        try {
                            this.uiSockets.subscribe(socket, deviceId);
                            socket.send(
                                safeJson({
                                    t: "subscribed",
                                    deviceId,
                                    subscribers: this.uiSockets.countDeviceSubscribers(deviceId),
                                })
                            );
                        } catch (e: any) {
                            socket.send(
                                safeJson({
                                    t: "error",
                                    error: "subscribe_failed",
                                    message: e?.message || String(e),
                                })
                            );
                        }
                        return;
                    }

                    // Unsubscribe from a deviceId
                    if (t === "unsubscribe") {
                        const deviceId = String(msg?.deviceId || "").trim();
                        if (!deviceId) return;

                        try {
                            this.uiSockets.unsubscribe(socket, deviceId);
                            socket.send(
                                safeJson({
                                    t: "unsubscribed",
                                    deviceId,
                                    subscribers: this.uiSockets.countDeviceSubscribers(deviceId),
                                })
                            );
                        } catch (e: any) {
                            socket.send(
                                safeJson({
                                    t: "error",
                                    error: "unsubscribe_failed",
                                    message: e?.message || String(e),
                                })
                            );
                        }
                        return;
                    }

                    // Unknown message type — ignore silently or send error
                });

                // ---- Cleanup on close/error ----
                const cleanup = () => {
                    try {
                        this.uiSockets.remove(socket);
                    } catch {
                        /* ignore */
                    }
                };
                socket.on("close", cleanup);
                socket.on("error", cleanup);
            }
        );
    }

    onModuleDestroy() {
        try {
            this.ws?.close();
        } catch {
            /* ignore */
        }
    }

    /* ------------------------------- Helpers -------------------------------- */

    private rawToString(data: RawData): string {
        if (typeof data === "string") return data;
        if (Buffer.isBuffer(data)) return data.toString("utf8");
        if (Array.isArray(data))
            return Buffer.concat(data as Buffer[]).toString("utf8");
        if (data instanceof ArrayBuffer) return Buffer.from(data).toString("utf8");
        return "";
    }

    private closeWithPolicy(ws: WebSocket, code: number, reason: string) {
        try {
            // eslint-disable-next-line @typescript-eslint/no-explicit-any
            (ws as any).close?.(code, reason);
        } catch {
            /* ignore */
        }
    }
}

===== END FILE remoteiq-minimal-e2e\backend\src\ws\dashboard.gateway.ts =====

===== FILE: remoteiq-minimal-e2e\backend\src\app.module.ts (96 lines) =====
// remoteiq-minimal-e2e/backend/src/app.module.ts

import { Module, MiddlewareConsumer, NestModule } from "@nestjs/common";
import { ServeStaticModule } from "@nestjs/serve-static";
import { join } from "path";

import { CommonModule } from "./common/common.module";
import { AuthModule } from "./auth/auth.module";
import { WsModule } from "./ws/ws.module";
import { AgentsModule } from "./agents/agents.module";
import { JobsModule } from "./jobs/jobs.module";
import { DevicesModule } from "./devices/devices.module";
import { HealthModule } from "./health/health.module";
import { AdminModule } from "./admin/admin.module";
import { CompanyModule } from "./company/company.module";
import { BrandingModule } from "./branding/branding.module";
import { LocalizationModule } from "./localization/localization.module";
import { SupportModule } from "./support/support.module";
import { SupportLegalModule } from "./support-legal/support-legal.module";
import { UsersModule } from "./users/users.module";
import { RolesModule } from "./roles/roles.module";
import { SmtpModule } from "./smtp/smtp.module";
import { ScheduleModule } from "@nestjs/schedule";
import { ImapModule } from "./imap/imap.module";
import { SessionCleanerService } from "./maintenance/session-cleaner.service";

import { JwtModule } from "@nestjs/jwt";

// ✅ correct path: the middleware file is under /auth, not /common
import { AuthCookieMiddleware } from "./auth/auth-cookie.middleware";

// ✅ bring PgPoolService into the AppModule DI context
import { StorageModule } from "./storage/storage.module";

@Module({
    imports: [
        // Static files mounted at /static -> maps to /public
        ServeStaticModule.forRoot({
            rootPath: join(__dirname, "..", "public"),
            serveRoot: "/static",
        }),

        // JwtService for middleware
        JwtModule.register({
            secret: process.env.JWT_SECRET ?? "dev-secret",
        }),

        // Base/shared
        CommonModule,

        // ✅ Storage (PgPoolService) must be available for main.ts interceptor registration
        StorageModule,

        // Feature modules
        BrandingModule,
        AuthModule,
        WsModule,
        AgentsModule,
        JobsModule,
        DevicesModule,
        HealthModule,
        AdminModule,
        CompanyModule,
        LocalizationModule,
        SupportModule,
        SupportLegalModule,
        UsersModule,
        RolesModule,

        // SMTP + IMAP
        SmtpModule,
        ScheduleModule.forRoot(),
        ImapModule,
    ],
    providers: [
        // Daily cleanup of revoked sessions
        SessionCleanerService,
    ],
})
export class AppModule implements NestModule {
    configure(consumer: MiddlewareConsumer) {
        // Apply cookie->req.user middleware to everything except obvious public/static routes
        consumer
            .apply(AuthCookieMiddleware)
            .exclude(
                "healthz",
                "docs",
                "docs/(.*)",
                "static/(.*)",      // static files
                "api/auth/login",   // login doesn’t need req.user
                "api/auth/logout"   // logout doesn’t need req.user
            )
            .forRoutes("*");
    }
}

===== END FILE remoteiq-minimal-e2e\backend\src\app.module.ts =====

===== FILE: remoteiq-minimal-e2e\backend\src\main.ts (138 lines) =====
// backend/src/main.ts
import "reflect-metadata";
import "dotenv/config";
import { NestFactory } from "@nestjs/core";
import { AppModule } from "./app.module";
import cookieParser from "cookie-parser";
import { WsAdapter } from "@nestjs/platform-ws";
import { ValidationPipe, INestApplication } from "@nestjs/common";
import * as fs from "fs";
import * as path from "path";

// 👇 add this import to serve static files
import { NestExpressApplication } from "@nestjs/platform-express";

// Pg + interceptor
import { PgPoolService } from "./storage/pg-pool.service";
import { SessionHeartbeatInterceptor } from "./auth/session-heartbeat.interceptor";

/** Mount /docs only when allowed (and if @nestjs/swagger is present). */
async function maybeSetupSwagger(app: INestApplication) {
  const enableSwagger =
    (process.env.SWAGGER ?? "").toLowerCase() === "true" ||
    process.env.NODE_ENV !== "production";

  if (!enableSwagger) {
    console.log("Swagger disabled (set SWAGGER=true to enable).");
    return;
  }
  try {
    // eslint-disable-next-line @typescript-eslint/no-var-requires
    const { SwaggerModule, DocumentBuilder } = require("@nestjs/swagger");
    const config = new DocumentBuilder()
      .setTitle("RemoteIQ API")
      .setDescription("OpenAPI for RemoteIQ RMM")
      .setVersion("v1")
      .addBearerAuth({ type: "http", scheme: "bearer", bearerFormat: "JWT" }, "bearer")
      .build();
    const document = SwaggerModule.createDocument(app, config);
    SwaggerModule.setup("/docs", app, document);
    console.log("Swagger docs mounted at /docs");
  } catch {
    console.log("Swagger not installed. Skip docs (pnpm add -D @nestjs/swagger swagger-ui-express)");
  }
}

function configureCors(app: INestApplication) {
  const isProd = process.env.NODE_ENV === "production";

  const listFromFrontends =
    (process.env.FRONTEND_ORIGINS || "")
      .split(",")
      .map((s) => s.trim())
      .filter(Boolean);

  const listFromAllowed = (process.env.ALLOWED_ORIGIN || "")
    .split(",")
    .map((s) => s.trim())
    .filter(Boolean);

  const origins = listFromFrontends.length ? listFromFrontends : listFromAllowed;

  if (isProd && origins.length > 0) {
    app.enableCors({
      origin: origins,
      credentials: true,
      methods: ["GET", "POST", "PUT", "PATCH", "DELETE", "OPTIONS"],
      allowedHeaders: ["Content-Type", "Authorization", "x-admin-api-key"],
      exposedHeaders: ["Content-Length"],
    });
    console.log("CORS restricted to:", origins);
  } else {
    app.enableCors({
      origin: (_origin, cb) => cb(null, true),
      credentials: true,
      methods: ["GET", "POST", "PUT", "PATCH", "DELETE", "OPTIONS"],
      allowedHeaders: ["Content-Type", "Authorization", "x-admin-api-key"],
      exposedHeaders: ["Content-Length"],
    });
    console.log("CORS open (dev). Set FRONTEND_ORIGINS or ALLOWED_ORIGIN for prod.");
  }
}

async function bootstrap() {
  // Ensure uploads directory exists (multer doesn't create it)
  const uploadsDir = path.join(process.cwd(), "public", "uploads");
  if (!fs.existsSync(uploadsDir)) fs.mkdirSync(uploadsDir, { recursive: true });

  // 👇 tell Nest this is an Express app so we can useStaticAssets
  const app = await NestFactory.create<NestExpressApplication>(AppModule);

  // 👇 serve /static/* from ./public/*
  app.useStaticAssets(path.join(process.cwd(), "public"), {
    prefix: "/static/",
  });

  app.use(cookieParser());
  configureCors(app);

  app.useWebSocketAdapter(new WsAdapter(app));

  app.useGlobalPipes(
    new ValidationPipe({
      whitelist: true,
      forbidNonWhitelisted: true,
      transform: true,
    })
  );

  app.enableShutdownHooks();

  app.getHttpAdapter().getInstance().get("/healthz", (_req: any, res: any) => res.send("OK"));

  await maybeSetupSwagger(app);

  // ✅ Register SessionHeartbeatInterceptor only if PgPoolService is resolvable
  try {
    const pg = app.get(PgPoolService, { strict: false });
    if (pg) {
      app.useGlobalInterceptors(new SessionHeartbeatInterceptor(pg));
      console.log("SessionHeartbeatInterceptor enabled.");
    } else {
      console.warn(
        "PgPoolService not found in AppModule context; SessionHeartbeatInterceptor NOT enabled."
      );
    }
  } catch (err) {
    console.warn(
      "Could not enable SessionHeartbeatInterceptor (continuing without it):",
      (err as Error)?.message || err
    );
  }

  const port = Number(process.env.PORT || 3001);
  await app.listen(port);
  console.log(`API up on http://localhost:${port}`);
}
bootstrap();

===== END FILE remoteiq-minimal-e2e\backend\src\main.ts =====

