================================================================================
RemoteIQ Context Export
Timestamp (local): 2025-10-29 13:00:47
Repo Root: C:\Users\Last Stop\Documents\Programming Projects\RemoteIQ V5
================================================================================
### BACKEND (NestJS) ###
============================= BEGIN FILE =======================================
Path: C:\Users\Last Stop\Documents\Programming Projects\RemoteIQ V5\remoteiq-minimal-e2e\backend\.env
Name: .env
-------------------------------------------------------------------------------# ──────────────────────────────────────────────────────────────────────────────
# Runtime / Server
# ──────────────────────────────────────────────────────────────────────────────
NODE_ENV=<redacted>
PORT=<redacted>

# If you ever run behind HTTPS in prod, set SECURE_COOKIES=true to force secure cookies
# SECURE_COOKIES=true

# ──────────────────────────────────────────────────────────────────────────────
# CORS / Frontend Origins
# ──────────────────────────────────────────────────────────────────────────────
# Comma-separated list of allowed web app origins. Used by backend CORS.
FRONTEND_ORIGINS=<redacted>
# Legacy single-origin variable (kept for compatibility). Not needed if FRONTEND_ORIGINS is set.
ALLOWED_ORIGIN=<redacted>

# ──────────────────────────────────────────────────────────────────────────────
# Public URLs (static files, websocket, API base for the frontend)
# ──────────────────────────────────────────────────────────────────────────────
# What the frontend uses to call the backend API.
NEXT_PUBLIC_API_BASE=<redacted>
# What the frontend uses to connect to websockets.
NEXT_PUBLIC_WS_BASE=<redacted>
# Public base for static files. Files saved in backend /public are served under /static
# e.g. /public/uploads/foo.png => http://localhost:3001/static/uploads/foo.png
PUBLIC_BASE_URL=<redacted>

# ──────────────────────────────────────────────────────────────────────────────
# Auth (JWT + cookie)
# ──────────────────────────────────────────────────────────────────────────────
# Name of the auth cookie the backend sets and reads.
AUTH_COOKIE_NAME=<redacted>
# JWT signing secret + expiry
JWT_SECRET=<redacted>
# Supports e.g. "7d", "12h", or raw seconds (604800).
JWT_EXPIRES=<redacted>

# Optional: If your admin API endpoints require an x-admin-api-key header.
ADMIN_API_KEY=<redacted>

# ──────────────────────────────────────────────────────────────────────────────
# Enrollment / Agents
# ──────────────────────────────────────────────────────────────────────────────
ENROLLMENT_SECRET=<redacted>

# ──────────────────────────────────────────────────────────────────────────────
# Database (PostgreSQL)
# ──────────────────────────────────────────────────────────────────────────────
DATABASE_URL=<redacted>

# Optional Pool/SSL tuning read by PgPoolService (uncomment to override defaults)
# DATABASE_SSL=false
# DATABASE_POOL_MAX=10
# DATABASE_POOL_MIN=0

# ──────────────────────────────────────────────────────────────────────────────
# Uploads / Avatar
# ──────────────────────────────────────────────────────────────────────────────
# Max avatar size in megabytes (read by the avatar upload endpoint)
AVATAR_MAX_MB=<redacted>

# ──────────────────────────────────────────────────────────────────────────────
# SMTP (outbound mail)
# ──────────────────────────────────────────────────────────────────────────────
# Simple in-memory rate limiting
SMTP_RATE_TOKENS=<redacted>
SMTP_RATE_REFILL=<redacted>

# Nodemailer pool mode
SMTP_POOL=<redacted>
SMTP_POOL_MAX_CONN=<redacted>
SMTP_POOL_MAX_MSG=<redacted>

# Optional non-prod test recipient guard (e.g., only allow *@example.com)
SMTP_TEST_DOMAIN=<redacted>

# ──────────────────────────────────────────────────────────────────────────────
# DKIM (optional; signs outgoing mail if set)
# ──────────────────────────────────────────────────────────────────────────────
DKIM_DOMAIN=<redacted>
DKIM_KEY_SELECTOR=<redacted>
# Paste the RSA private key exactly. Quotes allow multi-line here.
DKIM_PRIVATE_KEY=<redacted>
MIIEvgIBADANBgkqhkiG9w0BAQEFAASCBK...
-----END PRIVATE KEY-----"

# ──────────────────────────────────────────────────────────────────────────────
# IMAP Poller (optional intake)
# ──────────────────────────────────────────────────────────────────────────────
IMAP_POLL_ENABLED=<redacted>
IMAP_POLL_PURPOSE=<redacted>
IMAP_POLL_EVERY_MS=<redacted>
IMAP_POLL_MAX_PER_TICK=<redacted>
IMAP_MOVE_TO=<redacted>

============================== END FILE ========================================
============================= BEGIN FILE =======================================
Path: C:\Users\Last Stop\Documents\Programming Projects\RemoteIQ V5\remoteiq-minimal-e2e\backend\node_modules\.pnpm\@nestjs+schematics@11.0.9_chokidar@4.0.3_typescript@5.8.3\node_modules\@nestjs\schematics\dist\lib\application\files\ts\src\app.module.ts
Name: app.module.ts
-------------------------------------------------------------------------------import { Module } from '@nestjs/common';
import { AppController } from './app.controller';
import { AppService } from './app.service';

@Module({
  imports: [],
  controllers: [AppController],
  providers: [AppService],
})
export class AppModule {}

============================== END FILE ========================================
============================= BEGIN FILE =======================================
Path: C:\Users\Last Stop\Documents\Programming Projects\RemoteIQ V5\remoteiq-minimal-e2e\backend\node_modules\.pnpm\@nestjs+serve-static@5.0.4__b9f24ce09f827f8d5617209128ed4153\node_modules\@nestjs\serve-static\tests\src\app.module.ts
Name: app.module.ts
-------------------------------------------------------------------------------import { Module } from '@nestjs/common';
import { join } from 'path';
import { ServeStaticModule } from '../../lib';
import { AppController } from './app.controller';

@Module({
  controllers: [AppController]
})
export class AppModule {
  static withDefaults() {
    return {
      module: AppModule,
      imports: [
        ServeStaticModule.forRoot({
          rootPath: join(__dirname, '..', 'client'),
          exclude: ['/api/{*any}']
        })
      ]
    };
  }

  static withFallthrough() {
    return {
      module: AppModule,
      imports: [
        ServeStaticModule.forRoot({
          rootPath: join(__dirname, '..', 'client'),
          exclude: ['/api/{*any}'],
          serveStaticOptions: {
            fallthrough: true
          }
        })
      ]
    };
  }

  static withoutFallthrough() {
    return {
      module: AppModule,
      imports: [
        ServeStaticModule.forRoot({
          rootPath: join(__dirname, '..', 'client'),
          exclude: ['/api/{*any}'],
          serveStaticOptions: {
            fallthrough: false
          }
        })
      ]
    };
  }
}

============================== END FILE ========================================
============================= BEGIN FILE =======================================
Path: C:\Users\Last Stop\Documents\Programming Projects\RemoteIQ V5\remoteiq-minimal-e2e\backend\prisma\schema.prisma
Name: schema.prisma
-------------------------------------------------------------------------------generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider = "sqlite"
  url      = env("DATABASE_URL")
}

model Agent {
  id              String   @id @default(uuid())
  deviceId        String   @unique
  hostname        String
  os              String
  arch            String
  lastHeartbeatAt DateTime?
  version         String
  enrolledAt      DateTime @default(now())
  tokenHash       String   @unique

  jobs Job[]
}

model Job {
  id           String   @id @default(uuid())
  agentId      String
  type         String
  payload      String   // JSON string (SQLite-safe)
  status       String
  createdAt    DateTime @default(now())
  updatedAt    DateTime @updatedAt
  dispatchedAt DateTime?
  startedAt    DateTime?
  finishedAt   DateTime?

  agent  Agent   @relation(fields: [agentId], references: [id])
  result JobResult?

  @@index([agentId])
  @@index([status])
}

model JobResult {
  id         String   @id @default(uuid())
  jobId      String   @unique
  exitCode   Int
  stdout     String
  stderr     String
  durationMs Int
  createdAt  DateTime @default(now())

  job Job @relation(fields: [jobId], references: [id])
}

============================== END FILE ========================================
============================= BEGIN FILE =======================================
Path: C:\Users\Last Stop\Documents\Programming Projects\RemoteIQ V5\remoteiq-minimal-e2e\backend\src\app.module.ts
Name: app.module.ts
-------------------------------------------------------------------------------//remoteiq-minimal-e2e\backend\src\app.module.ts

import { Module, MiddlewareConsumer, NestModule } from "@nestjs/common";
import { ServeStaticModule } from "@nestjs/serve-static";
import { join } from "path";

import { CommonModule } from "./common/common.module";
import { AuthModule } from "./auth/auth.module";
import { WsModule } from "./ws/ws.module";
import { AgentsModule } from "./agents/agents.module";
import { JobsModule } from "./jobs/jobs.module";
import { DevicesModule } from "./devices/devices.module";
import { HealthModule } from "./health/health.module";
import { AdminModule } from "./admin/admin.module";
import { CompanyModule } from "./company/company.module";
import { BrandingModule } from "./branding/branding.module";
import { LocalizationModule } from "./localization/localization.module";
import { SupportModule } from "./support/support.module";
import { SupportLegalModule } from "./support-legal/support-legal.module";
import { UsersModule } from "./users/users.module";
import { RolesModule } from "./roles/roles.module";
import { SmtpModule } from "./smtp/smtp.module";
import { ScheduleModule } from "@nestjs/schedule";
import { ImapModule } from "./imap/imap.module";
import { SessionCleanerService } from "./maintenance/session-cleaner.service";

import { JwtModule } from "@nestjs/jwt";
import { AuthCookieMiddleware } from "./common/auth-cookie.middleware";

// ✅ bring PgPoolService into the AppModule DI context
import { StorageModule } from "./storage/storage.module";

@Module({
    imports: [
        // Static files mounted at /static -> maps to /public
        ServeStaticModule.forRoot({
            rootPath: join(__dirname, "..", "public"),
            serveRoot: "/static",
        }),

        // JwtService for middleware
        JwtModule.register({
            secret: process.env.JWT_SECRET ?? "dev-secret",
        }),

        // Base/shared
        CommonModule,

        // ✅ Storage (PgPoolService) must be available for main.ts interceptor registration
        StorageModule,

        // Feature modules
        BrandingModule,
        AuthModule,
        WsModule,
        AgentsModule,
        JobsModule,
        DevicesModule,
        HealthModule,
        AdminModule,
        CompanyModule,
        LocalizationModule,
        SupportModule,
        SupportLegalModule,
        UsersModule,
        RolesModule,

        // SMTP + IMAP
        SmtpModule,
        ScheduleModule.forRoot(),
        ImapModule,
    ],
    providers: [
        // Daily cleanup of revoked sessions
        SessionCleanerService,
    ],
})
export class AppModule implements NestModule {
    configure(consumer: MiddlewareConsumer) {
        // Apply cookie->req.user middleware to everything except obvious public/static routes
        consumer
            .apply(AuthCookieMiddleware)
            .exclude(
                "healthz",
                "docs",
                "docs/(.*)",
                "static/(.*)",      // static files
                "api/auth/login",   // login doesn’t need req.user
                "api/auth/logout"   // logout doesn’t need req.user
            )
            .forRoutes("*");
    }
}

============================== END FILE ========================================
============================= BEGIN FILE =======================================
Path: C:\Users\Last Stop\Documents\Programming Projects\RemoteIQ V5\remoteiq-minimal-e2e\backend\src\devices\device-actions.controller.ts
Name: device-actions.controller.ts
-------------------------------------------------------------------------------// backend/src/devices/device-actions.controller.ts
import {
    Body,
    Controller,
    HttpCode,
    NotFoundException,
    Param,
    Post,
    UsePipes,
    ValidationPipe,
} from "@nestjs/common";
import { JobsService } from "../jobs/jobs.service";

class ActionRequestDto {
    // Optional free-form reason; kept permissive
    reason?: string;
}

type ActionResponse = {
    accepted: true;
    jobId: string;
};

@UsePipes(new ValidationPipe({ whitelist: true, transform: true }))
@Controller("/api/devices/:id/actions")
export class DeviceActionsController {
    constructor(private readonly jobs: JobsService) { }

    /**
     * Reboot the device.
     * POST /api/devices/:id/actions/reboot -> { accepted, jobId }
     */
    @Post("reboot")
    @HttpCode(202)
    async reboot(
        @Param("id") agentId: string, // this should be the Agent ID your WS layer uses
        @Body() _body: ActionRequestDto
    ): Promise<ActionResponse> {
        if (!agentId) throw new NotFoundException("Missing device id");

        const job = await this.jobs.createRunScriptJob({
            agentId,
            language: "powershell",     // or "bash" if your agent is Linux
            scriptText:
                // Windows reboot (powershell)
                'Start-Process "shutdown" -ArgumentList "/r /t 5" -Verb RunAs',
            timeoutSec: 60,
        });

        return { accepted: true, jobId: job.id };
    }

    /**
     * Trigger patch now.
     * POST /api/devices/:id/actions/patch -> { accepted, jobId }
     */
    @Post("patch")
    @HttpCode(202)
    async patch(
        @Param("id") agentId: string,
        @Body() _body: ActionRequestDto
    ): Promise<ActionResponse> {
        if (!agentId) throw new NotFoundException("Missing device id");

        const job = await this.jobs.createRunScriptJob({
            agentId,
            language: "powershell",
            scriptText:
                // naive Windows Update start (example; replace with your updater)
                'Install-Module PSWindowsUpdate -Force -Scope CurrentUser; Import-Module PSWindowsUpdate; Get-WindowsUpdate -AcceptAll -Install -AutoReboot',
            timeoutSec: 15 * 60,
        });

        return { accepted: true, jobId: job.id };
    }
}

============================== END FILE ========================================
============================= BEGIN FILE =======================================
Path: C:\Users\Last Stop\Documents\Programming Projects\RemoteIQ V5\remoteiq-minimal-e2e\backend\src\devices\device-insights.controller.ts
Name: device-insights.controller.ts
-------------------------------------------------------------------------------// src/devices/device-insights.controller.ts
import { Controller, Get, Param } from "@nestjs/common";

type CheckStatus = "Passing" | "Warning" | "Failing";

export type DeviceCheck = {
    id: string;
    name: string;
    status: CheckStatus;
    lastRun: string; // ISO or humanized
    output: string;
};

export type DeviceSoftware = {
    id: string;
    name: string;
    version: string;
    publisher?: string | null;
    installDate?: string | null; // ISO
};

@Controller("/api/devices/:id")
export class DeviceInsightsController {
    // For now we return mock data. Swap these with DB/agent lookups later.
    @Get("checks")
    async getChecks(@Param("id") deviceId: string): Promise<{ items: DeviceCheck[] }> {
        const now = new Date();
        const items: DeviceCheck[] = [
            { id: "chk-1", name: "Ping", status: "Passing", lastRun: new Date(now.getTime() - 60_000).toISOString(), output: "8.8.8.8: 12ms" },
            { id: "chk-2", name: "Disk C:\\ free", status: "Passing", lastRun: new Date(now.getTime() - 5 * 60_000).toISOString(), output: "375GB free of 500GB" },
            { id: "chk-3", name: "CPU Load (5m)", status: "Warning", lastRun: new Date(now.getTime() - 90_000).toISOString(), output: "85% avg (5m)" },
            { id: "chk-4", name: "Spooler service", status: "Passing", lastRun: new Date(now.getTime() - 10 * 60_000).toISOString(), output: "Running" },
            { id: "chk-5", name: "AV Definitions", status: "Failing", lastRun: new Date(now.getTime() - 2 * 60 * 60_000).toISOString(), output: "Out of date (10 days)" },
        ];
        // eslint-disable-next-line @typescript-eslint/no-unused-vars
        void deviceId; // reserved for future filtering
        return { items };
    }

    @Get("software")
    async getSoftware(@Param("id") deviceId: string): Promise<{ items: DeviceSoftware[] }> {
        const items: DeviceSoftware[] = [
            { id: "sw-1", name: "Google Chrome", version: "128.0.0", publisher: "Google LLC", installDate: "2024-06-02" },
            { id: "sw-2", name: "Visual Studio Code", version: "1.94.2", publisher: "Microsoft", installDate: "2024-05-28" },
            { id: "sw-3", name: "7-Zip", version: "24.07", publisher: "Igor Pavlov", installDate: "2024-05-11" },
            { id: "sw-4", name: "Node.js", version: "20.14.0", publisher: "OpenJS Foundation", installDate: "2024-04-20" },
        ];
        // eslint-disable-next-line @typescript-eslint/no-unused-vars
        void deviceId;
        return { items };
    }
}

============================== END FILE ========================================
============================= BEGIN FILE =======================================
Path: C:\Users\Last Stop\Documents\Programming Projects\RemoteIQ V5\remoteiq-minimal-e2e\backend\src\devices\dto\uninstall-software.dto.ts
Name: uninstall-software.dto.ts
-------------------------------------------------------------------------------//remoteiq-minimal-e2e\backend\src\devices\dto\uninstall-software.dto.ts

import { IsOptional, IsString } from "class-validator";

export class UninstallSoftwareDto {
    @IsString()
    name!: string;

    @IsOptional()
    @IsString()
    version?: string;
}

============================== END FILE ========================================
============================= BEGIN FILE =======================================
Path: C:\Users\Last Stop\Documents\Programming Projects\RemoteIQ V5\remoteiq-minimal-e2e\backend\src\jobs\agent-jobs.controller.ts
Name: agent-jobs.controller.ts
-------------------------------------------------------------------------------import { Body, Controller, HttpCode, Param, Post, UseGuards } from "@nestjs/common";
import { JobsService } from "./jobs.service";
import { AgentTokenGuard, getAgentFromRequest } from "../common/agent-token.util";
import { Req } from "@nestjs/common";

@Controller("/api/agent/jobs")
export class AgentJobsController {
    constructor(private readonly jobs: JobsService) { }

    // Agent says: I started running this job
    @Post(":id/running")
    @UseGuards(AgentTokenGuard)
    @HttpCode(204)
    async running(@Req() req: any, @Param("id") jobId: string) {
        // (optional) verify job belongs to this agent: compare req.agent.id with jobs.getJobWithResult(jobId).agent_id
        await this.jobs.markRunning(jobId);
    }

    // Agent says: I finished this job (success/fail/timeout)
    @Post(":id/finish")
    @UseGuards(AgentTokenGuard)
    @HttpCode(204)
    async finish(
        @Req() req: any,
        @Param("id") jobId: string,
        @Body()
        body: {
            status: "succeeded" | "failed" | "timeout";
            exitCode: number;
            stdout: string;
            stderr: string;
            durationMs: number;
        },
    ) {
        await this.jobs.finishJob(
            jobId,
            {
                exitCode: body.exitCode ?? -1,
                stdout: body.stdout ?? "",
                stderr: body.stderr ?? "",
                durationMs: Math.max(0, body.durationMs ?? 0),
            },
            body.status,
        );
    }
}

============================== END FILE ========================================
============================= BEGIN FILE =======================================
Path: C:\Users\Last Stop\Documents\Programming Projects\RemoteIQ V5\remoteiq-minimal-e2e\backend\src\jobs\dispatcher.service.ts
Name: dispatcher.service.ts
-------------------------------------------------------------------------------import { Injectable, Logger, Inject, forwardRef } from "@nestjs/common";
import { PgPoolService } from "../storage/pg-pool.service";
import { SocketRegistry } from "../common/socket-registry.service";
import { JobsService } from "./jobs.service";

type RunScriptPayload = {
  language: "powershell" | "bash";
  scriptText: string;
  args?: string[];
  env?: Record<string, string>;
  timeoutSec?: number;
};

// safe parse for jsonb | text
function parsePayload(raw: unknown): any | null {
  if (raw == null) return null;
  if (typeof raw === "string") {
    try { return JSON.parse(raw); } catch { return null; }
  }
  if (typeof raw === "object") return raw;
  return null;
}
function isRunScriptPayload(v: any): v is RunScriptPayload {
  return !!v &&
    (v.language === "powershell" || v.language === "bash") &&
    typeof v.scriptText === "string";
}

@Injectable()
export class DispatcherService {
  private readonly logger = new Logger("Dispatcher");

  constructor(
    private readonly pg: PgPoolService,
    private readonly sockets: SocketRegistry,
    @Inject(forwardRef(() => JobsService)) private readonly jobs: JobsService,
  ) { }

  /** Try to dispatch a specific queued job to its agent over WS */
  async tryDispatch(jobId: string) {
    // Load job
    const { rows } = await this.pg.query<{
      id: string;
      agent_id: string | number;
      payload: unknown;
      status: string;
    }>(
      `SELECT id, agent_id, payload, status
         FROM jobs
        WHERE id = $1
        LIMIT 1`,
      [jobId],
    );
    const job = rows[0];
    if (!job) return;

    // Always coerce the agent key to string for the registry
    const agentKey = String(job.agent_id);

    // Require socket
    const socket = this.sockets.getByAgent(agentKey);
    if (!socket || (socket as any).readyState !== 1 /* OPEN */) {
      this.logger.debug(`Agent ${agentKey} not connected; job ${job.id} stays queued`);
      return;
    }

    // Parse payload (jsonb object or text JSON)
    const parsed = parsePayload(job.payload);
    if (!isRunScriptPayload(parsed)) {
      this.logger.warn(`Invalid payload JSON for job ${job.id}; marking failed`);
      await this.jobs.finishJob(
        job.id,
        { exitCode: -1, stdout: "", stderr: "Invalid payload JSON", durationMs: 0 },
        "failed",
      );
      return;
    }

    // Send over WS
    try {
      socket.send(
        JSON.stringify({
          t: "job_run_script",
          jobId: job.id,
          language: parsed.language,
          scriptText: parsed.scriptText,
          args: parsed.args ?? [],
          env: parsed.env ?? {},
          timeoutSec: parsed.timeoutSec ?? 120,
        }),
      );
      await this.jobs.markDispatched(job.id);
    } catch (e: any) {
      this.logger.warn(`WS send failed for job ${job.id}: ${e?.message ?? e}`);
    }
  }

  /** Opportunistically dispatch all queued jobs for an agent (called on connect) */
  async dispatchQueuedForAgent(agentId: string | number) {
    const agentKey = String(agentId);
    const { rows } = await this.pg.query<{ id: string }>(
      `SELECT id
         FROM jobs
        WHERE agent_id = $1 AND status = 'queued'
        ORDER BY created_at ASC`,
      [agentKey],
    );
    for (const j of rows) {
      await this.tryDispatch(j.id);
    }
  }
}

============================== END FILE ========================================
============================= BEGIN FILE =======================================
Path: C:\Users\Last Stop\Documents\Programming Projects\RemoteIQ V5\remoteiq-minimal-e2e\backend\src\jobs\jobs.controller.ts
Name: jobs.controller.ts
-------------------------------------------------------------------------------// backend/src/jobs/jobs.controller.ts
import {
  Body,
  Controller,
  Get,
  Param,
  Post,
  Headers,
  UnauthorizedException,
  Logger,
} from "@nestjs/common";
import { JobsService } from "./jobs.service";
import { PgPoolService } from "../storage/pg-pool.service";

@Controller("/api/admin")
export class JobsController {
  private readonly logger = new Logger("JobsController");

  constructor(
    private readonly jobs: JobsService,
    private readonly pg: PgPoolService,
  ) { }

  private checkAdmin(key: string | undefined) {
    if (!key || key !== process.env.ADMIN_API_KEY) {
      throw new UnauthorizedException("invalid admin key");
    }
  }

  @Post("/agents")
  async listAgents(@Headers("x-admin-api-key") key: string | undefined) {
    this.checkAdmin(key);
    try {
      const { rows } = await this.pg.query(
        `SELECT id, device_id, hostname, os, arch, version, created_at, updated_at
           FROM agents
          ORDER BY created_at DESC`,
      );
      return { items: rows };
    } catch (e: any) {
      this.logger.error(`listAgents failed: ${e?.message ?? e}`, e?.stack ?? undefined);
      throw e;
    }
  }

  @Post("/jobs/run-script")
  async runScript(
    @Headers("x-admin-api-key") key: string | undefined,
    @Body()
    body: {
      agentId: string;
      language: "powershell" | "bash";
      scriptText: string;
      args?: string[];
      env?: Record<string, string>;
      timeoutSec?: number;
    },
  ) {
    this.checkAdmin(key);
    try {
      const job = await this.jobs.createRunScriptJob(body);
      return job;
    } catch (e: any) {
      this.logger.error(`run-script failed: ${e?.message ?? e}`, e?.stack ?? undefined);
      throw e;
    }
  }

  @Get("/jobs/:id")
  async getJob(@Headers("x-admin-api-key") key: string | undefined, @Param("id") id: string) {
    this.checkAdmin(key);
    return this.jobs.getJobWithResult(id);
  }
}

============================== END FILE ========================================
============================= BEGIN FILE =======================================
Path: C:\Users\Last Stop\Documents\Programming Projects\RemoteIQ V5\remoteiq-minimal-e2e\backend\src\jobs\jobs.module.ts
Name: jobs.module.ts
-------------------------------------------------------------------------------// backend/src/jobs/jobs.module.ts
import { Module, forwardRef } from "@nestjs/common";
import { StorageModule } from "../storage/storage.module";     // PgPoolService
import { CommonModule } from "../common/common.module";        // SocketRegistry
import { WsModule } from "../ws/ws.module";                    // if you use ws gateway/handlers

import { JobsController } from "./jobs.controller";
import { JobsService } from "./jobs.service";
import { DispatcherService } from "./dispatcher.service";
import { AgentJobsController } from "./agent-jobs.controller";

@Module({
  imports: [
    StorageModule,                 // provides PgPoolService
    CommonModule,                  // exports SocketRegistry
    forwardRef(() => WsModule),    // keep if you have circular deps with ws
  ],
  controllers: [JobsController, AgentJobsController],
  providers: [JobsService, DispatcherService],
  exports: [JobsService, DispatcherService],
})
export class JobsModule { }

============================== END FILE ========================================
============================= BEGIN FILE =======================================
Path: C:\Users\Last Stop\Documents\Programming Projects\RemoteIQ V5\remoteiq-minimal-e2e\backend\src\jobs\jobs.service.ts
Name: jobs.service.ts
-------------------------------------------------------------------------------// backend/src/jobs/jobs.service.ts
import { Injectable, NotFoundException, Logger, Inject, forwardRef } from "@nestjs/common";
import { PgPoolService } from "../storage/pg-pool.service";
import { DispatcherService } from "./dispatcher.service";

type RunScriptInput = {
  agentId: string;
  language: "powershell" | "bash";
  scriptText: string;
  args?: string[];
  env?: Record<string, string>;
  timeoutSec?: number;
};

@Injectable()
export class JobsService {
  private readonly logger = new Logger("JobsService");

  constructor(
    private readonly pg: PgPoolService,
    @Inject(forwardRef(() => DispatcherService)) private readonly dispatcher: DispatcherService,
  ) { }

  /** Create a run-script job in SQL and attempt dispatch */
  async createRunScriptJob(input: RunScriptInput) {
    // Ensure agent exists
    const { rows: agentRows } = await this.pg.query<{ id: string }>(
      `SELECT id FROM agents WHERE id = $1 LIMIT 1`,
      [input.agentId],
    );
    if (!agentRows[0]) throw new NotFoundException("Agent not found");

    // Insert job
    const payload = JSON.stringify({
      language: input.language,
      scriptText: input.scriptText,
      args: input.args ?? [],
      env: input.env ?? {},
      timeoutSec: input.timeoutSec ?? 120,
    });

    const { rows } = await this.pg.query<{
      id: string;
      agent_id: string;
      type: string;
      status: string;
      created_at: string;
    }>(
      `INSERT INTO jobs (agent_id, type, payload, status, created_at)
       VALUES ($1, 'RUN_SCRIPT', $2, 'queued', now())
       RETURNING id, agent_id, type, status, created_at`,
      [input.agentId, payload],
    );

    const job = rows[0];

    // Fire-and-forget dispatch
    this.dispatcher.tryDispatch(job.id).catch((e: any) => {
      this.logger.warn(`Dispatch failed for job ${job.id}: ${e?.message ?? e}`);
    });

    return job;
  }

  /** Read a job and its (optional) result */
  async getJobWithResult(jobId: string) {
    const { rows } = await this.pg.query<any>(
      `SELECT
          j.id,
          j.agent_id,
          j.type,
          j.status,
          j.payload,
          j.created_at,
          j.dispatched_at,
          j.started_at,
          j.finished_at,
          r.exit_code,
          r.stdout,
          r.stderr,
          r.duration_ms
        FROM jobs j
        LEFT JOIN job_results r ON r.job_id = j.id
       WHERE j.id = $1
       LIMIT 1`,
      [jobId],
    );
    const job = rows[0];
    if (!job) throw new NotFoundException("Job not found");
    return job;
  }

  async markDispatched(jobId: string) {
    await this.pg.query(`UPDATE jobs SET status = 'dispatched', dispatched_at = now() WHERE id = $1`, [jobId]);
  }

  async markRunning(jobId: string) {
    await this.pg.query(`UPDATE jobs SET status = 'running', started_at = now() WHERE id = $1`, [jobId]);
  }

  async finishJob(
    jobId: string,
    result: { exitCode: number; stdout: string; stderr: string; durationMs: number },
    status: "succeeded" | "failed" | "timeout",
  ) {
    // Transaction: update job + insert result
    const client = (this.pg as any).ensurePool ? (this.pg as any).ensurePool() : null;
    const pool = client || (this.pg as any).pool || (this.pg as any);
    const conn = await pool.connect();

    try {
      await conn.query("BEGIN");
      await conn.query(`UPDATE jobs SET status = $1, finished_at = now() WHERE id = $2`, [status, jobId]);
      await conn.query(
        `INSERT INTO job_results (job_id, exit_code, stdout, stderr, duration_ms)
         VALUES ($1, $2, $3, $4, $5)`,
        [jobId, result.exitCode, result.stdout, result.stderr, result.durationMs],
      );
      await conn.query("COMMIT");
    } catch (e) {
      await conn.query("ROLLBACK");
      throw e;
    } finally {
      conn.release();
    }
  }
}

============================== END FILE ========================================
============================= BEGIN FILE =======================================
Path: C:\Users\Last Stop\Documents\Programming Projects\RemoteIQ V5\remoteiq-minimal-e2e\backend\src\jobs\runs.controller.ts
Name: runs.controller.ts
-------------------------------------------------------------------------------// backend/src/jobs/runs.controller.ts
import {
    Body,
    Controller,
    Get,
    HttpCode,
    NotFoundException,
    Param,
    Post,
    UsePipes,
    ValidationPipe,
} from "@nestjs/common";
import { RunsService } from "./runs.service";
import { IsIn, IsInt, IsOptional, IsString, Min } from "class-validator";
import { Transform } from "class-transformer";

class RunScriptDto {
    @IsString()
    deviceId!: string;

    @IsString()
    script!: string;

    @IsOptional()
    @IsIn(["powershell", "bash", "cmd"])
    shell?: "powershell" | "bash" | "cmd";

    @IsOptional()
    @IsInt()
    @Min(1)
    @Transform(({ value }) => (value != null ? parseInt(value, 10) : undefined))
    timeoutSec?: number;
}

@UsePipes(new ValidationPipe({ whitelist: true, transform: true }))
@Controller("/api/automation")
export class RunsController {
    constructor(private readonly runs: RunsService) { }

    /**
     * Start a new automation run.
     * Returns { jobId } and uses 202 Accepted for async work.
     */
    @Post("runs")
    @HttpCode(202)
    async start(@Body() body: RunScriptDto): Promise<{ jobId: string }> {
        const jobId = await this.runs.startRun(body);
        return { jobId };
    }

    /**
     * Get the *full* job snapshot (status, log, times, exitCode).
     * Useful for polling if WS isn’t available.
     */
    @Get("runs/:jobId")
    async getSnapshot(
        @Param("jobId") jobId: string
    ): Promise<ReturnType<RunsService["get"]>> {
        const snap = this.runs.get(jobId);
        if (!snap) throw new NotFoundException("Job not found");
        return snap;
    }

    /**
     * Get just the job logs (kept for compatibility with your current UI).
     */
    @Get("runs/:jobId/log")
    async log(
        @Param("jobId") jobId: string
    ): Promise<{ jobId: string; log: string }> {
        const snap = this.runs.get(jobId);
        if (!snap) throw new NotFoundException("Job not found");
        return { jobId, log: snap.log };
    }
}

============================== END FILE ========================================
============================= BEGIN FILE =======================================
Path: C:\Users\Last Stop\Documents\Programming Projects\RemoteIQ V5\remoteiq-minimal-e2e\backend\src\jobs\runs.service.ts
Name: runs.service.ts
-------------------------------------------------------------------------------// backend/src/jobs/runs.service.ts
import { Injectable, Inject, forwardRef } from "@nestjs/common";
import { randomUUID } from "crypto";
import { AgentGateway } from "../ws/agent.gateway";

export type JobStatus = "queued" | "running" | "succeeded" | "failed" | "canceled";

export type JobSnapshot = {
    jobId: string;
    deviceId: string;
    status: JobStatus;
    log: string;
    exitCode?: number | null;
    startedAt: number;
    finishedAt?: number | null;
};

export type StartRunInput = {
    deviceId: string;
    script: string;
    shell?: "powershell" | "bash" | "cmd";
    timeoutSec?: number;
};

@Injectable()
export class RunsService {
    private JOBS = new Map<string, JobSnapshot>();

    constructor(
        @Inject(forwardRef(() => AgentGateway))
        private readonly ws: AgentGateway
    ) { }

    get(jobId: string) {
        return this.JOBS.get(jobId);
    }

    async startRun(input: StartRunInput): Promise<string> {
        const jobId = randomUUID();
        const snap: JobSnapshot = {
            jobId,
            deviceId: input.deviceId,
            status: "queued",
            log: "",
            startedAt: Date.now(),
        };
        this.JOBS.set(jobId, snap);

        this.broadcast(jobId, { status: "queued", progress: 0 });

        // --- Simulated execution: replace these timers with real agent execution ---
        setTimeout(() => {
            this.append(jobId, `$ ${input.shell ?? "ps"} executing...\n`, { status: "running", progress: 5 });
        }, 300);

        setTimeout(() => {
            this.append(jobId, "Doing work...\n", { status: "running", progress: 40 });
        }, 1000);

        setTimeout(() => {
            this.append(jobId, "Halfway there...\n", { status: "running", progress: 65 });
        }, 1800);

        setTimeout(() => {
            this.append(jobId, "Finishing...\n", { status: "running", progress: 90 });
        }, 2500);

        setTimeout(() => {
            const done = this.JOBS.get(jobId);
            if (!done) return;
            done.status = "succeeded";
            done.exitCode = 0;
            done.finishedAt = Date.now();
            done.log += "Done.\n";
            this.broadcast(jobId, { status: "succeeded", progress: 100, chunk: "Done.\n", exitCode: 0 });
        }, 3200);
        // ---------------------------------------------------------------------------

        return jobId;
    }

    private append(jobId: string, chunk: string, payload: { status: JobStatus; progress?: number }) {
        const snap = this.JOBS.get(jobId);
        if (!snap) return;
        snap.status = payload.status;
        snap.log += chunk;
        this.broadcast(jobId, { status: payload.status, progress: payload.progress ?? 0, chunk });
    }

    private broadcast(
        jobId: string,
        data: { status: JobStatus; progress?: number; chunk?: string; exitCode?: number | null }
    ) {
        this.ws.broadcast({
            type: "job.run.updated",
            jobId,
            status: data.status,
            progress: typeof data.progress === "number" ? data.progress : undefined,
            chunk: data.chunk,
            exitCode: data.exitCode ?? null,
            finishedAt: data.status === "succeeded" || data.status === "failed" ? new Date().toISOString() : null,
        });
    }
}

============================== END FILE ========================================
============================= BEGIN FILE =======================================
Path: C:\Users\Last Stop\Documents\Programming Projects\RemoteIQ V5\remoteiq-minimal-e2e\backend\src\ws\agent.gateway.ts
Name: agent.gateway.ts
-------------------------------------------------------------------------------// backend/src/ws/agent.gateway.ts
import {
  Inject,
  Injectable,
  Logger,
  OnModuleDestroy,
  OnModuleInit,
  forwardRef,
} from "@nestjs/common";
import { WebSocketGateway, WebSocketServer } from "@nestjs/websockets";
import type { Server as WsServer, WebSocket, RawData } from "ws";

import { SocketRegistry, type AgentSocket } from "../common/socket-registry.service";
import { DispatcherService } from "../jobs/dispatcher.service";
import { JobsService } from "../jobs/jobs.service";

type JobResultMsg = {
  t: "job_result";
  jobId: string;
  exitCode?: number;
  stdout?: string;
  stderr?: string;
  durationMs?: number;
  status?: string; // agent may send custom text, we will map to our enum
};

type AgentHelloMsg = {
  t: "agent_hello";
  agentId?: string;
  deviceId?: string;
  hostname?: string;
  os?: string;
  arch?: string;
  version?: string;
};

function rawToString(data: RawData): string {
  if (typeof data === "string") return data;
  if (Buffer.isBuffer(data)) return data.toString("utf8");
  if (Array.isArray(data)) return Buffer.concat(data as Buffer[]).toString("utf8");
  if (data instanceof ArrayBuffer) return Buffer.from(data).toString("utf8");
  return "";
}

@WebSocketGateway({ path: "/ws" })
@Injectable()
export class AgentGateway implements OnModuleInit, OnModuleDestroy {
  private readonly log = new Logger("AgentGateway");

  @WebSocketServer()
  private ws!: WsServer;

  constructor(
    private readonly sockets: SocketRegistry,
    @Inject(forwardRef(() => DispatcherService))
    private readonly dispatcher: DispatcherService,
    @Inject(forwardRef(() => JobsService))
    private readonly jobs: JobsService,
  ) { }

  onModuleInit() {
    if (!this.ws) {
      this.log.warn("WS server not initialized by adapter; ensure a WS adapter is configured.");
      return;
    }

    this.ws.on("connection", (socket: WebSocket & Partial<AgentSocket>) => {
      this.log.debug("Agent WS connected (awaiting hello)");

      socket.on("message", async (data: RawData) => {
        const text = rawToString(data);
        if (!text) return;

        let msg: any;
        try {
          msg = JSON.parse(text);
        } catch {
          return;
        }
        const t = msg?.t as string | undefined;
        if (!t) return;

        if (t === "agent_hello") {
          const hello = msg as AgentHelloMsg;
          const agentId = String(hello.agentId ?? "").trim();
          const deviceId = String(hello.deviceId ?? "").trim();
          const hostname = String(hello.hostname ?? "").trim();

          if (!agentId) {
            this.log.warn("agent_hello missing agentId; closing socket.");
            socket.close(1008, "agentId required");
            return;
          }

          // Persist identifiers on the socket so cleanup works
          (socket as AgentSocket).agentId = agentId;
          (socket as AgentSocket).deviceId = deviceId || undefined;
          // AgentSocket doesn't declare hostname; store it loosely for logs/debug
          (socket as any).hostname = hostname || undefined;

          // Register into the registry
          this.sockets.set(agentId, deviceId || undefined, socket as AgentSocket);

          this.log.log(
            `Registered agent socket: agentId=${agentId}` +
            (deviceId ? ` deviceId=${deviceId}` : "") +
            (hostname ? ` host=${hostname}` : ""),
          );

          try {
            await this.dispatcher.dispatchQueuedForAgent(agentId);
          } catch (e: any) {
            this.log.warn(`dispatchQueuedForAgent failed: ${e?.message ?? e}`);
          }
          return;
        }

        if (t === "job_result") {
          const jr = msg as JobResultMsg;
          if (!jr.jobId) {
            this.log.warn("job_result missing jobId; ignoring");
            return;
          }

          const exitCode = Number.isFinite(jr.exitCode) ? Number(jr.exitCode) : -1;
          const stdout = typeof jr.stdout === "string" ? jr.stdout : "";
          const stderr = typeof jr.stderr === "string" ? jr.stderr : "";
          const durationMs = Number.isFinite(jr.durationMs) ? Number(jr.durationMs) : 0;

          // Map to our JobsService status enum: "succeeded" | "failed" | "timeout"
          let status: "succeeded" | "failed" | "timeout";
          const s = (jr.status ?? "").toLowerCase();
          if (s === "timeout") status = "timeout";
          else if (s === "succeeded" || (s === "finished" && exitCode === 0) || exitCode === 0) status = "succeeded";
          else status = "failed";

          try {
            await this.jobs.finishJob(
              jr.jobId,
              { exitCode, stdout, stderr, durationMs },
              status,
            );
          } catch (e: any) {
            this.log.warn(`finishJob failed for ${jr.jobId}: ${e?.message ?? e}`);
          }
          return;
        }
      });

      socket.on("close", () => {
        const s = socket as AgentSocket;
        if (s.agentId) this.sockets.deleteByAgent(s.agentId);
        if (s.deviceId) this.sockets.deleteByDevice(s.deviceId);
      });

      socket.on("error", () => {
        // close handler will clean up
      });
    });
  }

  onModuleDestroy() {
    try {
      this.ws?.close();
    } catch {
      /* ignore */
    }
  }

  /**
   * Broadcast a JSON message to all connected agent sockets.
   * automation.controller.ts expects this to exist.
   */
  public broadcast(payload: unknown, filter?: (s: AgentSocket) => boolean): number {
    if (!this.ws?.clients) return 0;
    let sent = 0;
    for (const client of this.ws.clients) {
      const sock = client as AgentSocket;
      // 'OPEN' is a numeric const on ws WebSocket instances
      if ((client as any).readyState !== (client as any).OPEN) continue;
      if (filter && !filter(sock)) continue;
      try {
        client.send(JSON.stringify(payload));
        sent++;
      } catch {
        // ignore per-socket send errors
      }
    }
    return sent;
  }
}

============================== END FILE ========================================
============================= BEGIN FILE =======================================
Path: C:\Users\Last Stop\Documents\Programming Projects\RemoteIQ V5\remoteiq-minimal-e2e\backend\src\ws\ws.module.ts
Name: ws.module.ts
-------------------------------------------------------------------------------// backend/src/ws/ws.module.ts
import { Module, forwardRef } from "@nestjs/common";
import { AgentGateway } from "./agent.gateway";
import { JobsModule } from "../jobs/jobs.module";
import { CommonModule } from "../common/common.module";
import { StorageModule } from "../storage/storage.module"; // <-- bring PgPoolService into WsModule scope

@Module({
  imports: [
    CommonModule,                 // exports SocketRegistry
    StorageModule,                // exports PgPoolService (required by AgentGateway)
    forwardRef(() => JobsModule), // circular with jobs <-> ws is fine
  ],
  providers: [AgentGateway],
  exports: [AgentGateway],
})
export class WsModule { }

============================== END FILE ========================================

### FRONTEND (Next.js) ###
============================= BEGIN FILE =======================================
Path: C:\Users\Last Stop\Documents\Programming Projects\RemoteIQ V5\remoteiq-frontend\components\data-table.tsx
Name: data-table.tsx
-------------------------------------------------------------------------------"use client";

import * as React from "react";
import {
    ColumnDef,
    flexRender,
    getCoreRowModel,
    getFilteredRowModel,
    getSortedRowModel,
    getPaginationRowModel,
    SortingState,
    VisibilityState,
    ColumnFiltersState,
    RowSelectionState,
    useReactTable,
} from "@tanstack/react-table";

import { cn } from "@/lib/utils";

import { Input } from "@/components/ui/input";
import { Button } from "@/components/ui/button";
import {
    DropdownMenu,
    DropdownMenuTrigger,
    DropdownMenuContent,
    DropdownMenuCheckboxItem,
} from "@/components/ui/dropdown-menu";
import {
    Table,
    TableHeader,
    TableHead,
    TableRow,
    TableBody,
    TableCell,
} from "@/components/ui/table";
import { ChevronLeft, ChevronRight, SlidersHorizontal } from "lucide-react";

type ColumnMeta = { headerClassName?: string; cellClassName?: string };

export type TableSnapshot = {
    sorting: SortingState;
    columnVisibility: VisibilityState;
    columnFilters: ColumnFiltersState;
    pagination: { pageIndex: number; pageSize: number };
};

export type DataTableProps<TData extends { id?: string }, TValue> = {
    columns: ColumnDef<TData, TValue>[];
    data: TData[];

    filterColumn?: string;
    filterInputPlaceholder?: string;

    sorting: SortingState;
    setSorting: React.Dispatch<React.SetStateAction<SortingState>>;
    columnVisibility: VisibilityState;
    setColumnVisibility: React.Dispatch<React.SetStateAction<VisibilityState>>;
    columnFilters: ColumnFiltersState;
    setColumnFilters: React.Dispatch<React.SetStateAction<ColumnFiltersState>>;

    rowSelection?: RowSelectionState;
    setRowSelection?: React.Dispatch<React.SetStateAction<RowSelectionState>>;

    compact?: boolean;

    // Saved Views plumbing + styling
    className?: string;
    /** Register a function that returns the current table snapshot (used by Saved Views). */
    registerSnapshotGetter?: (fn: () => TableSnapshot) => void;
    /** Optional: notify parent whenever table state changes. */
    onTableStateChange?: (snap: TableSnapshot) => void;
};

export function DataTable<TData extends { id?: string }, TValue>({
    columns,
    data,
    filterColumn,
    filterInputPlaceholder = "Filter…",
    sorting,
    setSorting,
    columnVisibility,
    setColumnVisibility,
    columnFilters,
    setColumnFilters,
    rowSelection,
    setRowSelection,
    compact = false,
    className,
    registerSnapshotGetter,
    onTableStateChange,
}: DataTableProps<TData, TValue>) {
    const table = useReactTable({
        data,
        columns,
        state: {
            sorting,
            columnVisibility,
            columnFilters,
            rowSelection: rowSelection ?? {},
        },
        onSortingChange: setSorting,
        onColumnVisibilityChange: setColumnVisibility,
        onColumnFiltersChange: setColumnFilters,
        enableRowSelection: !!setRowSelection,
        onRowSelectionChange: setRowSelection,
        getRowId: (row: any, index) => (row?.id ? String(row.id) : String(index)),
        getCoreRowModel: getCoreRowModel(),
        getFilteredRowModel: getFilteredRowModel(),
        getSortedRowModel: getSortedRowModel(),
        getPaginationRowModel: getPaginationRowModel(),
    });

    // ---- Saved Views snapshot getter (FUNCTION, not value) ----
    const getSnapshot = React.useCallback<() => TableSnapshot>(() => {
        const s = table.getState();
        return {
            sorting: s.sorting,
            columnVisibility: s.columnVisibility,
            columnFilters: s.columnFilters,
            pagination: {
                pageIndex: s.pagination.pageIndex,
                pageSize: s.pagination.pageSize,
            },
        };
    }, [table]);

    // Register getter with consumer (e.g., DashboardContext)
    React.useEffect(() => {
        if (registerSnapshotGetter) registerSnapshotGetter(getSnapshot);
    }, [registerSnapshotGetter, getSnapshot]);

    // Notify consumer when state changes (for autosave/dirty indicators)
    const pageIndex = table.getState().pagination.pageIndex;
    const pageSize = table.getState().pagination.pageSize;
    React.useEffect(() => {
        if (onTableStateChange) onTableStateChange(getSnapshot());
    }, [sorting, columnVisibility, columnFilters, pageIndex, pageSize, onTableStateChange, getSnapshot]);

    const globalFilterValue =
        filterColumn ? ((table.getColumn(filterColumn)?.getFilterValue() as string) ?? "") : "";

    return (
        <div className={cn("space-y-3 min-w-0", className)}>
            {/* Toolbar */}
            <div className="flex items-center gap-2 min-w-0">
                {filterColumn ? (
                    <div className="relative">
                        <Input
                            value={globalFilterValue}
                            onChange={(e) => table.getColumn(filterColumn)?.setFilterValue(e.target.value)}
                            placeholder={filterInputPlaceholder}
                            className="w-[240px] md:w-[320px]"
                            aria-label="Filter rows"
                        />
                    </div>
                ) : null}

                <div className="ml-auto" />

                {/* Columns visibility (stay open while toggling) */}
                <DropdownMenu>
                    <DropdownMenuTrigger asChild>
                        <Button variant="outline" size="sm" className="gap-2" title="Show/hide columns">
                            <SlidersHorizontal className="h-4 w-4" />
                            Columns
                        </Button>
                    </DropdownMenuTrigger>
                    <DropdownMenuContent align="end" className="w-56">
                        {table
                            .getAllLeafColumns()
                            .filter((col) => col.getCanHide?.() ?? true)
                            .map((col) => (
                                <DropdownMenuCheckboxItem
                                    key={col.id}
                                    checked={col.getIsVisible()}
                                    onCheckedChange={(checked) => col.toggleVisibility(!!checked)}
                                    onSelect={(e) => e.preventDefault()} // keep open for multi-toggle
                                    className="capitalize"
                                >
                                    {col.columnDef.header
                                        ? String(
                                            typeof col.columnDef.header === "string"
                                                ? col.columnDef.header
                                                : col.id.replace(/[_-]/g, " "),
                                        )
                                        : col.id.replace(/[_-]/g, " ")}
                                </DropdownMenuCheckboxItem>
                            ))}
                    </DropdownMenuContent>
                </DropdownMenu>
            </div>

            {/* Table */}
            <div className="rounded-md border overflow-hidden">
                <Table className="table-fixed">
                    <TableHeader>
                        {table.getHeaderGroups().map((hg) => (
                            <TableRow key={hg.id}>
                                {hg.headers.map((header) => {
                                    const meta = header.column.columnDef.meta as ColumnMeta | undefined;
                                    return (
                                        <TableHead key={header.id} className={cn("truncate", meta?.headerClassName)}>
                                            {header.isPlaceholder
                                                ? null
                                                : flexRender(header.column.columnDef.header, header.getContext())}
                                        </TableHead>
                                    );
                                })}
                            </TableRow>
                        ))}
                    </TableHeader>

                    <TableBody>
                        {table.getRowModel().rows.length ? (
                            table.getRowModel().rows.map((row) => (
                                <TableRow
                                    key={row.id}
                                    data-state={row.getIsSelected() ? "selected" : undefined}
                                    className={cn("hover:bg-accent/40", compact ? "[&>td]:py-2" : "[&>td]:py-3")}
                                >
                                    {row.getVisibleCells().map((cell) => {
                                        const meta = cell.column.columnDef.meta as ColumnMeta | undefined;
                                        return (
                                            <TableCell key={cell.id} className={cn("truncate", meta?.cellClassName)}>
                                                {flexRender(cell.column.columnDef.cell, cell.getContext())}
                                            </TableCell>
                                        );
                                    })}
                                </TableRow>
                            ))
                        ) : (
                            <TableRow>
                                <TableCell colSpan={columns.length} className="h-24 text-center">
                                    No results.
                                </TableCell>
                            </TableRow>
                        )}
                    </TableBody>
                </Table>
            </div>

            {/* Pagination */}
            <div className="flex items-center justify-end gap-2">
                <div className="text-xs text-muted-foreground">
                    Page {table.getState().pagination.pageIndex + 1} of {table.getPageCount()}
                </div>
                <Button
                    variant="outline"
                    size="icon"
                    onClick={() => table.previousPage()}
                    disabled={!table.getCanPreviousPage()}
                    aria-label="Previous page"
                    title="Previous page"
                >
                    <ChevronLeft className="h-4 w-4" />
                </Button>
                <Button
                    variant="outline"
                    size="icon"
                    onClick={() => table.nextPage()}
                    disabled={!table.getCanNextPage()}
                    aria-label="Next page"
                    title="Next page"
                >
                    <ChevronRight className="h-4 w-4" />
                </Button>
            </div>
        </div>
    );
}

============================== END FILE ========================================
============================= BEGIN FILE =======================================
Path: C:\Users\Last Stop\Documents\Programming Projects\RemoteIQ V5\remoteiq-frontend\components\device-actions.tsx
Name: device-actions.tsx
-------------------------------------------------------------------------------//components\device-actions.tsx

"use client";

import * as React from "react";
import { usePathname, useRouter, useSearchParams } from "next/navigation";
import { Button } from "@/components/ui/button";
import { Play } from "lucide-react";

export default function DeviceActions({ deviceId }: { deviceId: string }) {
    const router = useRouter();
    const pathname = usePathname();
    const searchParams = useSearchParams();

    const openRunScript = React.useCallback(() => {
        // Only update the URL. The Top Bar watcher will open the modal and preselect this device.
        const sp = new URLSearchParams(searchParams);
        sp.set("device", deviceId);     // or: sp.set("runScript", deviceId)
        router.replace(`${pathname}?${sp.toString()}`, { scroll: false });
    }, [deviceId, pathname, router, searchParams]);

    return (
        <div className="flex items-center gap-2">
            <Button size="sm" onClick={openRunScript} className="gap-2">
                <Play className="h-4 w-4" />
                Run Script
            </Button>

            {/* other device actions … */}
            {/* <Button size="sm" variant="secondary">Patch Now</Button> */}
            {/* <Button size="sm" variant="outline">Reboot</Button> */}
        </div>
    );
}

============================== END FILE ========================================
============================= BEGIN FILE =======================================
Path: C:\Users\Last Stop\Documents\Programming Projects\RemoteIQ V5\remoteiq-frontend\components\device-table-columns.tsx
Name: device-table-columns.tsx
-------------------------------------------------------------------------------// C:\Users\Last Stop\Documents\Programming Projects\RemoteIQ V5\remoteiq-frontend\components\device-table-columns.tsx
"use client";

import * as React from "react";
import Link from "next/link";
import { useRouter, usePathname, useSearchParams } from "next/navigation";
import { ColumnDef } from "@tanstack/react-table";
import { formatUsDateTime } from "@/lib/time";
import {
    ArrowUpDown,
    ArrowUp,
    ArrowDown,
    MoreHorizontal,
    PlaySquare,
    ExternalLink,
    Copy,
    CircleDot,
    Edit3,
    Eraser,
} from "lucide-react";

import { Button } from "@/components/ui/button";
import {
    DropdownMenu,
    DropdownMenuContent,
    DropdownMenuItem,
    DropdownMenuLabel,
    DropdownMenuSeparator,
    DropdownMenuTrigger,
} from "@/components/ui/dropdown-menu";
import { Dialog, DialogContent, DialogFooter, DialogHeader, DialogTitle } from "@/components/ui/dialog";
import {
    AlertDialog,
    AlertDialogAction,
    AlertDialogCancel,
    AlertDialogContent,
    AlertDialogDescription,
    AlertDialogFooter,
    AlertDialogHeader,
    AlertDialogTitle,
} from "@/components/ui/alert-dialog";
import { Input } from "@/components/ui/input";

import { StatusBadge } from "@/components/status-badge";
import { Device, useDashboard } from "@/app/(dashboard)/dashboard-context";
import { toast } from "sonner";

function SortIndicator({ isSorted }: { isSorted: false | "asc" | "desc" }) {
    if (!isSorted) return <ArrowUpDown className="ml-2 h-4 w-4 opacity-60" aria-hidden="true" />;
    if (isSorted === "asc") return <ArrowUp className="ml-2 h-4 w-4" aria-hidden="true" />;
    return <ArrowDown className="ml-2 h-4 w-4" aria-hidden="true" />;
}

function SortableHeader({ column, label }: { column: any; label: string }) {
    const isSorted = column.getIsSorted() as false | "asc" | "desc";
    const nextDir = isSorted === "asc" ? "descending" : "ascending";
    return (
        <Button
            variant="ghost"
            className="px-0 font-medium"
            onClick={() => column.toggleSorting(isSorted === "asc")}
            aria-label={`Sort by ${label} ${isSorted ? `(currently ${isSorted})` : ""}`}
            title={`Sort by ${label} ${isSorted ? `(currently ${isSorted}, click to ${nextDir})` : ""}`}
        >
            {label}
            <SortIndicator isSorted={isSorted} />
        </Button>
    );
}

export const columns: ColumnDef<Device>[] = [
    {
        accessorKey: "hostname",
        header: ({ column }) => <SortableHeader column={column} label="Hostname" />,
        cell: ({ row }) => {
            const d = row.original as Device;
            return (
                <Link
                    href={`/devices/${d.id}`}
                    className="hover:underline"
                    onClick={(e) => e.stopPropagation()}
                >
                    {d.alias ? (
                        <div className="leading-tight">
                            {/* changed from text-primary -> text-foreground for dark-mode readability */}
                            <div className="font-medium text-foreground">{d.alias}</div>
                            <div className="text-xs text-muted-foreground">{d.hostname}</div>
                        </div>
                    ) : (
                        // changed from text-primary -> text-foreground
                        <span className="font-medium text-foreground">{d.hostname}</span>
                    )}
                </Link>
            );
        },
    },
    {
        accessorKey: "status",
        header: ({ column }) => <SortableHeader column={column} label="Status" />,
        cell: ({ row }) => <StatusBadge status={row.getValue("status")} />,
    },
    {
        accessorKey: "client",
        header: ({ column }) => <SortableHeader column={column} label="Client" />,
        cell: ({ row }) => <span className="truncate">{row.getValue("client") as string}</span>,
    },
    {
        accessorKey: "site",
        header: ({ column }) => <SortableHeader column={column} label="Site" />,
        cell: ({ row }) => <span className="truncate">{row.getValue("site") as string}</span>,
    },
    {
        accessorKey: "os",
        header: ({ column }) => <SortableHeader column={column} label="Operating System" />,
        cell: ({ row }) => <span>{row.getValue("os") as string}</span>,
    },
    {
        accessorKey: "user",
        header: ({ column }) => <SortableHeader column={column} label="User" />,
        cell: ({ row }) => {
            const u = row.getValue("user") as any;
            if (!u) return <span className="text-muted-foreground">—</span>;
            const text = Array.isArray(u) ? u.filter(Boolean).join(", ") : String(u);
            return <span className="truncate">{text || "—"}</span>;
        },
    },
    {
        accessorKey: "lastResponse",
        header: ({ column }) => <SortableHeader column={column} label="Last Response" />,
        cell: ({ row }) => {
            const iso = row.getValue("lastResponse") as string | null | undefined;
            const pretty = formatUsDateTime(iso);
            return iso ? (
                <time dateTime={iso} title={iso}>
                    {pretty}
                </time>
            ) : (
                <span className="text-muted-foreground">—</span>
            );
        },
    },
    {
        id: "actions",
        enableSorting: false,
        header: () => <span className="sr-only">Actions</span>,
        cell: ({ row }) => <RowActions device={row.original} />,
    },
];

function RowActions({ device }: { device: Device }) {
    const router = useRouter();
    const pathname = usePathname();
    const searchParams = useSearchParams();
    const { updateDeviceAlias } = useDashboard();

    const [menuOpen, setMenuOpen] = React.useState(false);
    const [aliasOpen, setAliasOpen] = React.useState(false);
    const [aliasValue, setAliasValue] = React.useState(device.alias ?? "");
    const [confirmClearOpen, setConfirmClearOpen] = React.useState(false);

    React.useEffect(() => {
        if (aliasOpen) setAliasValue(device.alias ?? "");
    }, [aliasOpen, device.alias]);

    const copy = async (text: string, label: string) => {
        try {
            setMenuOpen(false);
            await navigator.clipboard.writeText(text);
            toast.success(`${label} copied to clipboard`);
        } catch {
            toast.error("Copy failed: your browser blocked clipboard access");
        }
    };

    const saveAlias = () => {
        updateDeviceAlias(device.id, aliasValue || null);
        setAliasOpen(false);
        toast.success(aliasValue ? `Alias set to “${aliasValue}”` : "Alias cleared");
    };

    const openRunScriptHere = () => {
        setMenuOpen(false);
        const sp = new URLSearchParams(searchParams);
        sp.set("runScript", device.id);
        router.push(`${pathname}?${sp.toString()}`);
    };

    const confirmClearAlias = () => {
        updateDeviceAlias(device.id, null);
        setConfirmClearOpen(false);
        toast.success("Alias cleared");
    };

    return (
        <>
            <DropdownMenu open={menuOpen} onOpenChange={setMenuOpen}>
                <DropdownMenuTrigger asChild>
                    <Button
                        variant="ghost"
                        className="h-8 w-8 p-0"
                        onClick={(e) => e.stopPropagation()}
                        aria-label={`Row actions for ${device.hostname}`}
                        title="Row actions"
                    >
                        <MoreHorizontal className="h-4 w-4" aria-hidden />
                    </Button>
                </DropdownMenuTrigger>
                <DropdownMenuContent align="end" onClick={(e) => e.stopPropagation()}>
                    <DropdownMenuLabel>{device.alias || device.hostname}</DropdownMenuLabel>
                    <DropdownMenuSeparator />
                    <DropdownMenuItem
                        onSelect={(e) => {
                            e.preventDefault();
                            setMenuOpen(false);
                            router.push(`/devices/${device.id}`);
                        }}
                    >
                        <ExternalLink className="mr-2 h-4 w-4" />
                        View details
                    </DropdownMenuItem>
                    <DropdownMenuItem
                        onSelect={(e) => {
                            e.preventDefault();
                            openRunScriptHere();
                        }}
                    >
                        <PlaySquare className="mr-2 h-4 w-4" />
                        Run Script…
                    </DropdownMenuItem>
                    <DropdownMenuSeparator />
                    <DropdownMenuItem
                        onSelect={(e) => {
                            e.preventDefault();
                            setMenuOpen(false);
                            setAliasOpen(true);
                        }}
                    >
                        <Edit3 className="mr-2 h-4 w-4" />
                        Edit alias…
                    </DropdownMenuItem>
                    {device.alias ? (
                        <DropdownMenuItem
                            className="text-destructive focus:text-destructive"
                            onSelect={(e) => {
                                e.preventDefault();
                                setMenuOpen(false);
                                setConfirmClearOpen(true);
                            }}
                        >
                            <Eraser className="mr-2 h-4 w-4" />
                            Clear alias
                        </DropdownMenuItem>
                    ) : null}
                    <DropdownMenuSeparator />
                    <DropdownMenuItem
                        onSelect={(e) => {
                            e.preventDefault();
                            copy(device.hostname, "Hostname");
                        }}
                    >
                        <Copy className="mr-2 h-4 w-4" />
                        Copy hostname
                    </DropdownMenuItem>
                    <DropdownMenuItem
                        onSelect={(e) => {
                            e.preventDefault();
                            copy(device.id, "Device ID");
                        }}
                    >
                        <CircleDot className="mr-2 h-4 w-4" />
                        Copy device ID
                    </DropdownMenuItem>
                </DropdownMenuContent>
            </DropdownMenu>

            {/* Alias dialog */}
            <Dialog open={aliasOpen} onOpenChange={setAliasOpen}>
                <DialogContent onClick={(e) => e.stopPropagation()}>
                    <DialogHeader>
                        <DialogTitle>Edit alias</DialogTitle>
                    </DialogHeader>
                    <div className="py-2">
                        <Input
                            autoFocus
                            placeholder="e.g., Accounting File Server"
                            value={aliasValue}
                            onChange={(e) => setAliasValue(e.target.value)}
                            onKeyDown={(e) => {
                                if (e.key === "Enter") saveAlias();
                            }}
                        />
                    </div>
                    <DialogFooter>
                        <Button variant="outline" onClick={() => setAliasOpen(false)} title="Cancel">
                            Cancel
                        </Button>
                        <Button onClick={saveAlias} title="Save alias">
                            Save
                        </Button>
                    </DialogFooter>
                </DialogContent>
            </Dialog>

            {/* Clear alias confirm */}
            <AlertDialog open={confirmClearOpen} onOpenChange={setConfirmClearOpen}>
                <AlertDialogContent>
                    <AlertDialogHeader>
                        <AlertDialogTitle>Clear alias?</AlertDialogTitle>
                        <AlertDialogDescription>
                            This will remove the alias for this device.
                        </AlertDialogDescription>
                    </AlertDialogHeader>
                    <AlertDialogFooter>
                        <AlertDialogCancel>Cancel</AlertDialogCancel>
                        <AlertDialogAction
                            className="bg-destructive text-destructive-foreground hover:bg-destructive/90"
                            onClick={confirmClearAlias}
                            title="Confirm clear alias"
                        >
                            Clear alias
                        </AlertDialogAction>
                    </AlertDialogFooter>
                </AlertDialogContent>
            </AlertDialog>
        </>
    );
}

============================== END FILE ========================================
============================= BEGIN FILE =======================================
Path: C:\Users\Last Stop\Documents\Programming Projects\RemoteIQ V5\remoteiq-frontend\components\device-table.tsx
Name: device-table.tsx
-------------------------------------------------------------------------------// components/device-table.tsx
"use client";

import * as React from "react";
import type {
    SortingState,
    VisibilityState,
    ColumnFiltersState,
} from "@tanstack/react-table";

import { useDashboard, type Device } from "@/app/(dashboard)/dashboard-context";
import { DataTable } from "@/components/data-table";
import { columns } from "@/components/device-table-columns";
import { useDevices } from "@/lib/use-devices";
import type { DeviceStatus as HookDeviceStatus } from "@/lib/use-devices";

type Props = {
    dataOverride?: Device[];
    filterColumnId?: string;
    filterPlaceholder?: string;
    compact?: boolean;
};

export default function DeviceTable({
    dataOverride,
    filterColumnId = "hostname",
    filterPlaceholder = "Filter devices…",
    compact = false,
}: Props) {
    const {
        // table state
        sorting,
        setSorting,
        columnVisibility,
        setColumnVisibility,
        columnFilters,
        setColumnFilters,

        // 🔌 Saved Views glue
        registerSnapshotGetter,
        // onTableStateChange, // <- optional if you add it to context later

        // legacy local source (kept for dataOverride and backward-compat)
        filteredDevices,

        // filters coming from your left rail (Status/OS)
        activeFilters,
    } = useDashboard();

    // === Backend link-up ===

    // derive "q" from this table's filter input for the chosen column
    const q =
        (columnFilters.find((f) => f.id === (filterColumnId ?? "hostname"))
            ?.value as string) || undefined;

    // Normalize TitleCase -> lowercase for the hook; memoized for clean deps
    const uiFilters = React.useMemo(() => {
        const normalizedStatus = (activeFilters?.status ?? [])
            .map((s) => (typeof s === "string" ? s.toLowerCase() : s)) as HookDeviceStatus[];
        return {
            q,
            status: normalizedStatus,
            os: activeFilters?.os, // ["Windows" | "Linux" | "macOS"]
        };
    }, [q, activeFilters]);

    // fetch from /api/devices with cursor pagination
    const {
        items,
        loading,
        error,
        hasMore,
        pageSize,
        setPageSize,
        setUiFilters,
        loadMore,
        refresh,
    } = useDevices(25);

    // push current filters into the hook whenever they change
    React.useEffect(() => {
        setUiFilters(uiFilters);
    }, [uiFilters, setUiFilters]);

    // Final data source: prefer override, else live items from API
    const data: Device[] = React.useMemo(
        () =>
            Array.isArray(dataOverride)
                ? dataOverride
                : ((items as unknown) as Device[]), // cast through unknown to UI Device shape
        [dataOverride, items]
    );

    return (
        <>
            <DataTable<Device, unknown>
                columns={columns}
                data={data}
                filterColumn={filterColumnId}
                filterInputPlaceholder={filterPlaceholder}
                sorting={sorting as SortingState}
                setSorting={setSorting as React.Dispatch<React.SetStateAction<SortingState>>}
                columnVisibility={columnVisibility as VisibilityState}
                setColumnVisibility={
                    setColumnVisibility as React.Dispatch<React.SetStateAction<VisibilityState>>
                }
                columnFilters={columnFilters as ColumnFiltersState}
                setColumnFilters={
                    setColumnFilters as React.Dispatch<React.SetStateAction<ColumnFiltersState>>
                }
                compact={compact}
                // ✅ Saved Views snapshot registration preserved
                registerSnapshotGetter={registerSnapshotGetter}
            // onTableStateChange={onTableStateChange} // optional
            />

            {/* Optional, lightweight backend pagination + controls (non-breaking) */}
            <div className="mt-2 flex items-center justify-between gap-2">
                <div className="text-sm text-muted-foreground">
                    {loading ? "Loading…" : error ? (
                        <span className="text-destructive">{String(error)}</span>
                    ) : null}
                </div>

                <div className="flex items-center gap-2">
                    <select
                        className="border rounded px-2 py-1"
                        value={pageSize}
                        onChange={(e) => setPageSize(Number(e.target.value))}
                        title="Rows per page (server fetch)"
                    >
                        {[10, 25, 50, 100, 200].map((n) => (
                            <option key={n} value={n}>
                                {n}/page
                            </option>
                        ))}
                    </select>

                    <button
                        className="border rounded px-2 py-1"
                        onClick={refresh}
                        disabled={loading}
                    >
                        {loading ? "Loading…" : "Refresh"}
                    </button>

                    {hasMore && (
                        <button
                            className="border rounded px-3 py-1"
                            onClick={loadMore}
                            disabled={loading}
                        >
                            {loading ? "Loading…" : "Load more"}
                        </button>
                    )}
                </div>
            </div>
        </>
    );
}

============================== END FILE ========================================
============================= BEGIN FILE =======================================
Path: C:\Users\Last Stop\Documents\Programming Projects\RemoteIQ V5\remoteiq-frontend\components\patch-tab.tsx
Name: patch-tab.tsx
-------------------------------------------------------------------------------// components/patch-tab.tsx

"use client"

import React from "react"
import { ColumnDef, SortingState, ColumnFiltersState, VisibilityState } from "@tanstack/react-table"
import { ArrowUpDown, MoreHorizontal } from "lucide-react"
import { DataTable } from '@/components/data-table'
import { Button } from "@/components/ui/button"
import { Badge } from "@/components/ui/badge"
import { Card, CardContent } from "@/components/ui/card"

// --- Type and Mock Data ---
type PatchStatus = "Installed" | "Required" | "Pending";
export type Patch = {
    id: string
    kbArticle: string
    description: string
    category: string
    status: PatchStatus
    installedOn: string | null
}

const mockPatches: Patch[] = [
    { id: "1", kbArticle: "KB501356", description: "Cumulative Update for Windows 10 Version 22H2", category: "Security Updates", status: "Installed", installedOn: "2023-10-10" },
    { id: "2", kbArticle: "KB5011323", description: ".NET Framework 3.5 and 4.8.1 Update", category: "Updates", status: "Installed", installedOn: "2023-10-10" },
    { id: "3", kbArticle: "KB5021289", description: "Cumulative Update for Windows 10 Version 22H2", category: "Security Updates", status: "Required", installedOn: null },
    { id: "4", kbArticle: "KB890830", description: "Windows Malicious Software Removal Tool", category: "Tools", status: "Pending", installedOn: null },
];

// --- Column Definitions ---
export const columns: ColumnDef<Patch>[] = [
    {
        accessorKey: "kbArticle",
        header: ({ column }) => (
            <Button variant="ghost" onClick={() => column.toggleSorting(column.getIsSorted() === "asc")}>
                KB Article <ArrowUpDown className="ml-2 h-4 w-4" />
            </Button>
        ),
    },
    {
        accessorKey: "description",
        header: "Description",
    },
    {
        accessorKey: "category",
        header: "Category",
    },
    {
        accessorKey: "status",
        header: "Status",
        cell: ({ row }) => {
            const status = row.getValue("status") as PatchStatus;

            if (status === "Installed") {
                // Green pill
                return (
                    <Badge
                        className="bg-emerald-600 text-white hover:bg-emerald-600/90"
                        variant="secondary"
                    >
                        Installed
                    </Badge>
                );
            }
            if (status === "Pending") {
                // Neutral gray pill
                return (
                    <Badge
                        className="bg-muted text-foreground/80 border border-border hover:bg-muted"
                        variant="outline"
                    >
                        Pending
                    </Badge>
                );
            }
            // Required -> red (destructive)
            return <Badge variant="destructive">Required</Badge>;
        },
    },
    {
        accessorKey: "installedOn",
        header: "Installed On",
    },
    {
        id: "actions",
        cell: () => (
            <Button variant="ghost" className="h-8 w-8 p-0">
                <span className="sr-only">Open menu</span>
                <MoreHorizontal className="h-4 w-4" />
            </Button>
        ),
    },
]

// --- Main Component ---
export default function PatchTab() {
    const [sorting, setSorting] = React.useState<SortingState>([])
    const [columnFilters, setColumnFilters] = React.useState<ColumnFiltersState>([])
    const [columnVisibility, setColumnVisibility] = React.useState<VisibilityState>({})

    return (
        <Card>
            <CardContent className="pt-6">
                <DataTable
                    columns={columns}
                    data={mockPatches}
                    sorting={sorting}
                    setSorting={setSorting}
                    columnFilters={columnFilters}
                    setColumnFilters={setColumnFilters}
                    columnVisibility={columnVisibility}
                    setColumnVisibility={setColumnVisibility}
                    filterColumn="description"
                    filterInputPlaceholder="Filter by description..."
                />
            </CardContent>
        </Card>
    )
}

============================== END FILE ========================================
============================= BEGIN FILE =======================================
Path: C:\Users\Last Stop\Documents\Programming Projects\RemoteIQ V5\remoteiq-frontend\components\remote-tab.tsx
Name: remote-tab.tsx
-------------------------------------------------------------------------------//components\remote-tab.tsx

"use client"

import React from 'react'
import { Card, CardContent, CardDescription, CardHeader, CardTitle } from '@/components/ui/card'
import { Button } from '@/components/ui/button'
import { Monitor, Terminal, FileText } from 'lucide-react'

const RemoteToolCard = ({ icon, title, description, actionText }: { icon: React.ElementType, title: string, description: string, actionText: string }) => {
    const Icon = icon
    return (
        <Card>
            <CardHeader className="flex flex-row items-center justify-between pb-2">
                <CardTitle className="text-base font-medium">{title}</CardTitle>
                <Icon className="h-6 w-6 text-muted-foreground" />
            </CardHeader>
            <CardContent>
                <p className="text-sm text-muted-foreground mb-4">{description}</p>
                <Button className="w-full">{actionText}</Button>
            </CardContent>
        </Card>
    )
}


export default function RemoteTab() {
    return (
        <div className="grid gap-6 md:grid-cols-2 lg:grid-cols-3">
            <RemoteToolCard
                icon={Monitor}
                title="Remote Desktop"
                description="Start an interactive remote desktop session. View and control the user's screen in real-time."
                actionText="Start Session"
            />
            <RemoteToolCard
                icon={Terminal}
                title="Remote Shell"
                description="Open a secure PowerShell or bash session directly on the endpoint for advanced command-line tasks."
                actionText="Open Shell"
            />
            <RemoteToolCard
                icon={FileText}
                title="File Browser"
                description="Securely browse, upload, and download files from the endpoint's filesystem."
                actionText="Browse Files"
            />
        </div>
    )
}

============================== END FILE ========================================
============================= BEGIN FILE =======================================
Path: C:\Users\Last Stop\Documents\Programming Projects\RemoteIQ V5\remoteiq-frontend\components\software-tab.tsx
Name: software-tab.tsx
-------------------------------------------------------------------------------// remoteiq-frontend/components/software-tab.tsx
"use client";

import * as React from "react";
import { useParams } from "next/navigation";
import {
    ColumnDef,
    SortingState,
    ColumnFiltersState,
    VisibilityState,
} from "@tanstack/react-table";
import { ArrowUpDown, MoreHorizontal, Trash2, Search } from "lucide-react";

import { DataTable } from "@/components/data-table";
import { Button } from "@/components/ui/button";
import { Card, CardContent } from "@/components/ui/card";
import {
    DropdownMenu,
    DropdownMenuTrigger,
    DropdownMenuContent,
    DropdownMenuItem,
    DropdownMenuSeparator,
    DropdownMenuLabel,
} from "@/components/ui/dropdown-menu";
import {
    AlertDialog,
    AlertDialogAction,
    AlertDialogCancel,
    AlertDialogContent,
    AlertDialogDescription,
    AlertDialogFooter,
    AlertDialogHeader,
    AlertDialogTitle,
    AlertDialogTrigger,
} from "@/components/ui/alert-dialog";
import { useToast } from "@/lib/toast";

import {
    fetchDeviceSoftware,
    requestUninstallSoftware,
    type DeviceSoftware,
} from "@/lib/api";

/** Same call shape used across the app (title/desc/kind) */
type ToastFn = (t: {
    title?: string;
    desc?: string;
    kind?: "default" | "destructive" | "success" | "warning";
}) => void;

type Props = { push?: ToastFn };

export default function SoftwareTab({ push }: Props) {
    // Back-compat: if parent didn't pass `push` yet, fall back to hook
    const hook = useToast();
    const doPush: ToastFn = push ?? hook.push;

    const params = useParams<{ deviceId: string }>();
    const deviceId = params?.deviceId;

    const [data, setData] = React.useState<DeviceSoftware[]>([]);
    const [loading, setLoading] = React.useState(false);
    const [error, setError] = React.useState<string | null>(null);

    const [sorting, setSorting] = React.useState<SortingState>([]);
    const [columnFilters, setColumnFilters] = React.useState<ColumnFiltersState>([]);
    const [columnVisibility, setColumnVisibility] = React.useState<VisibilityState>({});

    React.useEffect(() => {
        let alive = true;
        (async () => {
            if (!deviceId) return;
            setLoading(true);
            setError(null);
            try {
                const { items } = await fetchDeviceSoftware(deviceId);
                if (!alive) return;
                setData(items);
            } catch (e: any) {
                if (!alive) return;
                setError(e?.message ?? "Failed to load software list");
                doPush({
                    title: "Failed to load software",
                    desc: e?.message ?? "Request failed",
                    kind: "destructive",
                });
            } finally {
                if (alive) setLoading(false);
            }
        })();
        return () => {
            alive = false;
        };
    }, [deviceId, doPush]);

    const doSearchWeb = (name: string, version?: string | null) => {
        const q = encodeURIComponent([name, version].filter(Boolean).join(" "));
        window.open(
            `https://www.google.com/search?q=${q}`,
            "_blank",
            "noopener,noreferrer"
        );
    };

    const doUninstall = async (item: DeviceSoftware) => {
        if (!deviceId) return;
        try {
            const { jobId } = await requestUninstallSoftware(deviceId, {
                name: item.name,
                version: item.version || undefined,
            });
            doPush({
                title: "Uninstall requested",
                desc: `Job ${jobId} queued for ${item.name}.`,
                kind: "success",
            });
            // (optional) you could mark the row as "pending…" here
        } catch (e: any) {
            doPush({
                title: "Uninstall failed",
                desc: e?.message ?? "This device is offline. Ensure the agent is running and connected, then try again.",
                kind: "destructive",
            });
        }
    };

    const columns: ColumnDef<DeviceSoftware>[] = [
        {
            accessorKey: "name",
            header: ({ column }) => (
                <Button
                    variant="ghost"
                    onClick={() => column.toggleSorting(column.getIsSorted() === "asc")}
                >
                    Name <ArrowUpDown className="ml-2 h-4 w-4" />
                </Button>
            ),
        },
        { accessorKey: "version", header: "Version" },
        { accessorKey: "publisher", header: "Publisher" },
        { accessorKey: "installDate", header: "Install Date" },
        {
            id: "actions",
            cell: ({ row }) => {
                const item = row.original;
                return (
                    <AlertDialog>
                        <DropdownMenu>
                            <DropdownMenuTrigger asChild>
                                <Button variant="ghost" className="h-8 w-8 p-0" aria-label="Open menu">
                                    <MoreHorizontal className="h-4 w-4" />
                                </Button>
                            </DropdownMenuTrigger>
                            <DropdownMenuContent align="end">
                                <DropdownMenuLabel>Actions</DropdownMenuLabel>
                                <DropdownMenuItem
                                    onClick={async () => {
                                        await navigator.clipboard.writeText(item.name);
                                        doPush({ title: "Copied", desc: "Name copied to clipboard." });
                                    }}
                                >
                                    Copy name
                                </DropdownMenuItem>
                                <DropdownMenuItem
                                    onClick={async () => {
                                        await navigator.clipboard.writeText(item.version || "");
                                        doPush({
                                            title: "Copied",
                                            desc: "Version copied to clipboard.",
                                        });
                                    }}
                                >
                                    Copy version
                                </DropdownMenuItem>
                                <DropdownMenuSeparator />
                                <DropdownMenuItem onClick={() => doSearchWeb(item.name, item.version)}>
                                    <Search className="mr-2 h-4 w-4" />
                                    Search web
                                </DropdownMenuItem>
                                <DropdownMenuSeparator />
                                <AlertDialogTrigger asChild>
                                    <DropdownMenuItem className="text-red-600 focus:text-red-600">
                                        <Trash2 className="mr-2 h-4 w-4" />
                                        Uninstall…
                                    </DropdownMenuItem>
                                </AlertDialogTrigger>
                            </DropdownMenuContent>
                        </DropdownMenu>

                        {/* Confirm dialog */}
                        <AlertDialogContent>
                            <AlertDialogHeader>
                                <AlertDialogTitle>Uninstall “{item.name}”?</AlertDialogTitle>
                                <AlertDialogDescription>
                                    This will queue an uninstall job for the agent. The device may prompt
                                    the user and could require a reboot depending on the application.
                                </AlertDialogDescription>
                            </AlertDialogHeader>
                            <AlertDialogFooter>
                                <AlertDialogCancel>Cancel</AlertDialogCancel>
                                <AlertDialogAction onClick={() => doUninstall(item)}>
                                    Uninstall
                                </AlertDialogAction>
                            </AlertDialogFooter>
                        </AlertDialogContent>
                    </AlertDialog>
                );
            },
        },
    ];

    return (
        <Card>
            <CardContent className="pt-6">
                {loading && (
                    <div className="text-sm text-muted-foreground mb-3">Loading…</div>
                )}
                {error && <div className="text-sm text-red-600 mb-3">{error}</div>}
                <DataTable
                    columns={columns}
                    data={data}
                    sorting={sorting}
                    setSorting={setSorting}
                    columnFilters={columnFilters}
                    setColumnFilters={setColumnFilters}
                    columnVisibility={columnVisibility}
                    setColumnVisibility={setColumnVisibility}
                    filterColumn="name"
                    filterInputPlaceholder="Filter by name..."
                />
            </CardContent>
        </Card>
    );
}

============================== END FILE ========================================
============================= BEGIN FILE =======================================
Path: C:\Users\Last Stop\Documents\Programming Projects\RemoteIQ V5\remoteiq-frontend\lib\api.ts
Name: api.ts
-------------------------------------------------------------------------------// lib/api.ts
// Centralized typed API client used by the frontend (Next.js / React).
// It reads NEXT_PUBLIC_API_BASE for the backend base URL.

// ---------------------------- ENV / BASE ------------------------------------
const API_BASE =
  (typeof process !== "undefined" && process.env.NEXT_PUBLIC_API_BASE) || "";

// Utility to join base + path safely
function url(path: string) {
  if (!API_BASE) return path;
  return `${API_BASE.replace(/\/+$/, "")}${path.startsWith("/") ? "" : "/"}${path}`;
}

type JsonInit = Omit<RequestInit, "body" | "method"> & {
  body?: any;
  method?: "GET" | "POST" | "PUT" | "PATCH" | "DELETE";
};

// unified fetch wrapper w/ JSON
export async function jfetch<T>(path: string, init: JsonInit = {}): Promise<T> {
  const { body, ...rest } = init;
  const res = await fetch(url(path), {
    method: init.method ?? (body != null ? "POST" : "GET"),
    credentials: "include",
    headers: {
      "Content-Type": "application/json",
      ...(init.headers ?? {}),
    },
    body: body != null ? JSON.stringify(body) : undefined,
    ...rest,
  });

  if (!res.ok) {
    // try to surface JSON message; fall back to text
    let msg = "";
    try {
      const data = await res.json();
      msg = typeof (data as any)?.message === "string" ? (data as any).message : JSON.stringify(data);
    } catch {
      try {
        msg = await res.text();
      } catch {
        // ignore
      }
    }
    const err = new Error(msg || `Request failed: ${res.status}`);
    (err as any).status = res.status; // preserve status for caller fallbacks
    throw err;
  }

  if (res.status === 204) return undefined as unknown as T;
  try {
    return (await res.json()) as T;
  } catch {
    // when backend returns 200 with empty body
    return undefined as unknown as T;
  }
}

// ---------------------------------------------------------------------------
// Devices (grid + details)
// ---------------------------------------------------------------------------
// lib/api.ts  (only showing the Device type block; keep the rest as-is)
export type Device = {
  id: string;
  hostname: string;
  os: string;
  arch?: string | null;
  lastSeen?: string | null;
  status: "online" | "offline";
  client?: string | null;
  site?: string | null;
  user?: string | string[] | null;
  version?: string | null;      // <-- add
  primaryIp?: string | null;    // <-- add
};



export type DevicesResponse = {
  items: Device[];
  nextCursor: string | null;
};

export type DeviceFilters = {
  q?: string;
  status?: "online" | "offline";
  os?: string[];
};

export async function fetchDevices(
  pageSize = 25,
  cursor: string | null = null,
  filters?: DeviceFilters
): Promise<DevicesResponse> {
  const sp = new URLSearchParams();
  sp.set("pageSize", String(pageSize));
  if (cursor) sp.set("cursor", cursor);
  if (filters?.q) sp.set("q", filters.q);
  if (filters?.status) sp.set("status", filters.status);
  (filters?.os ?? []).forEach((o) => sp.append("os", o));
  return await jfetch<DevicesResponse>(`/api/devices?${sp.toString()}`);
}

export async function fetchDevice(id: string): Promise<Device> {
  return await jfetch<Device>(`/api/devices/${encodeURIComponent(id)}`);
}

// ---------------------------------------------------------------------------
// Device insights (checks / software)
// ---------------------------------------------------------------------------
export type DeviceCheck = {
  id: string;
  name: string;
  status: "Passing" | "Warning" | "Failing";
  lastRun: string;
  output: string;
};

export async function fetchDeviceChecks(deviceId: string): Promise<{ items: DeviceCheck[] }> {
  return await jfetch(`/api/devices/${encodeURIComponent(deviceId)}/checks`);
}

export type DeviceSoftware = {
  id: string;
  name: string;
  version: string;
  publisher?: string | null;
  installDate?: string | null;
};

export async function fetchDeviceSoftware(deviceId: string): Promise<{ items: DeviceSoftware[] }> {
  return await jfetch(`/api/devices/${encodeURIComponent(deviceId)}/software`);
}

// ---------------------------------------------------------------------------
// Device actions
// ---------------------------------------------------------------------------
export async function rebootDevice(id: string): Promise<{ accepted: true; jobId: string }> {
  return await jfetch(`/api/devices/${encodeURIComponent(id)}/actions/reboot`, { method: "POST" });
}
export async function patchDevice(id: string): Promise<{ accepted: true; jobId: string }> {
  return await jfetch(`/api/devices/${encodeURIComponent(id)}/actions/patch`, { method: "POST" });
}

// ---------------------------------------------------------------------------
// Automation / Runs
// ---------------------------------------------------------------------------
export type RunScriptRequest = {
  deviceId: string;
  script: string;
  shell?: "powershell" | "bash" | "cmd";
  timeoutSec?: number;
};

export async function postRunScript(req: RunScriptRequest): Promise<{ jobId: string }> {
  return await jfetch(`/api/automation/runs`, { method: "POST", body: req });
}

export type JobSnapshot = {
  jobId: string;
  deviceId: string;
  status: "queued" | "running" | "succeeded" | "failed" | "canceled";
  log: string;
  exitCode?: number | null;
  startedAt: number;
  finishedAt?: number | null;
};

export async function fetchJob(jobId: string): Promise<JobSnapshot> {
  return await jfetch(`/api/automation/runs/${encodeURIComponent(jobId)}`);
}
export async function fetchJobLog(jobId: string): Promise<{ jobId: string; log: string }> {
  return await jfetch(`/api/automation/runs/${encodeURIComponent(jobId)}/log`);
}

// ---------------------------------------------------------------------------
// Admin → Database configuration
// ---------------------------------------------------------------------------
export type DbEngine = "postgresql" | "mysql" | "mssql" | "sqlite" | "mongodb";
export type DbAuthMode = "fields" | "url";
export type StorageDomain =
  | "users" | "roles" | "sessions" | "audit_logs" | "devices" | "policies" | "email_queue";

export type DatabaseMappings = Record<StorageDomain, string>;

export type DatabaseConfig = {
  enabled: boolean;
  engine: DbEngine;
  authMode: DbAuthMode;
  url?: string;
  host?: string;
  port?: number;
  dbName?: string;
  username?: string;
  password?: string;
  ssl: boolean;
  poolMin: number;
  poolMax: number;
  readReplicas?: string;
  mappings: DatabaseMappings;
};

export type DbTestResult = {
  ok: boolean;
  engine: DbEngine;
  primary: { ok: boolean; message?: string };
  replicas?: Array<{ url: string; ok: boolean; message?: string }>;
  note?: string;
};

export async function getDatabaseConfig(): Promise<DatabaseConfig | { enabled: false }> {
  return await jfetch(`/api/admin/database`);
}

export async function testDatabaseConfig(cfg: DatabaseConfig): Promise<DbTestResult> {
  return await jfetch(`/api/admin/database/test`, { method: "POST", body: cfg });
}

export async function saveDatabaseConfig(cfg: DatabaseConfig): Promise<void> {
  await jfetch<void>(`/api/admin/database/save`, { method: "POST", body: cfg });
}

export async function dryRunDatabaseMigration(): Promise<{ ok: true; destructive: false; steps: string[] }> {
  return await jfetch(`/api/admin/database/migrate/dry-run`, { method: "POST" });
}

// --- Company profile (admin) ---
export type CompanyProfile = {
  name: string;
  legalName?: string;
  email?: string;
  phone?: string;
  fax?: string;
  website?: string;
  vatTin?: string;
  address1?: string;
  address2?: string;
  city?: string;
  state?: string;
  postal?: string;
  country?: string;
};

export async function getCompanyProfile(): Promise<CompanyProfile> {
  return await jfetch(`/api/admin/company`);
}

export async function saveCompanyProfile(p: CompanyProfile): Promise<void> {
  await jfetch(`/api/admin/company/save`, { method: "POST", body: p });
}

// --- Localization (admin) ---
export type LocalizationSettings = {
  language: string;                // "en-US"
  dateFormat: string;              // "MM/DD/YYYY"
  timeFormat: "12h" | "24h";       // strictly 12h/24h for UI consistency
  numberFormat: string;            // "1,234.56"
  timeZone: string;                // "America/New_York"
  firstDayOfWeek: "sunday" | "monday";
  currency?: string;               // "USD"
};

export async function getLocalizationSettings(): Promise<LocalizationSettings> {
  const res = await jfetch<LocalizationSettings | { exists: false }>(`/api/admin/localization`);
  if ((res as any)?.exists === false) {
    return {
      language: "en-US",
      dateFormat: "MM/DD/YYYY",
      timeFormat: "12h",
      numberFormat: "1,234.56",
      timeZone: "America/New_York",
      firstDayOfWeek: "sunday",
      currency: "USD",
    };
  }
  // Back-compat: normalize any legacy strings to the union
  const tfRaw = (res as any).timeFormat as string | undefined;
  const timeFormat: "12h" | "24h" = tfRaw === "24h" || tfRaw === "HH:mm" ? "24h" : "12h";
  return { ...(res as LocalizationSettings), timeFormat };
}

export async function saveLocalizationSettings(p: LocalizationSettings): Promise<void> {
  await jfetch(`/api/admin/localization/save`, { method: "POST", body: p });
}

// --- Support & Legal (admin) ---
export type SupportLegalSettings = {
  id?: number;                 // present on GET only
  supportEmail?: string;
  supportPhone?: string;
  knowledgeBaseUrl?: string;
  statusPageUrl?: string;
  privacyPolicyUrl?: string;
  termsUrl?: string;
  gdprContactEmail?: string;
  legalAddress?: string;
  ticketPortalUrl?: string;
  phoneHours?: string;
  notesHtml?: string;
};

export async function getSupportLegalSettings(): Promise<SupportLegalSettings> {
  return await jfetch(`/api/admin/support-legal`);
}

export async function saveSupportLegalSettings(
  p: Omit<SupportLegalSettings, "id">
): Promise<void> {
  await jfetch(`/api/admin/support-legal/save`, { method: "POST", body: p });
}

// ======================= Users & Roles (Admin) =======================
export type RoleDTO = { id: string; name: string };
export type UserDTO = {
  id: string;
  name: string;
  email: string;
  role: string;
  twoFactorEnabled: boolean;
  suspended: boolean;
  lastSeen: string | null;
  status: "active" | "invited" | "suspended";
  createdAt?: string;
  updatedAt?: string;

  // Optional profile fields (present if your DB exposes them)
  phone?: string | null;
  address1?: string | null;
  address2?: string | null;
  city?: string | null;
  state?: string | null;
  postal?: string | null;
  country?: string | null;
};

export async function getAdminRoles(): Promise<{ items: RoleDTO[] }> {
  // Wrap server response (array) into {items} for consistency
  const arr = await jfetch<RoleDTO[]>(`/api/admin/users/roles`);
  return { items: arr };
}

export async function getAdminUsers(): Promise<{ items: UserDTO[]; total?: number }> {
  // backend returns {items, total}
  return await jfetch(`/api/admin/users`);
}

export type InvitePayload = { name?: string; email: string; role?: string; message?: string };

/** Invite one-by-one under the hood to keep types simple */
export async function inviteUsers(invites: InvitePayload[]): Promise<{ created: UserDTO[] }> {
  const created: UserDTO[] = [];
  for (const i of invites) {
    const resp = await jfetch<{ id: string }>(`/api/admin/users/invite`, {
      method: "POST",
      body: i,
    });
    created.push({
      id: resp.id,
      name: i.name ?? i.email.split("@")[0],
      email: i.email,
      role: i.role ?? "User",
      status: "invited",
      twoFactorEnabled: false,
      suspended: false,
      lastSeen: null,
    });
  }
  return { created };
}

/** Change a user's role */
export async function updateUserRole(userId: string, role: string): Promise<void> {
  await jfetch<void>(`/api/admin/users/${encodeURIComponent(userId)}/role`, {
    method: "PATCH",
    body: { role },
  });
}

/** Trigger a 2FA reset */
export async function resetUser2FA(userId: string): Promise<void> {
  await jfetch<void>(`/api/admin/users/${encodeURIComponent(userId)}/reset-2fa`, {
    method: "POST",
  });
}

/** Remove (delete) a user */
export async function removeUser(userId: string): Promise<void> {
  await jfetch<void>(`/api/admin/users/${encodeURIComponent(userId)}`, {
    method: "DELETE",
  });
}

/** Suspend / Unsuspend user */
export async function setUserSuspended(userId: string, suspended: boolean): Promise<void> {
  await jfetch<void>(`/api/admin/users/${encodeURIComponent(userId)}/suspend`, {
    method: "POST",
    body: { suspended },
  });
}

/* -------- Admin create + reset password -------- */
export type CreateUserPayload = {
  name: string;
  email: string;
  role?: string;
  password: string;
  status?: "active" | "invited" | "suspended";
};

export async function createAdminUser(p: CreateUserPayload): Promise<{ id: string }> {
  return await jfetch(`/api/admin/users/create`, { method: "POST", body: p });
}

export async function setUserPassword(userId: string, password: string): Promise<void> {
  await jfetch(`/api/admin/users/${encodeURIComponent(userId)}/password`, {
    method: "POST",
    body: { password },
  });
}

/* -------- NEW: Update user details (partial) -------- */
export type UpdateUserPayload = Partial<{
  name: string;
  email: string;
  role: string;
  phone: string;
  address1: string;
  address2: string;
  city: string;
  state: string;
  postal: string;
  country: string;
}>;

export async function updateUser(userId: string, p: UpdateUserPayload): Promise<void> {
  await jfetch<void>(`/api/admin/users/${encodeURIComponent(userId)}`, {
    method: "PATCH",
    body: p,
  });
}

// ---------------------------------------------------------------------------
// Account (current user) - Profile
// ---------------------------------------------------------------------------
export type MeProfile = {
  id: string;
  name: string;
  email: string;
  username?: string;
  phone?: string | null;
  address1?: string | null;
  address2?: string | null;
  city?: string | null;
  state?: string | null;
  postal?: string | null;
  country?: string | null;
  timezone?: string | null;
  locale?: string | null;
  avatarUrl?: string | null; // backend may store as avatar_url; mapped server-side
  createdAt?: string;
  updatedAt?: string;
};

export type UpdateMePayload = Partial<{
  name: string;
  email: string;
  username: string;
  phone: string | null;
  address1: string | null;
  address2: string | null;
  city: string | null;
  state: string | null;
  postal: string | null;
  country: string | null;
  timezone: string | null;
  locale: string | null;
  avatarUrl: string | null;
}>;

/** Load the signed-in user's profile */
export async function getMyProfile(): Promise<MeProfile> {
  return await jfetch<MeProfile>(`/api/users/me`);
}

/** Patch the signed-in user's profile (only sends provided keys) */
export async function updateMyProfile(patch: UpdateMePayload): Promise<MeProfile> {
  const body = Object.fromEntries(Object.entries(patch).filter(([, v]) => v !== undefined));
  return await jfetch<MeProfile>(`/api/users/me`, { method: "PATCH", body });
}

// ---------------------------------------------------------------------------
// Account (current user) - Security & Sessions (legacy helpers kept)
// ---------------------------------------------------------------------------
export type SecuritySettings = {
  twoFaEnabled: boolean;
  autoRevokeSessions?: boolean;
};

export async function getSecuritySettings(): Promise<SecuritySettings> {
  return await jfetch(`/api/users/security`);
}
export async function saveSecuritySettings(p: Partial<SecuritySettings>): Promise<void> {
  await jfetch(`/api/users/security`, { method: "PATCH", body: p });
}

export type SessionDTO = {
  id: string;
  device: string;
  ip: string;
  lastActive: string;
  current: boolean;
  city?: string;
  isp?: string;
  trusted?: boolean;
};

export async function listSessions(): Promise<{ items: SessionDTO[] }> {
  return await jfetch(`/api/users/sessions`);
}
export async function toggleTrustSession(sessionId: string, trusted: boolean): Promise<void> {
  await jfetch(`/api/users/sessions/${encodeURIComponent(sessionId)}/trust`, {
    method: "POST",
    body: { trusted },
  });
}
export async function revokeSession(sessionId: string): Promise<void> {
  await jfetch(`/api/users/sessions/${encodeURIComponent(sessionId)}`, { method: "DELETE" });
}
export async function revokeAllSessions(): Promise<void> {
  await jfetch(`/api/users/sessions`, { method: "DELETE" });
}

// ---------------------------------------------------------------------------
// Account (current user) - Notifications
// ---------------------------------------------------------------------------
export type NotificationSettings = {
  email: boolean;
  push: boolean;
  product: boolean;
  digest: "off" | "daily" | "weekly";
  quiet?: { enabled: boolean; start?: string; end?: string };
  products?: string[];
};

export async function getNotificationSettings(): Promise<NotificationSettings> {
  return await jfetch(`/api/users/notifications`);
}
export async function saveNotificationSettings(p: Partial<NotificationSettings>): Promise<void> {
  await jfetch(`/api/users/notifications`, { method: "PATCH", body: p });
}

// ---------------------------------------------------------------------------
// Account (current user) - Integrations (Slack + generic webhook)
// ---------------------------------------------------------------------------
export type IntegrationsSettings = {
  slackWebhook?: string;
  webhookUrl?: string;
  webhookSigningSecret?: string;
  events?: string[];
};

export async function getIntegrationsSettings(): Promise<IntegrationsSettings> {
  return await jfetch(`/api/users/integrations`);
}
export async function saveIntegrationsSettings(p: Partial<IntegrationsSettings>): Promise<void> {
  await jfetch(`/api/users/integrations`, { method: "PATCH", body: p });
}

export async function testSlackWebhook(urlStr: string): Promise<{ ok: boolean; status: number; ms?: number }> {
  return await jfetch(`/api/users/integrations/test/slack`, { method: "POST", body: { url: urlStr } });
}
export async function testGenericWebhook(urlStr: string): Promise<{ ok: boolean; status: number; ms?: number }> {
  return await jfetch(`/api/users/integrations/test/webhook`, { method: "POST", body: { url: urlStr } });
}
export async function rotateSigningSecret(): Promise<{ secret: string }> {
  return await jfetch(`/api/users/integrations/rotate-signing-secret`, { method: "POST" });
}

// ---------------------------------------------------------------------------
// Account (current user) - API Keys
// ---------------------------------------------------------------------------
export type ApiKeyDTO = {
  id: string;          // token id (e.g., "rk_live_xxx")
  label: string;
  lastUsed?: string;
  scopes?: string[];
  expiresAt?: string;  // iso or empty string if never
};

export async function listApiKeys(): Promise<{ items: ApiKeyDTO[] }> {
  const arr = await jfetch<ApiKeyDTO[]>(`/api/users/api-keys`);
  return { items: arr };
}

export async function createApiKey(
  label: string,
  scopes: string[],
  expiresIn: "never" | "30d" | "90d",
  ipAllowlist?: string
): Promise<ApiKeyDTO> {
  return await jfetch(`/api/users/api-keys`, {
    method: "POST",
    body: { label, scopes, expiresIn, ipAllowlist },
  });
}

export async function revokeApiKey(id: string): Promise<void> {
  await jfetch(`/api/users/api-keys/${encodeURIComponent(id)}`, { method: "DELETE" });
}

export async function regenerateApiKey(id: string): Promise<{ oldId: string; newKey: string }> {
  return await jfetch(`/api/users/api-keys/${encodeURIComponent(id)}/regenerate`, { method: "POST" });
}

// Upload avatar to the dedicated endpoint
export async function uploadMyAvatar(file: File): Promise<{ url: string }> {
  const form = new FormData();
  form.append("file", file, file.name || "avatar.png");

  const base = (typeof process !== "undefined" && process.env.NEXT_PUBLIC_API_BASE) || "";
  const res = await fetch(`${base.replace(/\/+$/, "")}/api/users/me/avatar`, {
    method: "POST",
    credentials: "include",
    body: form,
  });
  if (!res.ok) {
    let msg = "";
    try { msg = (await res.json())?.message || ""; } catch { }
    if (!msg) try { msg = await res.text(); } catch { }
    throw new Error(msg || `Upload failed (${res.status})`);
  }
  return (await res.json()) as { url: string };
}

export async function removeMyAvatar(): Promise<void> {
  await jfetch<void>(`/api/users/me/avatar`, { method: "DELETE" });
}

/* ============================================================================
   NEW: Security Overview + TOTP + Sessions (ME scope) + PAT + WebAuthn stubs
   ==========================================================================*/

// ---- Types used by the Security tab ----
export type SecurityEvent = {
  id: string;
  type:
  | "signed_in"
  | "password_changed"
  | "2fa_enabled"
  | "2fa_disabled"
  | "recovery_codes_regenerated"
  | "session_revoked";
  at: string;
  ip?: string;
  userAgent?: string;
};

export type WebAuthnCredential = {
  id: string;
  label: string;
  createdAt: string;
  lastUsedAt?: string;
};

export type RecoveryCodes = string[];

// ---- Sessions (ME) ----
export type Session = {
  id: string;
  createdAt: string;
  lastSeenAt: string | null;
  ip: string | null;
  userAgent: string | null;
  current: boolean;
  trusted?: boolean;
  label?: string | null;
  revokedAt?: string | null; // <-- include so we can filter locally
};

export type SecurityOverview = {
  twoFactorEnabled: boolean;
  sessions: Session[];
  events: SecurityEvent[];
  webAuthn?: WebAuthnCredential[];
};

export type TOTPInit = { secret: string; otpauthUrl: string; qrPngDataUrl: string };

// ---- Overview ----
export async function getSecurityOverview(): Promise<SecurityOverview> {
  return await jfetch<SecurityOverview>(`/api/users/me/security`);
}

// ---- Change Password ----
export async function changePasswordSelf(current: string, next: string): Promise<void> {
  await jfetch(`/api/users/me/password`, { method: "POST", body: { current, next } });
}

// ---- TOTP 2FA ----
export async function start2FA(): Promise<TOTPInit> {
  return await jfetch<TOTPInit>(`/api/users/me/2fa/start`, { method: "POST" });
}

export async function confirm2FA(p: { code: string }): Promise<void> {
  await jfetch(`/api/users/me/2fa/confirm`, { method: "POST", body: p });
}

export async function disable2FA(p?: { code?: string; recoveryCode?: string }): Promise<void> {
  await jfetch(`/api/users/me/2fa/disable`, { method: "POST", body: p ?? {} });
}

export async function regenerateRecoveryCodes(): Promise<RecoveryCodes> {
  const res = await jfetch<{ recoveryCodes: string[] }>(`/api/users/me/2fa/recovery/regen`, {
    method: "POST",
  });
  return res.recoveryCodes;
}

// ---- Sessions (ME) ----
// NOTE: some servers include revoked sessions in the list; we filter them out.
export async function listMySessions(): Promise<{ items: Session[]; currentJti?: string }> {
  const res = await jfetch<{ items: Session[]; currentJti?: string }>(`/api/users/me/sessions/`);
  const items = (res.items ?? []).filter((s) => !s.revokedAt); // <-- hide revoked
  return { items, currentJti: res.currentJti };
}

export async function revokeAllOtherSessions(): Promise<void> {
  await jfetch(`/api/users/me/sessions/revoke-all`, { method: "POST" });
}

/**
 * Revoke a single session (ME).
 * Tries a sequence of plausible endpoints so we work with whatever the backend exposes.
 */
export async function revokeMySession(sessionId: string): Promise<void> {
  const enc = encodeURIComponent(sessionId);
  const base = `/api/users/me/sessions/${enc}`;

  // 1) Preferred: DELETE /me/sessions/:id
  try {
    await jfetch(base, { method: "DELETE" });
    return;
  } catch (e: any) {
    const msg = String(e?.message || "").toLowerCase();
    const status = e?.status ?? e?.code;
    if (!(status === 404 || status === 405 || msg.includes("cannot delete"))) throw e;
  }

  // 2) Alt: POST /me/sessions/:id/revoke
  try {
    await jfetch(`${base}/revoke`, { method: "POST" });
    return;
  } catch (e: any) {
    const status = e?.status ?? e?.code;
    if (!(status === 404 || status === 405)) throw e;
  }

  // 3) Alt: POST /me/sessions/revoke  { sessionId }
  try {
    await jfetch(`/api/users/me/sessions/revoke`, { method: "POST", body: { sessionId } });
    return;
  } catch (e: any) {
    const status = e?.status ?? e?.code;
    if (!(status === 404 || status === 405)) throw e;
  }

  // 4) Alt: POST /me/sessions/revoke/:id
  try {
    await jfetch(`/api/users/me/sessions/revoke/${enc}`, { method: "POST" });
    return;
  } catch (e: any) {
    const status = e?.status ?? e?.code;
    if (!(status === 404 || status === 405)) throw e;
  }

  // 5) Last-resort: PATCH /me/sessions/:id { action: "revoke" }
  await jfetch(base, { method: "PATCH", body: { action: "revoke" } });
}

/** Trust / untrust a session (ME) with fallbacks similar to revoke */
export async function trustMySession(
  sessionId: string,
  trusted: boolean
): Promise<{ trusted: boolean }> {
  const enc = encodeURIComponent(sessionId);
  const base = `/api/users/me/sessions/${enc}`;

  // 1) Preferred: POST /me/sessions/:id/trust { trusted }
  try {
    return await jfetch(`${base}/trust`, { method: "POST", body: { trusted } });
  } catch (e: any) {
    const status = e?.status ?? e?.code;
    if (!(status === 404 || status === 405)) throw e;
  }

  // 2) Alt: POST /me/sessions/trust { sessionId, trusted }
  try {
    return await jfetch(`/api/users/me/sessions/trust`, {
      method: "POST",
      body: { sessionId, trusted },
    });
  } catch (e: any) {
    const status = e?.status ?? e?.code;
    if (!(status === 404 || status === 405)) throw e;
  }

  // 3) Last-resort: PATCH /me/sessions/:id { trusted }
  return await jfetch(base, { method: "PATCH", body: { trusted } });
}

/** Optional: label a session (ME) */
export async function labelMySession(sessionId: string, label: string): Promise<void> {
  await jfetch(`/api/users/me/sessions/${encodeURIComponent(sessionId)}/label`, {
    method: "POST",
    body: { label },
  });
}

// lib/api.ts → mapMeSessionToDTO
export function mapMeSessionToDTO(s: Session): SessionDTO {
  return {
    id: s.id,
    device: s.label || s.userAgent || "Unknown device",
    ip: s.ip ?? "",                 // string (never undefined)
    lastActive: s.lastSeenAt ?? "", // string (never undefined)
    current: !!s.current,           // boolean
    city: undefined,
    isp: undefined,
    trusted: s.trusted ?? false,
  };
}


// ---- Personal Tokens (ME) ----
export type PersonalToken = {
  id: string;
  name: string;
  createdAt: string;
  lastUsedAt?: string;
  revokedAt?: string;
};

export async function listMyTokens(): Promise<{ items: PersonalToken[] }> {
  return await jfetch(`/api/users/me/tokens`);
}

export async function createMyToken(name: string): Promise<{ token: string; id: string }> {
  return await jfetch(`/api/users/me/tokens`, { method: "POST", body: { name } });
}

export async function revokeMyToken(id: string): Promise<void> {
  await jfetch(`/api/users/me/tokens/revoke`, { method: "POST", body: { id } });
}

// ---- WebAuthn (optional / stubbed) ----
export async function webauthnCreateOptions(): Promise<PublicKeyCredentialCreationOptions> {
  return await jfetch(`/api/users/me/webauthn/create-options`);
}

export async function webauthnFinishRegistration(attestationResponse: any): Promise<WebAuthnCredential> {
  return await jfetch(`/api/users/me/webauthn/finish`, { method: "POST", body: attestationResponse });
}

export async function deleteWebAuthnCredential(id: string): Promise<void> {
  await jfetch(`/api/users/me/webauthn/${encodeURIComponent(id)}`, { method: "DELETE" });
}

// --- Device software: request uninstall --------------------------------
export async function requestUninstallSoftware(
  deviceId: string,
  body: { name: string; version?: string }
): Promise<{ accepted: true; jobId?: string }> {
  const res = await fetch(
    `${((typeof process !== "undefined" && process.env.NEXT_PUBLIC_API_BASE) || "").replace(/\/+$/, "")}/api/devices/${encodeURIComponent(deviceId)}/actions/uninstall`,
    {
      method: "POST",
      credentials: "include",
      headers: { "Content-Type": "application/json" },
      body: JSON.stringify(body),
    }
  );

  if (!res.ok) {
    // surface error text
    let msg = "";
    try { msg = (await res.clone().json())?.message || ""; } catch { }
    if (!msg) try { msg = await res.text(); } catch { }
    throw new Error(msg || `Request failed: ${res.status}`);
  }

  // Try JSON first
  let jobId: string | undefined;
  try {
    const json = await res.clone().json();
    jobId = json?.jobId;
  } catch {
    /* no json body */
  }

  // Fallback: parse Location header (e.g. /api/automation/runs/<uuid>)
  if (!jobId) {
    const loc = res.headers.get("Location") || res.headers.get("location");
    const m = loc?.match(/([0-9a-fA-F-]{8}-[0-9a-fA-F-]{4}-[1-5][0-9a-fA-F-]{3}-[89abAB][0-9a-fA-F-]{3}-[0-9a-fA-F-]{12})$/);
    if (m) jobId = m[1];
  }

  return { accepted: true, jobId };
}

============================== END FILE ========================================
============================= BEGIN FILE =======================================
Path: C:\Users\Last Stop\Documents\Programming Projects\RemoteIQ V5\remoteiq-frontend\lib\use-job-run.ts
Name: use-job-run.ts
-------------------------------------------------------------------------------// lib/use-job-run.ts
"use client";

import * as React from "react";
import { onWsMessage, ensureSocket } from "./ws";
import { postRunScript, type RunScriptRequest } from "./api";

export type JobStatus = "queued" | "running" | "succeeded" | "failed" | "canceled";

export type JobUpdate = {
    type: "job.run.updated";
    jobId: string;
    status: JobStatus;
    progress?: number;       // 0..100
    chunk?: string;          // log delta
    exitCode?: number | null;
    finishedAt?: string | null;
};

export function useJobRun() {
    const [jobId, setJobId] = React.useState<string | null>(null);
    const [status, setStatus] = React.useState<JobStatus | null>(null);
    const [log, setLog] = React.useState<string>("");
    const [progress, setProgress] = React.useState<number>(0);
    const [error, setError] = React.useState<string | null>(null);
    const [subscribed, setSubscribed] = React.useState(false);

    // Subscribe to WS updates for the active jobId
    React.useEffect(() => {
        ensureSocket();
        const unsubscribe = onWsMessage((msg: any) => {
            if (msg?.type !== "job.run.updated") return;
            const data = msg as JobUpdate;
            if (!jobId || data.jobId !== jobId) return;

            setStatus(data.status);
            if (typeof data.progress === "number") setProgress(data.progress);
            if (data.chunk) setLog((prev) => prev + data.chunk);
            if (data.status === "failed") {
                setError(`Run failed${data.exitCode != null ? ` (exit ${data.exitCode})` : ""}`);
            }
        });
        setSubscribed(true);

        // Ensure cleanup returns void (not boolean)
        return () => {
            if (typeof unsubscribe === "function") {
                // swallow any return value to satisfy React types
                void unsubscribe();
            }
        };
    }, [jobId]);

    const start = React.useCallback(async (req: RunScriptRequest) => {
        setError(null);
        setLog("");
        setProgress(0);
        setStatus("queued");
        const res = await postRunScript(req);
        setJobId(res.jobId);
        return res.jobId;
    }, []);

    return {
        jobId,
        status,
        log,
        progress,
        error,
        subscribed,
        start,
    };
}

============================== END FILE ========================================
============================= BEGIN FILE =======================================
Path: C:\Users\Last Stop\Documents\Programming Projects\RemoteIQ V5\remoteiq-frontend\lib\ws.ts
Name: ws.ts
-------------------------------------------------------------------------------// lib/ws.ts
type Listener = (msg: any) => void;

let socket: WebSocket | null = null;
const listeners = new Set<Listener>();

export function ensureSocket(): WebSocket {
  const base = process.env.NEXT_PUBLIC_WS_BASE || "ws://localhost:3001/ws";
  if (socket && (socket.readyState === WebSocket.OPEN || socket.readyState === WebSocket.CONNECTING)) {
    return socket;
  }
  socket = new WebSocket(base);
  socket.onmessage = (ev) => {
    try {
      const data = JSON.parse(ev.data);
      for (const cb of Array.from(listeners)) cb(data);
    } catch {
      // ignore malformed frames
    }
  };
  return socket;
}

export function onWsMessage(cb: Listener) {
  listeners.add(cb);
  return () => listeners.delete(cb);
}

============================== END FILE ========================================
============================= BEGIN FILE =======================================
Path: C:\Users\Last Stop\Documents\Programming Projects\RemoteIQ V5\remoteiq-frontend\node_modules\.pnpm\zod@4.1.12\node_modules\zod\src\v4\core\api.ts
Name: api.ts
-------------------------------------------------------------------------------import * as checks from "./checks.js";
import type * as core from "./core.js";
import type * as errors from "./errors.js";
import * as schemas from "./schemas.js";
import * as util from "./util.js";

export type Params<
  T extends schemas.$ZodType | checks.$ZodCheck,
  IssueTypes extends errors.$ZodIssueBase,
  OmitKeys extends keyof T["_zod"]["def"] = never,
> = util.Flatten<
  Partial<
    util.EmptyToNever<
      Omit<T["_zod"]["def"], OmitKeys> &
        ([IssueTypes] extends [never]
          ? {} // unknown
          : {
              error?: string | errors.$ZodErrorMap<IssueTypes> | undefined;
              /** @deprecated This parameter is deprecated. Use `error` instead. */
              message?: string | undefined; // supported in Zod 3
            })
    >
  >
>;

export type TypeParams<
  T extends schemas.$ZodType = schemas.$ZodType & { _isst: never },
  AlsoOmit extends Exclude<keyof T["_zod"]["def"], "type" | "checks" | "error"> = never,
> = Params<T, NonNullable<T["_zod"]["isst"]>, "type" | "checks" | "error" | AlsoOmit>;

// strips types that are not exposed in the public factory
// incl. `error`, `check`
export type CheckParams<
  T extends checks.$ZodCheck = checks.$ZodCheck, // & { _issc: never },
  AlsoOmit extends Exclude<keyof T["_zod"]["def"], "check" | "error"> = never,
> = Params<T, NonNullable<T["_zod"]["issc"]>, "check" | "error" | AlsoOmit>;

// strips types that are not exposed in the public factory
// incl. `type`, `checks`, `error`, `check`, `format`
export type StringFormatParams<
  T extends schemas.$ZodStringFormat = schemas.$ZodStringFormat,
  AlsoOmit extends Exclude<keyof T["_zod"]["def"], "type" | "coerce" | "checks" | "error" | "check" | "format"> = never,
> = Params<
  T,
  NonNullable<T["_zod"]["isst"] | T["_zod"]["issc"]>,
  "type" | "coerce" | "checks" | "error" | "check" | "format" | AlsoOmit
>;

export type CheckStringFormatParams<
  T extends schemas.$ZodStringFormat = schemas.$ZodStringFormat,
  AlsoOmit extends Exclude<keyof T["_zod"]["def"], "type" | "coerce" | "checks" | "error" | "check" | "format"> = never,
> = Params<T, NonNullable<T["_zod"]["issc"]>, "type" | "coerce" | "checks" | "error" | "check" | "format" | AlsoOmit>;

export type CheckTypeParams<
  T extends schemas.$ZodType & checks.$ZodCheck = schemas.$ZodType & checks.$ZodCheck,
  AlsoOmit extends Exclude<keyof T["_zod"]["def"], "type" | "checks" | "error" | "check"> = never,
> = Params<T, NonNullable<T["_zod"]["isst"] | T["_zod"]["issc"]>, "type" | "checks" | "error" | "check" | AlsoOmit>;

// String
export type $ZodStringParams = TypeParams<schemas.$ZodString<string>, "coerce">;
export function _string<T extends schemas.$ZodString>(
  Class: util.SchemaClass<T>,
  params?: string | $ZodStringParams
): T {
  return new Class({
    type: "string",
    ...util.normalizeParams(params),
  });
}

export function _coercedString<T extends schemas.$ZodString>(
  Class: util.SchemaClass<T>,
  params?: string | $ZodStringParams
): T {
  return new Class({
    type: "string",
    coerce: true,
    ...util.normalizeParams(params),
  });
}

export type $ZodStringFormatParams = CheckTypeParams<
  schemas.$ZodStringFormat,
  "format" | "coerce" | "when" | "pattern"
>;
export type $ZodCheckStringFormatParams = CheckParams<checks.$ZodCheckStringFormat, "format">;
// custom format

// Email
export type $ZodEmailParams = StringFormatParams<schemas.$ZodEmail, "when">;
export type $ZodCheckEmailParams = CheckStringFormatParams<schemas.$ZodEmail, "when">;
export function _email<T extends schemas.$ZodEmail>(
  Class: util.SchemaClass<T>,
  params?: string | $ZodEmailParams | $ZodCheckEmailParams
): T {
  return new Class({
    type: "string",
    format: "email",
    check: "string_format",
    abort: false,
    ...util.normalizeParams(params),
  });
}

// GUID
export type $ZodGUIDParams = StringFormatParams<schemas.$ZodGUID, "pattern" | "when">;
export type $ZodCheckGUIDParams = CheckStringFormatParams<schemas.$ZodGUID, "pattern" | "when">;
export function _guid<T extends schemas.$ZodGUID>(
  Class: util.SchemaClass<T>,
  params?: string | $ZodGUIDParams | $ZodCheckGUIDParams
): T {
  return new Class({
    type: "string",
    format: "guid",
    check: "string_format",
    abort: false,
    ...util.normalizeParams(params),
  });
}

// UUID
export type $ZodUUIDParams = StringFormatParams<schemas.$ZodUUID, "pattern" | "when">;
export type $ZodCheckUUIDParams = CheckStringFormatParams<schemas.$ZodUUID, "pattern" | "when">;
export function _uuid<T extends schemas.$ZodUUID>(
  Class: util.SchemaClass<T>,
  params?: string | $ZodUUIDParams | $ZodCheckUUIDParams
): T {
  return new Class({
    type: "string",
    format: "uuid",
    check: "string_format",
    abort: false,
    ...util.normalizeParams(params),
  });
}

// UUIDv4
export type $ZodUUIDv4Params = StringFormatParams<schemas.$ZodUUID, "pattern" | "when">;
export type $ZodCheckUUIDv4Params = CheckStringFormatParams<schemas.$ZodUUID, "pattern" | "when">;
export function _uuidv4<T extends schemas.$ZodUUID>(
  Class: util.SchemaClass<T>,
  params?: string | $ZodUUIDv4Params | $ZodCheckUUIDv4Params
): T {
  return new Class({
    type: "string",
    format: "uuid",
    check: "string_format",
    abort: false,
    version: "v4",
    ...util.normalizeParams(params),
  });
}

// UUIDv6
export type $ZodUUIDv6Params = StringFormatParams<schemas.$ZodUUID, "pattern" | "when">;
export type $ZodCheckUUIDv6Params = CheckStringFormatParams<schemas.$ZodUUID, "pattern" | "when">;
export function _uuidv6<T extends schemas.$ZodUUID>(
  Class: util.SchemaClass<T>,
  params?: string | $ZodUUIDv6Params | $ZodCheckUUIDv6Params
): T {
  return new Class({
    type: "string",
    format: "uuid",
    check: "string_format",
    abort: false,
    version: "v6",
    ...util.normalizeParams(params),
  });
}

// UUIDv7
export type $ZodUUIDv7Params = StringFormatParams<schemas.$ZodUUID, "pattern" | "when">;
export type $ZodCheckUUIDv7Params = CheckStringFormatParams<schemas.$ZodUUID, "pattern" | "when">;
export function _uuidv7<T extends schemas.$ZodUUID>(
  Class: util.SchemaClass<T>,
  params?: string | $ZodUUIDv7Params | $ZodCheckUUIDv7Params
): T {
  return new Class({
    type: "string",
    format: "uuid",
    check: "string_format",
    abort: false,
    version: "v7",
    ...util.normalizeParams(params),
  });
}

// URL
export type $ZodURLParams = StringFormatParams<schemas.$ZodURL, "when">;
export type $ZodCheckURLParams = CheckStringFormatParams<schemas.$ZodURL, "when">;
export function _url<T extends schemas.$ZodURL>(
  Class: util.SchemaClass<T>,
  params?: string | $ZodURLParams | $ZodCheckURLParams
): T {
  return new Class({
    type: "string",
    format: "url",
    check: "string_format",
    abort: false,
    ...util.normalizeParams(params),
  });
}

// Emoji
export type $ZodEmojiParams = StringFormatParams<schemas.$ZodEmoji, "when">;
export type $ZodCheckEmojiParams = CheckStringFormatParams<schemas.$ZodEmoji, "when">;
export function _emoji<T extends schemas.$ZodEmoji>(
  Class: util.SchemaClass<T>,
  params?: string | $ZodEmojiParams | $ZodCheckEmojiParams
): T {
  return new Class({
    type: "string",
    format: "emoji",
    check: "string_format",
    abort: false,
    ...util.normalizeParams(params),
  });
}

// NanoID
export type $ZodNanoIDParams = StringFormatParams<schemas.$ZodNanoID, "when">;
export type $ZodCheckNanoIDParams = CheckStringFormatParams<schemas.$ZodNanoID, "when">;
export function _nanoid<T extends schemas.$ZodNanoID>(
  Class: util.SchemaClass<T>,
  params?: string | $ZodNanoIDParams | $ZodCheckNanoIDParams
): T {
  return new Class({
    type: "string",
    format: "nanoid",
    check: "string_format",
    abort: false,
    ...util.normalizeParams(params),
  });
}

// CUID
export type $ZodCUIDParams = StringFormatParams<schemas.$ZodCUID, "when">;
export type $ZodCheckCUIDParams = CheckStringFormatParams<schemas.$ZodCUID, "when">;
export function _cuid<T extends schemas.$ZodCUID>(
  Class: util.SchemaClass<T>,
  params?: string | $ZodCUIDParams | $ZodCheckCUIDParams
): T {
  return new Class({
    type: "string",
    format: "cuid",
    check: "string_format",
    abort: false,
    ...util.normalizeParams(params),
  });
}

// CUID2
export type $ZodCUID2Params = StringFormatParams<schemas.$ZodCUID2, "when">;
export type $ZodCheckCUID2Params = CheckStringFormatParams<schemas.$ZodCUID2, "when">;
export function _cuid2<T extends schemas.$ZodCUID2>(
  Class: util.SchemaClass<T>,
  params?: string | $ZodCUID2Params | $ZodCheckCUID2Params
): T {
  return new Class({
    type: "string",
    format: "cuid2",
    check: "string_format",
    abort: false,
    ...util.normalizeParams(params),
  });
}

// ULID
export type $ZodULIDParams = StringFormatParams<schemas.$ZodULID, "when">;
export type $ZodCheckULIDParams = CheckStringFormatParams<schemas.$ZodULID, "when">;
export function _ulid<T extends schemas.$ZodULID>(
  Class: util.SchemaClass<T>,
  params?: string | $ZodULIDParams | $ZodCheckULIDParams
): T {
  return new Class({
    type: "string",
    format: "ulid",
    check: "string_format",
    abort: false,
    ...util.normalizeParams(params),
  });
}

// XID
export type $ZodXIDParams = StringFormatParams<schemas.$ZodXID, "when">;
export type $ZodCheckXIDParams = CheckStringFormatParams<schemas.$ZodXID, "when">;
export function _xid<T extends schemas.$ZodXID>(
  Class: util.SchemaClass<T>,
  params?: string | $ZodXIDParams | $ZodCheckXIDParams
): T {
  return new Class({
    type: "string",
    format: "xid",
    check: "string_format",
    abort: false,
    ...util.normalizeParams(params),
  });
}

// KSUID
export type $ZodKSUIDParams = StringFormatParams<schemas.$ZodKSUID, "when">;
export type $ZodCheckKSUIDParams = CheckStringFormatParams<schemas.$ZodKSUID, "when">;
export function _ksuid<T extends schemas.$ZodKSUID>(
  Class: util.SchemaClass<T>,
  params?: string | $ZodKSUIDParams | $ZodCheckKSUIDParams
): T {
  return new Class({
    type: "string",
    format: "ksuid",
    check: "string_format",
    abort: false,
    ...util.normalizeParams(params),
  });
}

// IPv4
export type $ZodIPv4Params = StringFormatParams<schemas.$ZodIPv4, "pattern" | "when" | "version">;
export type $ZodCheckIPv4Params = CheckStringFormatParams<schemas.$ZodIPv4, "pattern" | "when" | "version">;
export function _ipv4<T extends schemas.$ZodIPv4>(
  Class: util.SchemaClass<T>,
  params?: string | $ZodIPv4Params | $ZodCheckIPv4Params
): T {
  return new Class({
    type: "string",
    format: "ipv4",
    check: "string_format",
    abort: false,
    ...util.normalizeParams(params),
  });
}

// IPv6
export type $ZodIPv6Params = StringFormatParams<schemas.$ZodIPv6, "pattern" | "when" | "version">;
export type $ZodCheckIPv6Params = CheckStringFormatParams<schemas.$ZodIPv6, "pattern" | "when" | "version">;
export function _ipv6<T extends schemas.$ZodIPv6>(
  Class: util.SchemaClass<T>,
  params?: string | $ZodIPv6Params | $ZodCheckIPv6Params
): T {
  return new Class({
    type: "string",
    format: "ipv6",
    check: "string_format",
    abort: false,
    ...util.normalizeParams(params),
  });
}

// CIDRv4
export type $ZodCIDRv4Params = StringFormatParams<schemas.$ZodCIDRv4, "pattern" | "when">;
export type $ZodCheckCIDRv4Params = CheckStringFormatParams<schemas.$ZodCIDRv4, "pattern" | "when">;
export function _cidrv4<T extends schemas.$ZodCIDRv4>(
  Class: util.SchemaClass<T>,
  params?: string | $ZodCIDRv4Params | $ZodCheckCIDRv4Params
): T {
  return new Class({
    type: "string",
    format: "cidrv4",
    check: "string_format",
    abort: false,
    ...util.normalizeParams(params),
  });
}

// CIDRv6
export type $ZodCIDRv6Params = StringFormatParams<schemas.$ZodCIDRv6, "pattern" | "when">;
export type $ZodCheckCIDRv6Params = CheckStringFormatParams<schemas.$ZodCIDRv6, "pattern" | "when">;
export function _cidrv6<T extends schemas.$ZodCIDRv6>(
  Class: util.SchemaClass<T>,
  params?: string | $ZodCIDRv6Params | $ZodCheckCIDRv6Params
): T {
  return new Class({
    type: "string",
    format: "cidrv6",
    check: "string_format",
    abort: false,
    ...util.normalizeParams(params),
  });
}

// Base64
export type $ZodBase64Params = StringFormatParams<schemas.$ZodBase64, "pattern" | "when">;
export type $ZodCheckBase64Params = CheckStringFormatParams<schemas.$ZodBase64, "pattern" | "when">;
export function _base64<T extends schemas.$ZodBase64>(
  Class: util.SchemaClass<T>,
  params?: string | $ZodBase64Params | $ZodCheckBase64Params
): T {
  return new Class({
    type: "string",
    format: "base64",
    check: "string_format",
    abort: false,
    ...util.normalizeParams(params),
  });
}

// base64url
export type $ZodBase64URLParams = StringFormatParams<schemas.$ZodBase64URL, "pattern" | "when">;
export type $ZodCheckBase64URLParams = CheckStringFormatParams<schemas.$ZodBase64URL, "pattern" | "when">;
export function _base64url<T extends schemas.$ZodBase64URL>(
  Class: util.SchemaClass<T>,
  params?: string | $ZodBase64URLParams | $ZodCheckBase64URLParams
): T {
  return new Class({
    type: "string",
    format: "base64url",
    check: "string_format",
    abort: false,
    ...util.normalizeParams(params),
  });
}

// E164
export type $ZodE164Params = StringFormatParams<schemas.$ZodE164, "when">;
export type $ZodCheckE164Params = CheckStringFormatParams<schemas.$ZodE164, "when">;
export function _e164<T extends schemas.$ZodE164>(
  Class: util.SchemaClass<T>,
  params?: string | $ZodE164Params | $ZodCheckE164Params
): T {
  return new Class({
    type: "string",
    format: "e164",
    check: "string_format",
    abort: false,
    ...util.normalizeParams(params),
  });
}

// JWT
export type $ZodJWTParams = StringFormatParams<schemas.$ZodJWT, "pattern" | "when">;
export type $ZodCheckJWTParams = CheckStringFormatParams<schemas.$ZodJWT, "pattern" | "when">;
export function _jwt<T extends schemas.$ZodJWT>(
  Class: util.SchemaClass<T>,
  params?: string | $ZodJWTParams | $ZodCheckJWTParams
): T {
  return new Class({
    type: "string",
    format: "jwt",
    check: "string_format",
    abort: false,
    ...util.normalizeParams(params),
  });
}

export const TimePrecision = {
  Any: null,
  Minute: -1,
  Second: 0,
  Millisecond: 3,
  Microsecond: 6,
} as const;
// ISODateTime
export type $ZodISODateTimeParams = StringFormatParams<schemas.$ZodISODateTime, "pattern" | "when">;
export type $ZodCheckISODateTimeParams = CheckStringFormatParams<schemas.$ZodISODateTime, "pattern" | "when">;
export function _isoDateTime<T extends schemas.$ZodISODateTime>(
  Class: util.SchemaClass<T>,
  params?: string | $ZodISODateTimeParams | $ZodCheckISODateTimeParams
): T {
  return new Class({
    type: "string",
    format: "datetime",
    check: "string_format",
    offset: false,
    local: false,
    precision: null,
    ...util.normalizeParams(params),
  });
}

// ISODate
export type $ZodISODateParams = StringFormatParams<schemas.$ZodISODate, "pattern" | "when">;
export type $ZodCheckISODateParams = CheckStringFormatParams<schemas.$ZodISODate, "pattern" | "when">;
export function _isoDate<T extends schemas.$ZodISODate>(
  Class: util.SchemaClass<T>,
  params?: string | $ZodISODateParams | $ZodCheckISODateParams
): T {
  return new Class({
    type: "string",
    format: "date",
    check: "string_format",
    ...util.normalizeParams(params),
  });
}

// ISOTime
export type $ZodISOTimeParams = StringFormatParams<schemas.$ZodISOTime, "pattern" | "when">;
export type $ZodCheckISOTimeParams = CheckStringFormatParams<schemas.$ZodISOTime, "pattern" | "when">;
export function _isoTime<T extends schemas.$ZodISOTime>(
  Class: util.SchemaClass<T>,
  params?: string | $ZodISOTimeParams | $ZodCheckISOTimeParams
): T {
  return new Class({
    type: "string",
    format: "time",
    check: "string_format",
    precision: null,
    ...util.normalizeParams(params),
  });
}

// ISODuration
export type $ZodISODurationParams = StringFormatParams<schemas.$ZodISODuration, "when">;
export type $ZodCheckISODurationParams = CheckStringFormatParams<schemas.$ZodISODuration, "when">;
export function _isoDuration<T extends schemas.$ZodISODuration>(
  Class: util.SchemaClass<T>,
  params?: string | $ZodISODurationParams | $ZodCheckISODurationParams
): T {
  return new Class({
    type: "string",
    format: "duration",
    check: "string_format",
    ...util.normalizeParams(params),
  });
}

// Number
export type $ZodNumberParams = TypeParams<schemas.$ZodNumber<number>, "coerce">;
export type $ZodNumberFormatParams = CheckTypeParams<schemas.$ZodNumberFormat, "format" | "coerce">;
export type $ZodCheckNumberFormatParams = CheckParams<checks.$ZodCheckNumberFormat, "format" | "when">;
export function _number<T extends schemas.$ZodNumber>(
  Class: util.SchemaClass<T>,
  params?: string | $ZodNumberParams
): T {
  return new Class({
    type: "number",
    checks: [],
    ...util.normalizeParams(params),
  });
}

export function _coercedNumber<T extends schemas.$ZodNumber>(
  Class: util.SchemaClass<T>,
  params?: string | $ZodNumberParams
): T {
  return new Class({
    type: "number",
    coerce: true,
    checks: [],
    ...util.normalizeParams(params),
  });
}

export function _int<T extends schemas.$ZodNumberFormat>(
  Class: util.SchemaClass<T>,
  params?: string | $ZodCheckNumberFormatParams
): T {
  return new Class({
    type: "number",
    check: "number_format",
    abort: false,
    format: "safeint",
    ...util.normalizeParams(params),
  });
}
export function _float32<T extends schemas.$ZodNumberFormat>(
  Class: util.SchemaClass<T>,
  params?: string | $ZodCheckNumberFormatParams
): T {
  return new Class({
    type: "number",
    check: "number_format",
    abort: false,
    format: "float32",
    ...util.normalizeParams(params),
  });
}
export function _float64<T extends schemas.$ZodNumberFormat>(
  Class: util.SchemaClass<T>,
  params?: string | $ZodCheckNumberFormatParams
): T {
  return new Class({
    type: "number",
    check: "number_format",
    abort: false,
    format: "float64",
    ...util.normalizeParams(params),
  });
}
export function _int32<T extends schemas.$ZodNumberFormat>(
  Class: util.SchemaClass<T>,
  params?: string | $ZodCheckNumberFormatParams
): T {
  return new Class({
    type: "number",
    check: "number_format",
    abort: false,
    format: "int32",
    ...util.normalizeParams(params),
  });
}
export function _uint32<T extends schemas.$ZodNumberFormat>(
  Class: util.SchemaClass<T>,
  params?: string | $ZodCheckNumberFormatParams
): T {
  return new Class({
    type: "number",
    check: "number_format",
    abort: false,
    format: "uint32",
    ...util.normalizeParams(params),
  });
}

// Boolean
export type $ZodBooleanParams = TypeParams<schemas.$ZodBoolean<boolean>, "coerce">;
export function _boolean<T extends schemas.$ZodBoolean>(
  Class: util.SchemaClass<T>,
  params?: string | $ZodBooleanParams
): T {
  return new Class({
    type: "boolean",
    ...util.normalizeParams(params),
  });
}
export function _coercedBoolean<T extends schemas.$ZodBoolean>(
  Class: util.SchemaClass<T>,
  params?: string | $ZodBooleanParams
): T {
  return new Class({
    type: "boolean",
    coerce: true,
    ...util.normalizeParams(params),
  });
}

// BigInt
export type $ZodBigIntParams = TypeParams<schemas.$ZodBigInt<bigint>>;
export type $ZodBigIntFormatParams = CheckTypeParams<schemas.$ZodBigIntFormat, "format" | "coerce">;
export type $ZodCheckBigIntFormatParams = CheckParams<checks.$ZodCheckBigIntFormat, "format" | "when">;
export function _bigint<T extends schemas.$ZodBigInt>(
  Class: util.SchemaClass<T>,
  params?: string | $ZodBigIntParams
): T {
  return new Class({
    type: "bigint",
    ...util.normalizeParams(params),
  });
}
export function _coercedBigint<T extends schemas.$ZodBigInt>(
  Class: util.SchemaClass<T>,
  params?: string | $ZodBigIntParams
): T {
  return new Class({
    type: "bigint",
    coerce: true,
    ...util.normalizeParams(params),
  });
}

export function _int64<T extends schemas.$ZodBigIntFormat>(
  Class: util.SchemaClass<T>,
  params?: string | $ZodBigIntFormatParams
): T {
  return new Class({
    type: "bigint",
    check: "bigint_format",
    abort: false,
    format: "int64",
    ...util.normalizeParams(params),
  });
}
export function _uint64<T extends schemas.$ZodBigIntFormat>(
  Class: util.SchemaClass<T>,
  params?: string | $ZodBigIntFormatParams
): T {
  return new Class({
    type: "bigint",
    check: "bigint_format",
    abort: false,
    format: "uint64",
    ...util.normalizeParams(params),
  });
}

// Symbol
export type $ZodSymbolParams = TypeParams<schemas.$ZodSymbol>;
export function _symbol<T extends schemas.$ZodSymbol>(
  Class: util.SchemaClass<T>,
  params?: string | $ZodSymbolParams
): T {
  return new Class({
    type: "symbol",
    ...util.normalizeParams(params),
  });
}

// Undefined
export type $ZodUndefinedParams = TypeParams<schemas.$ZodUndefined>;
export function _undefined<T extends schemas.$ZodUndefined>(
  Class: util.SchemaClass<T>,
  params?: string | $ZodUndefinedParams
): T {
  return new Class({
    type: "undefined",
    ...util.normalizeParams(params),
  });
}

// Null
export type $ZodNullParams = TypeParams<schemas.$ZodNull>;
export function _null<T extends schemas.$ZodNull>(Class: util.SchemaClass<T>, params?: string | $ZodNullParams): T {
  return new Class({
    type: "null",
    ...util.normalizeParams(params),
  });
}

// Any
export type $ZodAnyParams = TypeParams<schemas.$ZodAny>;
export function _any<T extends schemas.$ZodAny>(Class: util.SchemaClass<T>): T {
  return new Class({
    type: "any",
  });
}

// Unknown
export type $ZodUnknownParams = TypeParams<schemas.$ZodUnknown>;
export function _unknown<T extends schemas.$ZodUnknown>(Class: util.SchemaClass<T>): T {
  return new Class({
    type: "unknown",
  });
}

// Never
export type $ZodNeverParams = TypeParams<schemas.$ZodNever>;
export function _never<T extends schemas.$ZodNever>(Class: util.SchemaClass<T>, params?: string | $ZodNeverParams): T {
  return new Class({
    type: "never",
    ...util.normalizeParams(params),
  });
}

// Void
export type $ZodVoidParams = TypeParams<schemas.$ZodVoid>;
export function _void<T extends schemas.$ZodVoid>(Class: util.SchemaClass<T>, params?: string | $ZodVoidParams): T {
  return new Class({
    type: "void",
    ...util.normalizeParams(params),
  });
}

// Date
export type $ZodDateParams = TypeParams<schemas.$ZodDate, "coerce">;
export function _date<T extends schemas.$ZodDate>(Class: util.SchemaClass<T>, params?: string | $ZodDateParams): T {
  return new Class({
    type: "date",
    ...util.normalizeParams(params),
  });
}
export function _coercedDate<T extends schemas.$ZodDate>(
  Class: util.SchemaClass<T>,
  params?: string | $ZodDateParams
): T {
  return new Class({
    type: "date",
    coerce: true,
    ...util.normalizeParams(params),
  });
}

// NaN
export type $ZodNaNParams = TypeParams<schemas.$ZodNaN>;
export function _nan<T extends schemas.$ZodNaN>(Class: util.SchemaClass<T>, params?: string | $ZodNaNParams): T {
  return new Class({
    type: "nan",
    ...util.normalizeParams(params),
  });
}

// export type $ZodCheckParams = CheckParams<checks.$ZodCheck, "abort" | "when">;

export type $ZodCheckLessThanParams = CheckParams<checks.$ZodCheckLessThan, "inclusive" | "value" | "when">;
export function _lt(
  value: util.Numeric,
  params?: string | $ZodCheckLessThanParams
): checks.$ZodCheckLessThan<util.Numeric> {
  return new checks.$ZodCheckLessThan({
    check: "less_than",
    ...util.normalizeParams(params),
    value,
    inclusive: false,
  });
}

export function _lte(
  value: util.Numeric,
  params?: string | $ZodCheckLessThanParams
): checks.$ZodCheckLessThan<util.Numeric> {
  return new checks.$ZodCheckLessThan({
    check: "less_than",

    ...util.normalizeParams(params),
    value,
    inclusive: true,
  });
}
export {
  /** @deprecated Use `z.lte()` instead. */
  _lte as _max,
};

// ZodCheckGreaterThan
export type $ZodCheckGreaterThanParams = CheckParams<checks.$ZodCheckGreaterThan, "inclusive" | "value" | "when">;
export function _gt(value: util.Numeric, params?: string | $ZodCheckGreaterThanParams): checks.$ZodCheckGreaterThan {
  return new checks.$ZodCheckGreaterThan({
    check: "greater_than",

    ...util.normalizeParams(params),
    value,
    inclusive: false,
  });
}

export function _gte(value: util.Numeric, params?: string | $ZodCheckGreaterThanParams): checks.$ZodCheckGreaterThan {
  return new checks.$ZodCheckGreaterThan({
    check: "greater_than",
    ...util.normalizeParams(params),
    value,
    inclusive: true,
  });
}

export {
  /** @deprecated Use `z.gte()` instead. */
  _gte as _min,
};

export function _positive(params?: string | $ZodCheckGreaterThanParams): checks.$ZodCheckGreaterThan {
  return _gt(0, params);
}

// negative
export function _negative(params?: string | $ZodCheckLessThanParams): checks.$ZodCheckLessThan {
  return _lt(0, params);
}

// nonpositive
export function _nonpositive(params?: string | $ZodCheckLessThanParams): checks.$ZodCheckLessThan {
  return _lte(0, params);
}

// nonnegative
export function _nonnegative(params?: string | $ZodCheckGreaterThanParams): checks.$ZodCheckGreaterThan {
  return _gte(0, params);
}

export type $ZodCheckMultipleOfParams = CheckParams<checks.$ZodCheckMultipleOf, "value" | "when">;
export function _multipleOf(
  value: number | bigint,
  params?: string | $ZodCheckMultipleOfParams
): checks.$ZodCheckMultipleOf {
  return new checks.$ZodCheckMultipleOf({
    check: "multiple_of",
    ...util.normalizeParams(params),
    value,
  });
}

export type $ZodCheckMaxSizeParams = CheckParams<checks.$ZodCheckMaxSize, "maximum" | "when">;
export function _maxSize(
  maximum: number,
  params?: string | $ZodCheckMaxSizeParams
): checks.$ZodCheckMaxSize<util.HasSize> {
  return new checks.$ZodCheckMaxSize({
    check: "max_size",
    ...util.normalizeParams(params),
    maximum,
  });
}

export type $ZodCheckMinSizeParams = CheckParams<checks.$ZodCheckMinSize, "minimum" | "when">;
export function _minSize(
  minimum: number,
  params?: string | $ZodCheckMinSizeParams
): checks.$ZodCheckMinSize<util.HasSize> {
  return new checks.$ZodCheckMinSize({
    check: "min_size",
    ...util.normalizeParams(params),
    minimum,
  });
}

export type $ZodCheckSizeEqualsParams = CheckParams<checks.$ZodCheckSizeEquals, "size" | "when">;
export function _size(
  size: number,
  params?: string | $ZodCheckSizeEqualsParams
): checks.$ZodCheckSizeEquals<util.HasSize> {
  return new checks.$ZodCheckSizeEquals({
    check: "size_equals",
    ...util.normalizeParams(params),
    size,
  });
}

export type $ZodCheckMaxLengthParams = CheckParams<checks.$ZodCheckMaxLength, "maximum" | "when">;
export function _maxLength(
  maximum: number,
  params?: string | $ZodCheckMaxLengthParams
): checks.$ZodCheckMaxLength<util.HasLength> {
  const ch = new checks.$ZodCheckMaxLength({
    check: "max_length",
    ...util.normalizeParams(params),
    maximum,
  });
  return ch;
}

export type $ZodCheckMinLengthParams = CheckParams<checks.$ZodCheckMinLength, "minimum" | "when">;
export function _minLength(
  minimum: number,
  params?: string | $ZodCheckMinLengthParams
): checks.$ZodCheckMinLength<util.HasLength> {
  return new checks.$ZodCheckMinLength({
    check: "min_length",
    ...util.normalizeParams(params),
    minimum,
  });
}

export type $ZodCheckLengthEqualsParams = CheckParams<checks.$ZodCheckLengthEquals, "length" | "when">;
export function _length(
  length: number,
  params?: string | $ZodCheckLengthEqualsParams
): checks.$ZodCheckLengthEquals<util.HasLength> {
  return new checks.$ZodCheckLengthEquals({
    check: "length_equals",
    ...util.normalizeParams(params),
    length,
  });
}

export type $ZodCheckRegexParams = CheckParams<checks.$ZodCheckRegex, "format" | "pattern" | "when">;
export function _regex(pattern: RegExp, params?: string | $ZodCheckRegexParams): checks.$ZodCheckRegex {
  return new checks.$ZodCheckRegex({
    check: "string_format",
    format: "regex",
    ...util.normalizeParams(params),
    pattern,
  });
}

export type $ZodCheckLowerCaseParams = CheckParams<checks.$ZodCheckLowerCase, "format" | "when">;
export function _lowercase(params?: string | $ZodCheckLowerCaseParams): checks.$ZodCheckLowerCase {
  return new checks.$ZodCheckLowerCase({
    check: "string_format",
    format: "lowercase",
    ...util.normalizeParams(params),
  });
}

export type $ZodCheckUpperCaseParams = CheckParams<checks.$ZodCheckUpperCase, "format" | "when">;

export function _uppercase(params?: string | $ZodCheckUpperCaseParams): checks.$ZodCheckUpperCase {
  return new checks.$ZodCheckUpperCase({
    check: "string_format",
    format: "uppercase",
    ...util.normalizeParams(params),
  });
}

export type $ZodCheckIncludesParams = CheckParams<checks.$ZodCheckIncludes, "includes" | "format" | "when" | "pattern">;
export function _includes(includes: string, params?: string | $ZodCheckIncludesParams): checks.$ZodCheckIncludes {
  return new checks.$ZodCheckIncludes({
    check: "string_format",
    format: "includes",
    ...util.normalizeParams(params),
    includes,
  });
}
export type $ZodCheckStartsWithParams = CheckParams<
  checks.$ZodCheckStartsWith,
  "prefix" | "format" | "when" | "pattern"
>;
export function _startsWith(prefix: string, params?: string | $ZodCheckStartsWithParams): checks.$ZodCheckStartsWith {
  return new checks.$ZodCheckStartsWith({
    check: "string_format",
    format: "starts_with",
    ...util.normalizeParams(params),
    prefix,
  });
}

export type $ZodCheckEndsWithParams = CheckParams<checks.$ZodCheckEndsWith, "suffix" | "format" | "pattern" | "when">;

export function _endsWith(suffix: string, params?: string | $ZodCheckEndsWithParams): checks.$ZodCheckEndsWith {
  return new checks.$ZodCheckEndsWith({
    check: "string_format",
    format: "ends_with",
    ...util.normalizeParams(params),
    suffix,
  });
}

export type $ZodCheckPropertyParams = CheckParams<checks.$ZodCheckProperty, "property" | "schema" | "when">;
export function _property<K extends string, T extends schemas.$ZodType>(
  property: K,
  schema: T,
  params?: string | $ZodCheckPropertyParams
): checks.$ZodCheckProperty<{ [k in K]: core.output<T> }> {
  return new checks.$ZodCheckProperty({
    check: "property",
    property,
    schema,
    ...util.normalizeParams(params),
  });
}

export type $ZodCheckMimeTypeParams = CheckParams<checks.$ZodCheckMimeType, "mime" | "when">;
export function _mime(types: util.MimeTypes[], params?: string | $ZodCheckMimeTypeParams): checks.$ZodCheckMimeType {
  return new checks.$ZodCheckMimeType({
    check: "mime_type",
    mime: types,
    ...util.normalizeParams(params),
  });
}

export function _overwrite<T>(tx: (input: T) => T): checks.$ZodCheckOverwrite<T> {
  return new checks.$ZodCheckOverwrite({
    check: "overwrite",
    tx,
  }) as checks.$ZodCheckOverwrite<T>;
}
// normalize
export function _normalize(form?: "NFC" | "NFD" | "NFKC" | "NFKD" | (string & {})): checks.$ZodCheckOverwrite<string> {
  return _overwrite((input) => input.normalize(form));
}

// trim
export function _trim(): checks.$ZodCheckOverwrite<string> {
  return _overwrite((input) => input.trim());
}
// toLowerCase
export function _toLowerCase(): checks.$ZodCheckOverwrite<string> {
  return _overwrite((input) => input.toLowerCase());
}
// toUpperCase
export function _toUpperCase(): checks.$ZodCheckOverwrite<string> {
  return _overwrite((input) => input.toUpperCase());
}

///////  collections   ///////

// Array
export type $ZodArrayParams = TypeParams<schemas.$ZodArray, "element">;
export function _array<T extends schemas.$ZodType>(
  Class: util.SchemaClass<schemas.$ZodArray>,
  element: T,
  params?: string | $ZodArrayParams
): schemas.$ZodArray<T> {
  return new Class({
    type: "array",
    element,
    // get element() {
    //   return element;
    // },
    ...util.normalizeParams(params),
  }) as any;
}

export type $ZodObjectParams = TypeParams<schemas.$ZodObject, "shape" | "catchall">;

// ZodUnion
export type $ZodUnionParams = TypeParams<schemas.$ZodUnion, "options">;
export function _union<const T extends readonly schemas.$ZodObject[]>(
  Class: util.SchemaClass<schemas.$ZodUnion>,
  options: T,
  params?: string | $ZodUnionParams
): schemas.$ZodUnion<T> {
  return new Class({
    type: "union",
    options,
    ...util.normalizeParams(params),
  }) as any;
}

// ZodDiscriminatedUnion
export interface $ZodTypeDiscriminableInternals extends schemas.$ZodTypeInternals {
  propValues: util.PropValues;
}

export interface $ZodTypeDiscriminable extends schemas.$ZodType {
  _zod: $ZodTypeDiscriminableInternals;
}
export type $ZodDiscriminatedUnionParams = TypeParams<schemas.$ZodDiscriminatedUnion, "options" | "discriminator">;
export function _discriminatedUnion<
  Types extends [$ZodTypeDiscriminable, ...$ZodTypeDiscriminable[]],
  Disc extends string,
>(
  Class: util.SchemaClass<schemas.$ZodDiscriminatedUnion>,
  discriminator: Disc,
  options: Types,
  params?: string | $ZodDiscriminatedUnionParams
): schemas.$ZodDiscriminatedUnion<Types, Disc> {
  return new Class({
    type: "union",
    options,
    discriminator,
    ...util.normalizeParams(params),
  }) as any;
}

// ZodIntersection
export type $ZodIntersectionParams = TypeParams<schemas.$ZodIntersection, "left" | "right">;
export function _intersection<T extends schemas.$ZodObject, U extends schemas.$ZodObject>(
  Class: util.SchemaClass<schemas.$ZodIntersection>,
  left: T,
  right: U
): schemas.$ZodIntersection<T, U> {
  return new Class({
    type: "intersection",
    left,
    right,
  }) as any;
}

// ZodTuple
export type $ZodTupleParams = TypeParams<schemas.$ZodTuple, "items" | "rest">;
export function _tuple<T extends readonly [schemas.$ZodType, ...schemas.$ZodType[]]>(
  Class: util.SchemaClass<schemas.$ZodTuple>,
  items: T,
  params?: string | $ZodTupleParams
): schemas.$ZodTuple<T, null>;
export function _tuple<T extends readonly [schemas.$ZodType, ...schemas.$ZodType[]], Rest extends schemas.$ZodType>(
  Class: util.SchemaClass<schemas.$ZodTuple>,
  items: T,
  rest: Rest,
  params?: string | $ZodTupleParams
): schemas.$ZodTuple<T, Rest>;
// export function _tuple(
//   Class: util.SchemaClass<schemas.$ZodTuple>,
//   items: [],
//   params?: string | $ZodTupleParams
// ): schemas.$ZodTuple<[], null>;
export function _tuple(
  Class: util.SchemaClass<schemas.$ZodTuple>,
  items: schemas.$ZodType[],
  _paramsOrRest?: string | $ZodTupleParams | schemas.$ZodType,
  _params?: string | $ZodTupleParams
) {
  const hasRest = _paramsOrRest instanceof schemas.$ZodType;
  const params = hasRest ? _params : _paramsOrRest;
  const rest = hasRest ? _paramsOrRest : null;
  return new Class({
    type: "tuple",
    items,
    rest,
    ...util.normalizeParams(params),
  });
}

// ZodRecord
export type $ZodRecordParams = TypeParams<schemas.$ZodRecord, "keyType" | "valueType">;
export function _record<Key extends schemas.$ZodRecordKey, Value extends schemas.$ZodObject>(
  Class: util.SchemaClass<schemas.$ZodRecord>,
  keyType: Key,
  valueType: Value,
  params?: string | $ZodRecordParams
): schemas.$ZodRecord<Key, Value> {
  return new Class({
    type: "record",
    keyType,
    valueType,
    ...util.normalizeParams(params),
  }) as any;
}

// ZodMap
export type $ZodMapParams = TypeParams<schemas.$ZodMap, "keyType" | "valueType">;
export function _map<Key extends schemas.$ZodObject, Value extends schemas.$ZodObject>(
  Class: util.SchemaClass<schemas.$ZodMap>,
  keyType: Key,
  valueType: Value,
  params?: string | $ZodMapParams
): schemas.$ZodMap<Key, Value> {
  return new Class({
    type: "map",
    keyType,
    valueType,
    ...util.normalizeParams(params),
  }) as any;
}

// ZodSet
export type $ZodSetParams = TypeParams<schemas.$ZodSet, "valueType">;
export function _set<Value extends schemas.$ZodObject>(
  Class: util.SchemaClass<schemas.$ZodSet>,
  valueType: Value,
  params?: string | $ZodSetParams
): schemas.$ZodSet<Value> {
  return new Class({
    type: "set",
    valueType,
    ...util.normalizeParams(params),
  }) as any;
}

// ZodEnum
export type $ZodEnumParams = TypeParams<schemas.$ZodEnum, "entries">;
export function _enum<const T extends string[]>(
  Class: util.SchemaClass<schemas.$ZodEnum>,
  values: T,
  params?: string | $ZodEnumParams
): schemas.$ZodEnum<util.ToEnum<T[number]>>;
export function _enum<T extends util.EnumLike>(
  Class: util.SchemaClass<schemas.$ZodEnum>,
  entries: T,
  params?: string | $ZodEnumParams
): schemas.$ZodEnum<T>;
export function _enum(Class: util.SchemaClass<schemas.$ZodEnum>, values: any, params?: string | $ZodEnumParams) {
  const entries: any = Array.isArray(values) ? Object.fromEntries(values.map((v) => [v, v])) : values;
  // if (Array.isArray(values)) {
  //   for (const value of values) {
  //     entries[value] = value;
  //   }
  // } else {
  //   Object.assign(entries, values);
  // }
  // const entries: util.EnumLike = {};
  // for (const val of values) {
  //   entries[val] = val;
  // }

  return new Class({
    type: "enum",
    entries,
    ...util.normalizeParams(params),
  }) as any;
}

/** @deprecated This API has been merged into `z.enum()`. Use `z.enum()` instead.
 *
 * ```ts
 * enum Colors { red, green, blue }
 * z.enum(Colors);
 * ```
 */
export function _nativeEnum<T extends util.EnumLike>(
  Class: util.SchemaClass<schemas.$ZodEnum>,
  entries: T,
  params?: string | $ZodEnumParams
): schemas.$ZodEnum<T> {
  return new Class({
    type: "enum",
    entries,
    ...util.normalizeParams(params),
  }) as any;
}

// ZodLiteral
export type $ZodLiteralParams = TypeParams<schemas.$ZodLiteral, "values">;
export function _literal<const T extends Array<util.Literal>>(
  Class: util.SchemaClass<schemas.$ZodLiteral>,
  value: T,
  params?: string | $ZodLiteralParams
): schemas.$ZodLiteral<T[number]>;
export function _literal<const T extends util.Literal>(
  Class: util.SchemaClass<schemas.$ZodLiteral>,
  value: T,
  params?: string | $ZodLiteralParams
): schemas.$ZodLiteral<T>;
export function _literal(Class: util.SchemaClass<schemas.$ZodLiteral>, value: any, params: any) {
  return new Class({
    type: "literal",
    values: Array.isArray(value) ? value : [value],
    ...util.normalizeParams(params),
  });
}

// ZodFile
export type $ZodFileParams = TypeParams<schemas.$ZodFile>;
export function _file(Class: util.SchemaClass<schemas.$ZodFile>, params?: string | $ZodFileParams): schemas.$ZodFile {
  return new Class({
    type: "file",
    ...util.normalizeParams(params),
  });
}

// ZodTransform
export type $ZodTransformParams = TypeParams<schemas.$ZodTransform, "transform">;
export function _transform<I = unknown, O = I>(
  Class: util.SchemaClass<schemas.$ZodTransform>,
  fn: (input: I, ctx?: schemas.ParsePayload) => O
): schemas.$ZodTransform<Awaited<O>, I> {
  return new Class({
    type: "transform",
    transform: fn as any,
  }) as any;
}

// ZodOptional
export type $ZodOptionalParams = TypeParams<schemas.$ZodOptional, "innerType">;
export function _optional<T extends schemas.$ZodObject>(
  Class: util.SchemaClass<schemas.$ZodOptional>,
  innerType: T
): schemas.$ZodOptional<T> {
  return new Class({
    type: "optional",
    innerType,
  }) as any;
}

// ZodNullable
export type $ZodNullableParams = TypeParams<schemas.$ZodNullable, "innerType">;
export function _nullable<T extends schemas.$ZodObject>(
  Class: util.SchemaClass<schemas.$ZodNullable>,
  innerType: T
): schemas.$ZodNullable<T> {
  return new Class({
    type: "nullable",
    innerType,
  }) as any;
}

// ZodDefault
export type $ZodDefaultParams = TypeParams<schemas.$ZodDefault, "innerType" | "defaultValue">;
export function _default<T extends schemas.$ZodObject>(
  Class: util.SchemaClass<schemas.$ZodDefault>,
  innerType: T,
  defaultValue: util.NoUndefined<core.output<T>> | (() => util.NoUndefined<core.output<T>>)
): schemas.$ZodDefault<T> {
  return new Class({
    type: "default",
    innerType,
    get defaultValue() {
      return typeof defaultValue === "function" ? (defaultValue as Function)() : util.shallowClone(defaultValue);
    },
  }) as any;
}

// ZodNonOptional
export type $ZodNonOptionalParams = TypeParams<schemas.$ZodNonOptional, "innerType">;
export function _nonoptional<T extends schemas.$ZodObject>(
  Class: util.SchemaClass<schemas.$ZodNonOptional>,
  innerType: T,
  params?: string | $ZodNonOptionalParams
): schemas.$ZodNonOptional<T> {
  return new Class({
    type: "nonoptional",
    innerType,
    ...util.normalizeParams(params),
  }) as any;
}

// ZodSuccess
export type $ZodSuccessParams = TypeParams<schemas.$ZodSuccess, "innerType">;
export function _success<T extends schemas.$ZodObject>(
  Class: util.SchemaClass<schemas.$ZodSuccess>,
  innerType: T
): schemas.$ZodSuccess<T> {
  return new Class({
    type: "success",
    innerType,
  }) as any;
}

// ZodCatch
export type $ZodCatchParams = TypeParams<schemas.$ZodCatch, "innerType" | "catchValue">;
export function _catch<T extends schemas.$ZodObject>(
  Class: util.SchemaClass<schemas.$ZodCatch>,
  innerType: T,
  catchValue: core.output<T> | ((ctx: schemas.$ZodCatchCtx) => core.output<T>)
): schemas.$ZodCatch<T> {
  return new Class({
    type: "catch",
    innerType,
    catchValue: (typeof catchValue === "function" ? catchValue : () => catchValue) as any,
  }) as any;
}

// ZodPipe
export type $ZodPipeParams = TypeParams<schemas.$ZodPipe, "in" | "out">;
export function _pipe<
  const A extends schemas.$ZodType,
  B extends schemas.$ZodType<unknown, core.output<A>> = schemas.$ZodType<unknown, core.output<A>>,
>(
  Class: util.SchemaClass<schemas.$ZodPipe>,
  in_: A,
  out: B | schemas.$ZodType<unknown, core.output<A>>
): schemas.$ZodPipe<A, B> {
  return new Class({
    type: "pipe",
    in: in_,
    out,
  }) as any;
}

// ZodReadonly
export type $ZodReadonlyParams = TypeParams<schemas.$ZodReadonly, "innerType">;
export function _readonly<T extends schemas.$ZodObject>(
  Class: util.SchemaClass<schemas.$ZodReadonly>,
  innerType: T
): schemas.$ZodReadonly<T> {
  return new Class({
    type: "readonly",
    innerType,
  }) as any;
}

// ZodTemplateLiteral
export type $ZodTemplateLiteralParams = TypeParams<schemas.$ZodTemplateLiteral, "parts">;
export function _templateLiteral<const Parts extends schemas.$ZodTemplateLiteralPart[]>(
  Class: util.SchemaClass<schemas.$ZodTemplateLiteral>,
  parts: Parts,
  params?: string | $ZodTemplateLiteralParams
): schemas.$ZodTemplateLiteral<schemas.$PartsToTemplateLiteral<Parts>> {
  return new Class({
    type: "template_literal",
    parts,
    ...util.normalizeParams(params),
  }) as any;
}

// ZodLazy
export type $ZodLazyParams = TypeParams<schemas.$ZodLazy, "getter">;
export function _lazy<T extends schemas.$ZodType>(
  Class: util.SchemaClass<schemas.$ZodLazy>,
  getter: () => T
): schemas.$ZodLazy<T> {
  return new Class({
    type: "lazy",
    getter,
  }) as any;
}

// ZodPromise
export type $ZodPromiseParams = TypeParams<schemas.$ZodPromise, "innerType">;
export function _promise<T extends schemas.$ZodObject>(
  Class: util.SchemaClass<schemas.$ZodPromise>,
  innerType: T
): schemas.$ZodPromise<T> {
  return new Class({
    type: "promise",
    innerType,
  }) as any;
}

// ZodCustom
export type $ZodCustomParams = CheckTypeParams<schemas.$ZodCustom, "fn">;
export function _custom<O = unknown, I = O>(
  Class: util.SchemaClass<schemas.$ZodCustom>,
  fn: (data: O) => unknown,
  _params: string | $ZodCustomParams | undefined
): schemas.$ZodCustom<O, I> {
  const norm = util.normalizeParams(_params);
  norm.abort ??= true; // default to abort:false
  const schema = new Class({
    type: "custom",
    check: "custom",
    fn: fn as any,
    ...norm,
  });

  return schema as any;
}

// same as _custom but defaults to abort:false
export function _refine<O = unknown, I = O>(
  Class: util.SchemaClass<schemas.$ZodCustom>,
  fn: (data: O) => unknown,
  _params: string | $ZodCustomParams | undefined
): schemas.$ZodCustom<O, I> {
  const schema = new Class({
    type: "custom",
    check: "custom",
    fn: fn as any,
    ...util.normalizeParams(_params),
  });

  return schema as any;
}

export type $ZodSuperRefineIssue<T extends errors.$ZodIssueBase = errors.$ZodIssue> = T extends any
  ? RawIssue<T>
  : never;
type RawIssue<T extends errors.$ZodIssueBase> = T extends any
  ? util.Flatten<
      util.MakePartial<T, "message" | "path"> & {
        /** The schema or check that originated this issue. */
        readonly inst?: schemas.$ZodType | checks.$ZodCheck;
        /** If `true`, Zod will execute subsequent checks/refinements instead of immediately aborting */
        readonly continue?: boolean | undefined;
      } & Record<string, unknown>
    >
  : never;

export interface $RefinementCtx<T = unknown> extends schemas.ParsePayload<T> {
  addIssue(arg: string | $ZodSuperRefineIssue): void;
}

export function _superRefine<T>(fn: (arg: T, payload: $RefinementCtx<T>) => void | Promise<void>): checks.$ZodCheck<T> {
  const ch = _check<T>((payload) => {
    (payload as $RefinementCtx).addIssue = (issue) => {
      if (typeof issue === "string") {
        payload.issues.push(util.issue(issue, payload.value, ch._zod.def));
      } else {
        // for Zod 3 backwards compatibility
        const _issue: any = issue;
        if (_issue.fatal) _issue.continue = false;
        _issue.code ??= "custom";
        _issue.input ??= payload.value;
        _issue.inst ??= ch;
        _issue.continue ??= !ch._zod.def.abort; // abort is always undefined, so this is always true...
        payload.issues.push(util.issue(_issue));
      }
    };

    return fn(payload.value, payload as $RefinementCtx<T>);
  });
  return ch;
}

export function _check<O = unknown>(fn: schemas.CheckFn<O>, params?: string | $ZodCustomParams): checks.$ZodCheck<O> {
  const ch = new checks.$ZodCheck({
    check: "custom",
    ...util.normalizeParams(params),
  });

  ch._zod.check = fn;
  return ch;
}

// export type $ZodCustomParams = CheckTypeParams<schemas.$ZodCustom, "fn">

/////////    STRINGBOOL   /////////

// stringbool
export interface $ZodStringBoolParams extends TypeParams {
  truthy?: string[];
  falsy?: string[];
  /**
   * Options: `"sensitive"`, `"insensitive"`
   *
   * @default `"insensitive"`
   */
  case?: "sensitive" | "insensitive" | undefined;
}

export function _stringbool(
  Classes: {
    Codec?: typeof schemas.$ZodCodec;
    Boolean?: typeof schemas.$ZodBoolean;
    String?: typeof schemas.$ZodString;
  },
  _params?: string | $ZodStringBoolParams
): schemas.$ZodCodec<schemas.$ZodString, schemas.$ZodBoolean> {
  const params = util.normalizeParams(_params);

  let truthyArray = params.truthy ?? ["true", "1", "yes", "on", "y", "enabled"];
  let falsyArray = params.falsy ?? ["false", "0", "no", "off", "n", "disabled"];
  if (params.case !== "sensitive") {
    truthyArray = truthyArray.map((v) => (typeof v === "string" ? v.toLowerCase() : v));
    falsyArray = falsyArray.map((v) => (typeof v === "string" ? v.toLowerCase() : v));
  }

  const truthySet = new Set(truthyArray);
  const falsySet = new Set(falsyArray);

  const _Codec = Classes.Codec ?? schemas.$ZodCodec;
  const _Boolean = Classes.Boolean ?? schemas.$ZodBoolean;
  const _String = Classes.String ?? schemas.$ZodString;

  const stringSchema = new _String({ type: "string", error: params.error });
  const booleanSchema = new _Boolean({ type: "boolean", error: params.error });

  const codec = new _Codec({
    type: "pipe",
    in: stringSchema as any,
    out: booleanSchema as any,
    transform: ((input: string, payload: schemas.ParsePayload<string>) => {
      let data: string = input;
      if (params.case !== "sensitive") data = data.toLowerCase();
      if (truthySet.has(data)) {
        return true;
      } else if (falsySet.has(data)) {
        return false;
      } else {
        payload.issues.push({
          code: "invalid_value",
          expected: "stringbool",
          values: [...truthySet, ...falsySet],
          input: payload.value,
          inst: codec,
          continue: false,
        });
        return {} as never;
      }
    }) as any,
    reverseTransform: ((input: boolean, _payload: schemas.ParsePayload<boolean>) => {
      if (input === true) {
        return truthyArray[0] || "true";
      } else {
        return falsyArray[0] || "false";
      }
    }) as any,
    error: params.error,
  }) as any;

  return codec;
}

export function _stringFormat<Format extends string>(
  Class: typeof schemas.$ZodCustomStringFormat,
  format: Format,
  fnOrRegex: ((arg: string) => util.MaybeAsync<unknown>) | RegExp,
  _params: string | $ZodStringFormatParams = {}
): schemas.$ZodCustomStringFormat<Format> {
  const params = util.normalizeParams(_params);
  const def: schemas.$ZodCustomStringFormatDef = {
    ...util.normalizeParams(_params),
    check: "string_format",
    type: "string",
    format,
    fn: typeof fnOrRegex === "function" ? fnOrRegex : (val) => fnOrRegex.test(val),
    ...params,
  };
  if (fnOrRegex instanceof RegExp) {
    def.pattern = fnOrRegex;
  }

  const inst = new Class(def);
  return inst as any;
}

============================== END FILE ========================================
============================= BEGIN FILE =======================================
Path: C:\Users\Last Stop\Documents\Programming Projects\RemoteIQ V5\remoteiq-minimal-e2e\backend\node_modules\.pnpm\zod@3.25.76\node_modules\zod\src\v4\core\api.ts
Name: api.ts
-------------------------------------------------------------------------------import * as checks from "./checks.js";
import type * as core from "./core.js";
import type * as errors from "./errors.js";
import * as schemas from "./schemas.js";
import * as util from "./util.js";

export type Params<
  T extends schemas.$ZodType | checks.$ZodCheck,
  IssueTypes extends errors.$ZodIssueBase,
  OmitKeys extends keyof T["_zod"]["def"] = never,
> = util.Flatten<
  Partial<
    util.EmptyToNever<
      Omit<T["_zod"]["def"], OmitKeys> &
        ([IssueTypes] extends [never]
          ? {} // unknown
          : {
              error?: string | errors.$ZodErrorMap<IssueTypes> | undefined;
              /** @deprecated This parameter is deprecated. Use `error` instead. */
              message?: string | undefined; // supported in Zod 3
            })
    >
  >
>;

export type TypeParams<
  T extends schemas.$ZodType = schemas.$ZodType & { _isst: never },
  AlsoOmit extends Exclude<keyof T["_zod"]["def"], "type" | "checks" | "error"> = never,
> = Params<T, NonNullable<T["_zod"]["isst"]>, "type" | "checks" | "error" | AlsoOmit>;

// strips types that are not exposed in the public factory
// incl. `error`, `check`
export type CheckParams<
  T extends checks.$ZodCheck = checks.$ZodCheck, // & { _issc: never },
  AlsoOmit extends Exclude<keyof T["_zod"]["def"], "check" | "error"> = never,
> = Params<T, NonNullable<T["_zod"]["issc"]>, "check" | "error" | AlsoOmit>;

// strips types that are not exposed in the public factory
// incl. `type`, `checks`, `error`, `check`, `format`
export type StringFormatParams<
  T extends schemas.$ZodStringFormat = schemas.$ZodStringFormat,
  AlsoOmit extends Exclude<keyof T["_zod"]["def"], "type" | "coerce" | "checks" | "error" | "check" | "format"> = never,
> = Params<
  T,
  NonNullable<T["_zod"]["isst"] | T["_zod"]["issc"]>,
  "type" | "coerce" | "checks" | "error" | "check" | "format" | AlsoOmit
>;

export type CheckStringFormatParams<
  T extends schemas.$ZodStringFormat = schemas.$ZodStringFormat,
  AlsoOmit extends Exclude<keyof T["_zod"]["def"], "type" | "coerce" | "checks" | "error" | "check" | "format"> = never,
> = Params<T, NonNullable<T["_zod"]["issc"]>, "type" | "coerce" | "checks" | "error" | "check" | "format" | AlsoOmit>;

export type CheckTypeParams<
  T extends schemas.$ZodType & checks.$ZodCheck = schemas.$ZodType & checks.$ZodCheck,
  AlsoOmit extends Exclude<keyof T["_zod"]["def"], "type" | "checks" | "error" | "check"> = never,
> = Params<T, NonNullable<T["_zod"]["isst"] | T["_zod"]["issc"]>, "type" | "checks" | "error" | "check" | AlsoOmit>;

// String
export type $ZodStringParams = TypeParams<schemas.$ZodString<string>, "coerce">;
export function _string<T extends schemas.$ZodString>(
  Class: util.SchemaClass<T>,
  params?: string | $ZodStringParams
): T {
  return new Class({
    type: "string",
    ...util.normalizeParams(params),
  });
}

export function _coercedString<T extends schemas.$ZodString>(
  Class: util.SchemaClass<T>,
  params?: string | $ZodStringParams
): T {
  return new Class({
    type: "string",
    coerce: true,
    ...util.normalizeParams(params),
  });
}

export type $ZodStringFormatParams = CheckTypeParams<schemas.$ZodStringFormat, "format" | "coerce">;
export type $ZodCheckStringFormatParams = CheckParams<checks.$ZodCheckStringFormat, "format">;
// custom format

// Email
export type $ZodEmailParams = StringFormatParams<schemas.$ZodEmail>;
export type $ZodCheckEmailParams = CheckStringFormatParams<schemas.$ZodEmail>;
export function _email<T extends schemas.$ZodEmail>(
  Class: util.SchemaClass<T>,
  params?: string | $ZodEmailParams | $ZodCheckEmailParams
): T {
  return new Class({
    type: "string",
    format: "email",
    check: "string_format",
    abort: false,
    ...util.normalizeParams(params),
  });
}

// GUID
export type $ZodGUIDParams = StringFormatParams<schemas.$ZodGUID, "pattern">;
export type $ZodCheckGUIDParams = CheckStringFormatParams<schemas.$ZodGUID, "pattern">;
export function _guid<T extends schemas.$ZodGUID>(
  Class: util.SchemaClass<T>,
  params?: string | $ZodGUIDParams | $ZodCheckGUIDParams
): T {
  return new Class({
    type: "string",
    format: "guid",
    check: "string_format",
    abort: false,
    ...util.normalizeParams(params),
  });
}

// UUID
export type $ZodUUIDParams = StringFormatParams<schemas.$ZodUUID, "pattern">;
export type $ZodCheckUUIDParams = CheckStringFormatParams<schemas.$ZodUUID, "pattern">;
export function _uuid<T extends schemas.$ZodUUID>(
  Class: util.SchemaClass<T>,
  params?: string | $ZodUUIDParams | $ZodCheckUUIDParams
): T {
  return new Class({
    type: "string",
    format: "uuid",
    check: "string_format",
    abort: false,
    ...util.normalizeParams(params),
  });
}

// UUIDv4
export type $ZodUUIDv4Params = StringFormatParams<schemas.$ZodUUID, "pattern">;
export type $ZodCheckUUIDv4Params = CheckStringFormatParams<schemas.$ZodUUID, "pattern">;
export function _uuidv4<T extends schemas.$ZodUUID>(
  Class: util.SchemaClass<T>,
  params?: string | $ZodUUIDv4Params | $ZodCheckUUIDv4Params
): T {
  return new Class({
    type: "string",
    format: "uuid",
    check: "string_format",
    abort: false,
    version: "v4",
    ...util.normalizeParams(params),
  });
}

// UUIDv6
export type $ZodUUIDv6Params = StringFormatParams<schemas.$ZodUUID, "pattern">;
export type $ZodCheckUUIDv6Params = CheckStringFormatParams<schemas.$ZodUUID, "pattern">;
export function _uuidv6<T extends schemas.$ZodUUID>(
  Class: util.SchemaClass<T>,
  params?: string | $ZodUUIDv6Params | $ZodCheckUUIDv6Params
): T {
  return new Class({
    type: "string",
    format: "uuid",
    check: "string_format",
    abort: false,
    version: "v6",
    ...util.normalizeParams(params),
  });
}

// UUIDv7
export type $ZodUUIDv7Params = StringFormatParams<schemas.$ZodUUID, "pattern">;
export type $ZodCheckUUIDv7Params = CheckStringFormatParams<schemas.$ZodUUID, "pattern">;
export function _uuidv7<T extends schemas.$ZodUUID>(
  Class: util.SchemaClass<T>,
  params?: string | $ZodUUIDv7Params | $ZodCheckUUIDv7Params
): T {
  return new Class({
    type: "string",
    format: "uuid",
    check: "string_format",
    abort: false,
    version: "v7",
    ...util.normalizeParams(params),
  });
}

// URL
export type $ZodURLParams = StringFormatParams<schemas.$ZodURL>;
export type $ZodCheckURLParams = CheckStringFormatParams<schemas.$ZodURL>;
export function _url<T extends schemas.$ZodURL>(
  Class: util.SchemaClass<T>,
  params?: string | $ZodURLParams | $ZodCheckURLParams
): T {
  return new Class({
    type: "string",
    format: "url",
    check: "string_format",
    abort: false,
    ...util.normalizeParams(params),
  });
}

// Emoji
export type $ZodEmojiParams = StringFormatParams<schemas.$ZodEmoji>;
export type $ZodCheckEmojiParams = CheckStringFormatParams<schemas.$ZodEmoji>;
export function _emoji<T extends schemas.$ZodEmoji>(
  Class: util.SchemaClass<T>,
  params?: string | $ZodEmojiParams | $ZodCheckEmojiParams
): T {
  return new Class({
    type: "string",
    format: "emoji",
    check: "string_format",
    abort: false,
    ...util.normalizeParams(params),
  });
}

// NanoID
export type $ZodNanoIDParams = StringFormatParams<schemas.$ZodNanoID>;
export type $ZodCheckNanoIDParams = CheckStringFormatParams<schemas.$ZodNanoID>;
export function _nanoid<T extends schemas.$ZodNanoID>(
  Class: util.SchemaClass<T>,
  params?: string | $ZodNanoIDParams | $ZodCheckNanoIDParams
): T {
  return new Class({
    type: "string",
    format: "nanoid",
    check: "string_format",
    abort: false,
    ...util.normalizeParams(params),
  });
}

// CUID
export type $ZodCUIDParams = StringFormatParams<schemas.$ZodCUID>;
export type $ZodCheckCUIDParams = CheckStringFormatParams<schemas.$ZodCUID>;
export function _cuid<T extends schemas.$ZodCUID>(
  Class: util.SchemaClass<T>,
  params?: string | $ZodCUIDParams | $ZodCheckCUIDParams
): T {
  return new Class({
    type: "string",
    format: "cuid",
    check: "string_format",
    abort: false,
    ...util.normalizeParams(params),
  });
}

// CUID2
export type $ZodCUID2Params = StringFormatParams<schemas.$ZodCUID2>;
export type $ZodCheckCUID2Params = CheckStringFormatParams<schemas.$ZodCUID2>;
export function _cuid2<T extends schemas.$ZodCUID2>(
  Class: util.SchemaClass<T>,
  params?: string | $ZodCUID2Params | $ZodCheckCUID2Params
): T {
  return new Class({
    type: "string",
    format: "cuid2",
    check: "string_format",
    abort: false,
    ...util.normalizeParams(params),
  });
}

// ULID
export type $ZodULIDParams = StringFormatParams<schemas.$ZodULID>;
export type $ZodCheckULIDParams = CheckStringFormatParams<schemas.$ZodULID>;
export function _ulid<T extends schemas.$ZodULID>(
  Class: util.SchemaClass<T>,
  params?: string | $ZodULIDParams | $ZodCheckULIDParams
): T {
  return new Class({
    type: "string",
    format: "ulid",
    check: "string_format",
    abort: false,
    ...util.normalizeParams(params),
  });
}

// XID
export type $ZodXIDParams = StringFormatParams<schemas.$ZodXID>;
export type $ZodCheckXIDParams = CheckStringFormatParams<schemas.$ZodXID>;
export function _xid<T extends schemas.$ZodXID>(
  Class: util.SchemaClass<T>,
  params?: string | $ZodXIDParams | $ZodCheckXIDParams
): T {
  return new Class({
    type: "string",
    format: "xid",
    check: "string_format",
    abort: false,
    ...util.normalizeParams(params),
  });
}

// KSUID
export type $ZodKSUIDParams = StringFormatParams<schemas.$ZodKSUID>;
export type $ZodCheckKSUIDParams = CheckStringFormatParams<schemas.$ZodKSUID>;
export function _ksuid<T extends schemas.$ZodKSUID>(
  Class: util.SchemaClass<T>,
  params?: string | $ZodKSUIDParams | $ZodCheckKSUIDParams
): T {
  return new Class({
    type: "string",
    format: "ksuid",
    check: "string_format",
    abort: false,
    ...util.normalizeParams(params),
  });
}

// IP
// export type $ZodIPParams = StringFormatParams<schemas.$ZodIP, "pattern">;
// export type $ZodCheckIPParams = CheckStringFormatParams<schemas.$ZodIP, "pattern">;
// export function _ip<T extends schemas.$ZodIP>(
//   Class: util.SchemaClass<T>,
//   params?: string | $ZodIPParams | $ZodCheckIPParams
// ): T {
//   return new Class({
//     type: "string",
//     format: "ip",
//     check: "string_format",
//     abort: false,
//     ...util.normalizeParams(params),
//   });
// }

// IPv4
export type $ZodIPv4Params = StringFormatParams<schemas.$ZodIPv4, "pattern">;
export type $ZodCheckIPv4Params = CheckStringFormatParams<schemas.$ZodIPv4, "pattern">;
export function _ipv4<T extends schemas.$ZodIPv4>(
  Class: util.SchemaClass<T>,
  params?: string | $ZodIPv4Params | $ZodCheckIPv4Params
): T {
  return new Class({
    type: "string",
    format: "ipv4",
    check: "string_format",
    abort: false,
    ...util.normalizeParams(params),
  });
}

// IPv6
export type $ZodIPv6Params = StringFormatParams<schemas.$ZodIPv6, "pattern">;
export type $ZodCheckIPv6Params = CheckStringFormatParams<schemas.$ZodIPv6, "pattern">;
export function _ipv6<T extends schemas.$ZodIPv6>(
  Class: util.SchemaClass<T>,
  params?: string | $ZodIPv6Params | $ZodCheckIPv6Params
): T {
  return new Class({
    type: "string",
    format: "ipv6",
    check: "string_format",
    abort: false,
    ...util.normalizeParams(params),
  });
}

// CIDRv4
export type $ZodCIDRv4Params = StringFormatParams<schemas.$ZodCIDRv4, "pattern">;
export type $ZodCheckCIDRv4Params = CheckStringFormatParams<schemas.$ZodCIDRv4, "pattern">;
export function _cidrv4<T extends schemas.$ZodCIDRv4>(
  Class: util.SchemaClass<T>,
  params?: string | $ZodCIDRv4Params | $ZodCheckCIDRv4Params
): T {
  return new Class({
    type: "string",
    format: "cidrv4",
    check: "string_format",
    abort: false,
    ...util.normalizeParams(params),
  });
}

// CIDRv6
export type $ZodCIDRv6Params = StringFormatParams<schemas.$ZodCIDRv6, "pattern">;
export type $ZodCheckCIDRv6Params = CheckStringFormatParams<schemas.$ZodCIDRv6, "pattern">;
export function _cidrv6<T extends schemas.$ZodCIDRv6>(
  Class: util.SchemaClass<T>,
  params?: string | $ZodCIDRv6Params | $ZodCheckCIDRv6Params
): T {
  return new Class({
    type: "string",
    format: "cidrv6",
    check: "string_format",
    abort: false,
    ...util.normalizeParams(params),
  });
}

// Base64
export type $ZodBase64Params = StringFormatParams<schemas.$ZodBase64, "pattern">;
export type $ZodCheckBase64Params = CheckStringFormatParams<schemas.$ZodBase64, "pattern">;
export function _base64<T extends schemas.$ZodBase64>(
  Class: util.SchemaClass<T>,
  params?: string | $ZodBase64Params | $ZodCheckBase64Params
): T {
  return new Class({
    type: "string",
    format: "base64",
    check: "string_format",
    abort: false,
    ...util.normalizeParams(params),
  });
}

// base64url
export type $ZodBase64URLParams = StringFormatParams<schemas.$ZodBase64URL, "pattern">;
export type $ZodCheckBase64URLParams = CheckStringFormatParams<schemas.$ZodBase64URL, "pattern">;
export function _base64url<T extends schemas.$ZodBase64URL>(
  Class: util.SchemaClass<T>,
  params?: string | $ZodBase64URLParams | $ZodCheckBase64URLParams
): T {
  return new Class({
    type: "string",
    format: "base64url",
    check: "string_format",
    abort: false,
    ...util.normalizeParams(params),
  });
}

// E164
export type $ZodE164Params = StringFormatParams<schemas.$ZodE164>;
export type $ZodCheckE164Params = CheckStringFormatParams<schemas.$ZodE164>;
export function _e164<T extends schemas.$ZodE164>(
  Class: util.SchemaClass<T>,
  params?: string | $ZodE164Params | $ZodCheckE164Params
): T {
  return new Class({
    type: "string",
    format: "e164",
    check: "string_format",
    abort: false,
    ...util.normalizeParams(params),
  });
}

// JWT
export type $ZodJWTParams = StringFormatParams<schemas.$ZodJWT, "pattern">;
export type $ZodCheckJWTParams = CheckStringFormatParams<schemas.$ZodJWT, "pattern">;
export function _jwt<T extends schemas.$ZodJWT>(
  Class: util.SchemaClass<T>,
  params?: string | $ZodJWTParams | $ZodCheckJWTParams
): T {
  return new Class({
    type: "string",
    format: "jwt",
    check: "string_format",
    abort: false,
    ...util.normalizeParams(params),
  });
}

export const TimePrecision = {
  Any: null,
  Minute: -1,
  Second: 0,
  Millisecond: 3,
  Microsecond: 6,
} as const;
// ISODateTime
export type $ZodISODateTimeParams = StringFormatParams<schemas.$ZodISODateTime, "pattern">;
export type $ZodCheckISODateTimeParams = CheckStringFormatParams<schemas.$ZodISODateTime, "pattern">;
export function _isoDateTime<T extends schemas.$ZodISODateTime>(
  Class: util.SchemaClass<T>,
  params?: string | $ZodISODateTimeParams | $ZodCheckISODateTimeParams
): T {
  return new Class({
    type: "string",
    format: "datetime",
    check: "string_format",
    offset: false,
    local: false,
    precision: null,
    ...util.normalizeParams(params),
  });
}

// ISODate
export type $ZodISODateParams = StringFormatParams<schemas.$ZodISODate, "pattern">;
export type $ZodCheckISODateParams = CheckStringFormatParams<schemas.$ZodISODate, "pattern">;
export function _isoDate<T extends schemas.$ZodISODate>(
  Class: util.SchemaClass<T>,
  params?: string | $ZodISODateParams | $ZodCheckISODateParams
): T {
  return new Class({
    type: "string",
    format: "date",
    check: "string_format",
    ...util.normalizeParams(params),
  });
}

// ISOTime
export type $ZodISOTimeParams = StringFormatParams<schemas.$ZodISOTime, "pattern">;
export type $ZodCheckISOTimeParams = CheckStringFormatParams<schemas.$ZodISOTime, "pattern">;
export function _isoTime<T extends schemas.$ZodISOTime>(
  Class: util.SchemaClass<T>,
  params?: string | $ZodISOTimeParams | $ZodCheckISOTimeParams
): T {
  return new Class({
    type: "string",
    format: "time",
    check: "string_format",
    precision: null,
    ...util.normalizeParams(params),
  });
}

// ISODuration
export type $ZodISODurationParams = StringFormatParams<schemas.$ZodISODuration>;
export type $ZodCheckISODurationParams = CheckStringFormatParams<schemas.$ZodISODuration>;
export function _isoDuration<T extends schemas.$ZodISODuration>(
  Class: util.SchemaClass<T>,
  params?: string | $ZodISODurationParams | $ZodCheckISODurationParams
): T {
  return new Class({
    type: "string",
    format: "duration",
    check: "string_format",
    ...util.normalizeParams(params),
  });
}

// Number
export type $ZodNumberParams = TypeParams<schemas.$ZodNumber<number>, "coerce">;
export type $ZodNumberFormatParams = CheckTypeParams<schemas.$ZodNumberFormat, "format" | "coerce">;
export type $ZodCheckNumberFormatParams = CheckParams<checks.$ZodCheckNumberFormat, "format">;
export function _number<T extends schemas.$ZodNumber>(
  Class: util.SchemaClass<T>,
  params?: string | $ZodNumberParams
): T {
  return new Class({
    type: "number",
    checks: [],
    ...util.normalizeParams(params),
  });
}

export function _coercedNumber<T extends schemas.$ZodNumber>(
  Class: util.SchemaClass<T>,
  params?: string | $ZodNumberParams
): T {
  return new Class({
    type: "number",
    coerce: true,
    checks: [],
    ...util.normalizeParams(params),
  });
}

export function _int<T extends schemas.$ZodNumberFormat>(
  Class: util.SchemaClass<T>,
  params?: string | $ZodCheckNumberFormatParams
): T {
  return new Class({
    type: "number",
    check: "number_format",
    abort: false,
    format: "safeint",
    ...util.normalizeParams(params),
  });
}
export function _float32<T extends schemas.$ZodNumberFormat>(
  Class: util.SchemaClass<T>,
  params?: string | $ZodCheckNumberFormatParams
): T {
  return new Class({
    type: "number",
    check: "number_format",
    abort: false,
    format: "float32",
    ...util.normalizeParams(params),
  });
}
export function _float64<T extends schemas.$ZodNumberFormat>(
  Class: util.SchemaClass<T>,
  params?: string | $ZodCheckNumberFormatParams
): T {
  return new Class({
    type: "number",
    check: "number_format",
    abort: false,
    format: "float64",
    ...util.normalizeParams(params),
  });
}
export function _int32<T extends schemas.$ZodNumberFormat>(
  Class: util.SchemaClass<T>,
  params?: string | $ZodCheckNumberFormatParams
): T {
  return new Class({
    type: "number",
    check: "number_format",
    abort: false,
    format: "int32",
    ...util.normalizeParams(params),
  });
}
export function _uint32<T extends schemas.$ZodNumberFormat>(
  Class: util.SchemaClass<T>,
  params?: string | $ZodCheckNumberFormatParams
): T {
  return new Class({
    type: "number",
    check: "number_format",
    abort: false,
    format: "uint32",
    ...util.normalizeParams(params),
  });
}

// Boolean
export type $ZodBooleanParams = TypeParams<schemas.$ZodBoolean<boolean>, "coerce">;
export function _boolean<T extends schemas.$ZodBoolean>(
  Class: util.SchemaClass<T>,
  params?: string | $ZodBooleanParams
): T {
  return new Class({
    type: "boolean",
    ...util.normalizeParams(params),
  });
}
export function _coercedBoolean<T extends schemas.$ZodBoolean>(
  Class: util.SchemaClass<T>,
  params?: string | $ZodBooleanParams
): T {
  return new Class({
    type: "boolean",
    coerce: true,
    ...util.normalizeParams(params),
  });
}

// BigInt
export type $ZodBigIntParams = TypeParams<schemas.$ZodBigInt<bigint>>;
export type $ZodBigIntFormatParams = CheckTypeParams<schemas.$ZodBigIntFormat, "format" | "coerce">;
export type $ZodCheckBigIntFormatParams = CheckParams<checks.$ZodCheckBigIntFormat, "format">;
export function _bigint<T extends schemas.$ZodBigInt>(
  Class: util.SchemaClass<T>,
  params?: string | $ZodBigIntParams
): T {
  return new Class({
    type: "bigint",
    ...util.normalizeParams(params),
  });
}
export function _coercedBigint<T extends schemas.$ZodBigInt>(
  Class: util.SchemaClass<T>,
  params?: string | $ZodBigIntParams
): T {
  return new Class({
    type: "bigint",
    coerce: true,
    ...util.normalizeParams(params),
  });
}

export function _int64<T extends schemas.$ZodBigIntFormat>(
  Class: util.SchemaClass<T>,
  params?: string | $ZodBigIntFormatParams
): T {
  return new Class({
    type: "bigint",
    check: "bigint_format",
    abort: false,
    format: "int64",
    ...util.normalizeParams(params),
  });
}
export function _uint64<T extends schemas.$ZodBigIntFormat>(
  Class: util.SchemaClass<T>,
  params?: string | $ZodBigIntFormatParams
): T {
  return new Class({
    type: "bigint",
    check: "bigint_format",
    abort: false,
    format: "uint64",
    ...util.normalizeParams(params),
  });
}

// Symbol
export type $ZodSymbolParams = TypeParams<schemas.$ZodSymbol>;
export function _symbol<T extends schemas.$ZodSymbol>(
  Class: util.SchemaClass<T>,
  params?: string | $ZodSymbolParams
): T {
  return new Class({
    type: "symbol",
    ...util.normalizeParams(params),
  });
}

// Undefined
export type $ZodUndefinedParams = TypeParams<schemas.$ZodUndefined>;
export function _undefined<T extends schemas.$ZodUndefined>(
  Class: util.SchemaClass<T>,
  params?: string | $ZodUndefinedParams
): T {
  return new Class({
    type: "undefined",
    ...util.normalizeParams(params),
  });
}

// Null
export type $ZodNullParams = TypeParams<schemas.$ZodNull>;
export function _null<T extends schemas.$ZodNull>(Class: util.SchemaClass<T>, params?: string | $ZodNullParams): T {
  return new Class({
    type: "null",
    ...util.normalizeParams(params),
  });
}

// Any
export type $ZodAnyParams = TypeParams<schemas.$ZodAny>;
export function _any<T extends schemas.$ZodAny>(Class: util.SchemaClass<T>): T {
  return new Class({
    type: "any",
  });
}

// Unknown
export type $ZodUnknownParams = TypeParams<schemas.$ZodUnknown>;
export function _unknown<T extends schemas.$ZodUnknown>(Class: util.SchemaClass<T>): T {
  return new Class({
    type: "unknown",
  });
}

// Never
export type $ZodNeverParams = TypeParams<schemas.$ZodNever>;
export function _never<T extends schemas.$ZodNever>(Class: util.SchemaClass<T>, params?: string | $ZodNeverParams): T {
  return new Class({
    type: "never",
    ...util.normalizeParams(params),
  });
}

// Void
export type $ZodVoidParams = TypeParams<schemas.$ZodVoid>;
export function _void<T extends schemas.$ZodVoid>(Class: util.SchemaClass<T>, params?: string | $ZodVoidParams): T {
  return new Class({
    type: "void",
    ...util.normalizeParams(params),
  });
}

// Date
export type $ZodDateParams = TypeParams<schemas.$ZodDate, "coerce">;
export function _date<T extends schemas.$ZodDate>(Class: util.SchemaClass<T>, params?: string | $ZodDateParams): T {
  return new Class({
    type: "date",
    ...util.normalizeParams(params),
  });
}
export function _coercedDate<T extends schemas.$ZodDate>(
  Class: util.SchemaClass<T>,
  params?: string | $ZodDateParams
): T {
  return new Class({
    type: "date",
    coerce: true,
    ...util.normalizeParams(params),
  });
}

// NaN
export type $ZodNaNParams = TypeParams<schemas.$ZodNaN>;
export function _nan<T extends schemas.$ZodNaN>(Class: util.SchemaClass<T>, params?: string | $ZodNaNParams): T {
  return new Class({
    type: "nan",
    ...util.normalizeParams(params),
  });
}

// export type $ZodCheckParams = CheckParams<checks.$ZodCheck, "abort">;

export type $ZodCheckLessThanParams = CheckParams<checks.$ZodCheckLessThan, "inclusive" | "value">;
export function _lt(
  value: util.Numeric,
  params?: string | $ZodCheckLessThanParams
): checks.$ZodCheckLessThan<util.Numeric> {
  return new checks.$ZodCheckLessThan({
    check: "less_than",
    ...util.normalizeParams(params),
    value,
    inclusive: false,
  });
}

export function _lte(
  value: util.Numeric,
  params?: string | $ZodCheckLessThanParams
): checks.$ZodCheckLessThan<util.Numeric> {
  return new checks.$ZodCheckLessThan({
    check: "less_than",

    ...util.normalizeParams(params),
    value,
    inclusive: true,
  });
}
export {
  /** @deprecated Use `z.lte()` instead. */
  _lte as _max,
};

// ZodCheckGreaterThan
export type $ZodCheckGreaterThanParams = CheckParams<checks.$ZodCheckGreaterThan, "inclusive" | "value">;
export function _gt(value: util.Numeric, params?: string | $ZodCheckGreaterThanParams): checks.$ZodCheckGreaterThan {
  return new checks.$ZodCheckGreaterThan({
    check: "greater_than",

    ...util.normalizeParams(params),
    value,
    inclusive: false,
  });
}

export function _gte(value: util.Numeric, params?: string | $ZodCheckGreaterThanParams): checks.$ZodCheckGreaterThan {
  return new checks.$ZodCheckGreaterThan({
    check: "greater_than",
    ...util.normalizeParams(params),
    value,
    inclusive: true,
  });
}

export {
  /** @deprecated Use `z.gte()` instead. */
  _gte as _min,
};

export function _positive(params?: string | $ZodCheckGreaterThanParams): checks.$ZodCheckGreaterThan {
  return _gt(0, params);
}

// negative
export function _negative(params?: string | $ZodCheckLessThanParams): checks.$ZodCheckLessThan {
  return _lt(0, params);
}

// nonpositive
export function _nonpositive(params?: string | $ZodCheckLessThanParams): checks.$ZodCheckLessThan {
  return _lte(0, params);
}

// nonnegative
export function _nonnegative(params?: string | $ZodCheckGreaterThanParams): checks.$ZodCheckGreaterThan {
  return _gte(0, params);
}

export type $ZodCheckMultipleOfParams = CheckParams<checks.$ZodCheckMultipleOf, "value">;
export function _multipleOf(
  value: number | bigint,
  params?: string | $ZodCheckMultipleOfParams
): checks.$ZodCheckMultipleOf {
  return new checks.$ZodCheckMultipleOf({
    check: "multiple_of",
    ...util.normalizeParams(params),
    value,
  });
}

export type $ZodCheckMaxSizeParams = CheckParams<checks.$ZodCheckMaxSize, "maximum">;
export function _maxSize(
  maximum: number,
  params?: string | $ZodCheckMaxSizeParams
): checks.$ZodCheckMaxSize<util.HasSize> {
  return new checks.$ZodCheckMaxSize({
    check: "max_size",
    ...util.normalizeParams(params),
    maximum,
  });
}

export type $ZodCheckMinSizeParams = CheckParams<checks.$ZodCheckMinSize, "minimum">;
export function _minSize(
  minimum: number,
  params?: string | $ZodCheckMinSizeParams
): checks.$ZodCheckMinSize<util.HasSize> {
  return new checks.$ZodCheckMinSize({
    check: "min_size",
    ...util.normalizeParams(params),
    minimum,
  });
}

export type $ZodCheckSizeEqualsParams = CheckParams<checks.$ZodCheckSizeEquals, "size">;
export function _size(
  size: number,
  params?: string | $ZodCheckSizeEqualsParams
): checks.$ZodCheckSizeEquals<util.HasSize> {
  return new checks.$ZodCheckSizeEquals({
    check: "size_equals",
    ...util.normalizeParams(params),
    size,
  });
}

export type $ZodCheckMaxLengthParams = CheckParams<checks.$ZodCheckMaxLength, "maximum">;
export function _maxLength(
  maximum: number,
  params?: string | $ZodCheckMaxLengthParams
): checks.$ZodCheckMaxLength<util.HasLength> {
  const ch = new checks.$ZodCheckMaxLength({
    check: "max_length",
    ...util.normalizeParams(params),
    maximum,
  });
  return ch;
}

export type $ZodCheckMinLengthParams = CheckParams<checks.$ZodCheckMinLength, "minimum">;
export function _minLength(
  minimum: number,
  params?: string | $ZodCheckMinLengthParams
): checks.$ZodCheckMinLength<util.HasLength> {
  return new checks.$ZodCheckMinLength({
    check: "min_length",
    ...util.normalizeParams(params),
    minimum,
  });
}

export type $ZodCheckLengthEqualsParams = CheckParams<checks.$ZodCheckLengthEquals, "length">;
export function _length(
  length: number,
  params?: string | $ZodCheckLengthEqualsParams
): checks.$ZodCheckLengthEquals<util.HasLength> {
  return new checks.$ZodCheckLengthEquals({
    check: "length_equals",
    ...util.normalizeParams(params),
    length,
  });
}

export type $ZodCheckRegexParams = CheckParams<checks.$ZodCheckRegex, "format" | "pattern">;
export function _regex(pattern: RegExp, params?: string | $ZodCheckRegexParams): checks.$ZodCheckRegex {
  return new checks.$ZodCheckRegex({
    check: "string_format",
    format: "regex",
    ...util.normalizeParams(params),
    pattern,
  });
}

export type $ZodCheckLowerCaseParams = CheckParams<checks.$ZodCheckLowerCase, "format">;
export function _lowercase(params?: string | $ZodCheckLowerCaseParams): checks.$ZodCheckLowerCase {
  return new checks.$ZodCheckLowerCase({
    check: "string_format",
    format: "lowercase",
    ...util.normalizeParams(params),
  });
}

export type $ZodCheckUpperCaseParams = CheckParams<checks.$ZodCheckUpperCase, "format">;

export function _uppercase(params?: string | $ZodCheckUpperCaseParams): checks.$ZodCheckUpperCase {
  return new checks.$ZodCheckUpperCase({
    check: "string_format",
    format: "uppercase",
    ...util.normalizeParams(params),
  });
}

export type $ZodCheckIncludesParams = CheckParams<checks.$ZodCheckIncludes, "includes" | "format" | "pattern">;
export function _includes(includes: string, params?: string | $ZodCheckIncludesParams): checks.$ZodCheckIncludes {
  return new checks.$ZodCheckIncludes({
    check: "string_format",
    format: "includes",
    ...util.normalizeParams(params),
    includes,
  });
}
export type $ZodCheckStartsWithParams = CheckParams<checks.$ZodCheckStartsWith, "prefix" | "format" | "pattern">;
export function _startsWith(prefix: string, params?: string | $ZodCheckStartsWithParams): checks.$ZodCheckStartsWith {
  return new checks.$ZodCheckStartsWith({
    check: "string_format",
    format: "starts_with",
    ...util.normalizeParams(params),
    prefix,
  });
}

export type $ZodCheckEndsWithParams = CheckParams<checks.$ZodCheckEndsWith, "suffix" | "format" | "pattern">;

export function _endsWith(suffix: string, params?: string | $ZodCheckEndsWithParams): checks.$ZodCheckEndsWith {
  return new checks.$ZodCheckEndsWith({
    check: "string_format",
    format: "ends_with",
    ...util.normalizeParams(params),
    suffix,
  });
}

export type $ZodCheckPropertyParams = CheckParams<checks.$ZodCheckProperty, "property" | "schema">;
export function _property<K extends string, T extends schemas.$ZodType>(
  property: K,
  schema: T,
  params?: string | $ZodCheckPropertyParams
): checks.$ZodCheckProperty<{ [k in K]: core.output<T> }> {
  return new checks.$ZodCheckProperty({
    check: "property",
    property,
    schema,
    ...util.normalizeParams(params),
  });
}

export type $ZodCheckMimeTypeParams = CheckParams<checks.$ZodCheckMimeType, "mime">;
export function _mime(types: util.MimeTypes[], params?: string | $ZodCheckMimeTypeParams): checks.$ZodCheckMimeType {
  return new checks.$ZodCheckMimeType({
    check: "mime_type",
    mime: types,
    ...util.normalizeParams(params),
  });
}

export function _overwrite<T>(tx: (input: T) => T): checks.$ZodCheckOverwrite<T> {
  return new checks.$ZodCheckOverwrite({
    check: "overwrite",
    tx,
  }) as checks.$ZodCheckOverwrite<T>;
}
// normalize
export function _normalize(form?: "NFC" | "NFD" | "NFKC" | "NFKD" | (string & {})): checks.$ZodCheckOverwrite<string> {
  return _overwrite((input) => input.normalize(form));
}

// trim
export function _trim(): checks.$ZodCheckOverwrite<string> {
  return _overwrite((input) => input.trim());
}
// toLowerCase
export function _toLowerCase(): checks.$ZodCheckOverwrite<string> {
  return _overwrite((input) => input.toLowerCase());
}
// toUpperCase
export function _toUpperCase(): checks.$ZodCheckOverwrite<string> {
  return _overwrite((input) => input.toUpperCase());
}

///////  collections   ///////

// Array
export type $ZodArrayParams = TypeParams<schemas.$ZodArray, "element">;
export function _array<T extends schemas.$ZodType>(
  Class: util.SchemaClass<schemas.$ZodArray>,
  element: T,
  params?: string | $ZodArrayParams
): schemas.$ZodArray<T> {
  return new Class({
    type: "array",
    element,
    // get element() {
    //   return element;
    // },
    ...util.normalizeParams(params),
  }) as any;
}

export type $ZodObjectParams = TypeParams<schemas.$ZodObject, "shape" | "catchall">;

// ZodUnion
export type $ZodUnionParams = TypeParams<schemas.$ZodUnion, "options">;
export function _union<const T extends readonly schemas.$ZodObject[]>(
  Class: util.SchemaClass<schemas.$ZodUnion>,
  options: T,
  params?: string | $ZodUnionParams
): schemas.$ZodUnion<T> {
  return new Class({
    type: "union",
    options,
    ...util.normalizeParams(params),
  }) as any;
}

// ZodDiscriminatedUnion
export interface $ZodTypeDiscriminableInternals extends schemas.$ZodTypeInternals {
  propValues: util.PropValues;
}

export interface $ZodTypeDiscriminable extends schemas.$ZodType {
  _zod: $ZodTypeDiscriminableInternals;
}
export type $ZodDiscriminatedUnionParams = TypeParams<schemas.$ZodDiscriminatedUnion, "options" | "discriminator">;
export function _discriminatedUnion<Types extends [$ZodTypeDiscriminable, ...$ZodTypeDiscriminable[]]>(
  Class: util.SchemaClass<schemas.$ZodDiscriminatedUnion>,
  discriminator: string,
  options: Types,
  params?: string | $ZodDiscriminatedUnionParams
): schemas.$ZodDiscriminatedUnion<Types> {
  return new Class({
    type: "union",
    options,
    discriminator,
    ...util.normalizeParams(params),
  }) as any;
}

// ZodIntersection
export type $ZodIntersectionParams = TypeParams<schemas.$ZodIntersection, "left" | "right">;
export function _intersection<T extends schemas.$ZodObject, U extends schemas.$ZodObject>(
  Class: util.SchemaClass<schemas.$ZodIntersection>,
  left: T,
  right: U
): schemas.$ZodIntersection<T, U> {
  return new Class({
    type: "intersection",
    left,
    right,
  }) as any;
}

// ZodTuple
export type $ZodTupleParams = TypeParams<schemas.$ZodTuple, "items" | "rest">;
export function _tuple<T extends readonly [schemas.$ZodType, ...schemas.$ZodType[]]>(
  Class: util.SchemaClass<schemas.$ZodTuple>,
  items: T,
  params?: string | $ZodTupleParams
): schemas.$ZodTuple<T, null>;
export function _tuple<T extends readonly [schemas.$ZodType, ...schemas.$ZodType[]], Rest extends schemas.$ZodType>(
  Class: util.SchemaClass<schemas.$ZodTuple>,
  items: T,
  rest: Rest,
  params?: string | $ZodTupleParams
): schemas.$ZodTuple<T, Rest>;
// export function _tuple(
//   Class: util.SchemaClass<schemas.$ZodTuple>,
//   items: [],
//   params?: string | $ZodTupleParams
// ): schemas.$ZodTuple<[], null>;
export function _tuple(
  Class: util.SchemaClass<schemas.$ZodTuple>,
  items: schemas.$ZodType[],
  _paramsOrRest?: string | $ZodTupleParams | schemas.$ZodType,
  _params?: string | $ZodTupleParams
) {
  const hasRest = _paramsOrRest instanceof schemas.$ZodType;
  const params = hasRest ? _params : _paramsOrRest;
  const rest = hasRest ? _paramsOrRest : null;
  return new Class({
    type: "tuple",
    items,
    rest,
    ...util.normalizeParams(params),
  });
}

// ZodRecord
export type $ZodRecordParams = TypeParams<schemas.$ZodRecord, "keyType" | "valueType">;
export function _record<Key extends schemas.$ZodRecordKey, Value extends schemas.$ZodObject>(
  Class: util.SchemaClass<schemas.$ZodRecord>,
  keyType: Key,
  valueType: Value,
  params?: string | $ZodRecordParams
): schemas.$ZodRecord<Key, Value> {
  return new Class({
    type: "record",
    keyType,
    valueType,
    ...util.normalizeParams(params),
  }) as any;
}

// ZodMap
export type $ZodMapParams = TypeParams<schemas.$ZodMap, "keyType" | "valueType">;
export function _map<Key extends schemas.$ZodObject, Value extends schemas.$ZodObject>(
  Class: util.SchemaClass<schemas.$ZodMap>,
  keyType: Key,
  valueType: Value,
  params?: string | $ZodMapParams
): schemas.$ZodMap<Key, Value> {
  return new Class({
    type: "map",
    keyType,
    valueType,
    ...util.normalizeParams(params),
  }) as any;
}

// ZodSet
export type $ZodSetParams = TypeParams<schemas.$ZodSet, "valueType">;
export function _set<Value extends schemas.$ZodObject>(
  Class: util.SchemaClass<schemas.$ZodSet>,
  valueType: Value,
  params?: string | $ZodSetParams
): schemas.$ZodSet<Value> {
  return new Class({
    type: "set",
    valueType,
    ...util.normalizeParams(params),
  }) as any;
}

// ZodEnum
export type $ZodEnumParams = TypeParams<schemas.$ZodEnum, "entries">;
export function _enum<const T extends string[]>(
  Class: util.SchemaClass<schemas.$ZodEnum>,
  values: T,
  params?: string | $ZodEnumParams
): schemas.$ZodEnum<util.ToEnum<T[number]>>;
export function _enum<T extends util.EnumLike>(
  Class: util.SchemaClass<schemas.$ZodEnum>,
  entries: T,
  params?: string | $ZodEnumParams
): schemas.$ZodEnum<T>;
export function _enum(Class: util.SchemaClass<schemas.$ZodEnum>, values: any, params?: string | $ZodEnumParams) {
  const entries: any = Array.isArray(values) ? Object.fromEntries(values.map((v) => [v, v])) : values;
  // if (Array.isArray(values)) {
  //   for (const value of values) {
  //     entries[value] = value;
  //   }
  // } else {
  //   Object.assign(entries, values);
  // }
  // const entries: util.EnumLike = {};
  // for (const val of values) {
  //   entries[val] = val;
  // }

  return new Class({
    type: "enum",
    entries,
    ...util.normalizeParams(params),
  }) as any;
}

/** @deprecated This API has been merged into `z.enum()`. Use `z.enum()` instead.
 *
 * ```ts
 * enum Colors { red, green, blue }
 * z.enum(Colors);
 * ```
 */
export function _nativeEnum<T extends util.EnumLike>(
  Class: util.SchemaClass<schemas.$ZodEnum>,
  entries: T,
  params?: string | $ZodEnumParams
): schemas.$ZodEnum<T> {
  return new Class({
    type: "enum",
    entries,
    ...util.normalizeParams(params),
  }) as any;
}

// ZodLiteral
export type $ZodLiteralParams = TypeParams<schemas.$ZodLiteral, "values">;
export function _literal<const T extends Array<util.Literal>>(
  Class: util.SchemaClass<schemas.$ZodLiteral>,
  value: T,
  params?: string | $ZodLiteralParams
): schemas.$ZodLiteral<T[number]>;
export function _literal<const T extends util.Literal>(
  Class: util.SchemaClass<schemas.$ZodLiteral>,
  value: T,
  params?: string | $ZodLiteralParams
): schemas.$ZodLiteral<T>;
export function _literal(Class: util.SchemaClass<schemas.$ZodLiteral>, value: any, params: any) {
  return new Class({
    type: "literal",
    values: Array.isArray(value) ? value : [value],
    ...util.normalizeParams(params),
  });
}

// ZodFile
export type $ZodFileParams = TypeParams<schemas.$ZodFile>;
export function _file(Class: util.SchemaClass<schemas.$ZodFile>, params?: string | $ZodFileParams): schemas.$ZodFile {
  return new Class({
    type: "file",
    ...util.normalizeParams(params),
  });
}

// ZodTransform
export type $ZodTransformParams = TypeParams<schemas.$ZodTransform, "transform">;
export function _transform<I = unknown, O = I>(
  Class: util.SchemaClass<schemas.$ZodTransform>,
  fn: (input: I, ctx?: schemas.ParsePayload) => O
): schemas.$ZodTransform<Awaited<O>, I> {
  return new Class({
    type: "transform",
    transform: fn as any,
  }) as any;
}

// ZodOptional
export type $ZodOptionalParams = TypeParams<schemas.$ZodOptional, "innerType">;
export function _optional<T extends schemas.$ZodObject>(
  Class: util.SchemaClass<schemas.$ZodOptional>,
  innerType: T
): schemas.$ZodOptional<T> {
  return new Class({
    type: "optional",
    innerType,
  }) as any;
}

// ZodNullable
export type $ZodNullableParams = TypeParams<schemas.$ZodNullable, "innerType">;
export function _nullable<T extends schemas.$ZodObject>(
  Class: util.SchemaClass<schemas.$ZodNullable>,
  innerType: T
): schemas.$ZodNullable<T> {
  return new Class({
    type: "nullable",
    innerType,
  }) as any;
}

// ZodDefault
export type $ZodDefaultParams = TypeParams<schemas.$ZodDefault, "innerType" | "defaultValue">;
export function _default<T extends schemas.$ZodObject>(
  Class: util.SchemaClass<schemas.$ZodDefault>,
  innerType: T,
  defaultValue: util.NoUndefined<core.output<T>> | (() => util.NoUndefined<core.output<T>>)
): schemas.$ZodDefault<T> {
  return new Class({
    type: "default",
    innerType,
    get defaultValue() {
      return typeof defaultValue === "function" ? (defaultValue as Function)() : defaultValue;
    },
  }) as any;
}

// ZodNonOptional
export type $ZodNonOptionalParams = TypeParams<schemas.$ZodNonOptional, "innerType">;
export function _nonoptional<T extends schemas.$ZodObject>(
  Class: util.SchemaClass<schemas.$ZodNonOptional>,
  innerType: T,
  params?: string | $ZodNonOptionalParams
): schemas.$ZodNonOptional<T> {
  return new Class({
    type: "nonoptional",
    innerType,
    ...util.normalizeParams(params),
  }) as any;
}

// ZodSuccess
export type $ZodSuccessParams = TypeParams<schemas.$ZodSuccess, "innerType">;
export function _success<T extends schemas.$ZodObject>(
  Class: util.SchemaClass<schemas.$ZodSuccess>,
  innerType: T
): schemas.$ZodSuccess<T> {
  return new Class({
    type: "success",
    innerType,
  }) as any;
}

// ZodCatch
export type $ZodCatchParams = TypeParams<schemas.$ZodCatch, "innerType" | "catchValue">;
export function _catch<T extends schemas.$ZodObject>(
  Class: util.SchemaClass<schemas.$ZodCatch>,
  innerType: T,
  catchValue: core.output<T> | ((ctx: schemas.$ZodCatchCtx) => core.output<T>)
): schemas.$ZodCatch<T> {
  return new Class({
    type: "catch",
    innerType,
    catchValue: (typeof catchValue === "function" ? catchValue : () => catchValue) as any,
  }) as any;
}

// ZodPipe
export type $ZodPipeParams = TypeParams<schemas.$ZodPipe, "in" | "out">;
export function _pipe<
  const A extends schemas.$ZodType,
  B extends schemas.$ZodType<unknown, core.output<A>> = schemas.$ZodType<unknown, core.output<A>>,
>(
  Class: util.SchemaClass<schemas.$ZodPipe>,
  in_: A,
  out: B | schemas.$ZodType<unknown, core.output<A>>
): schemas.$ZodPipe<A, B> {
  return new Class({
    type: "pipe",
    in: in_,
    out,
  }) as any;
}

// ZodReadonly
export type $ZodReadonlyParams = TypeParams<schemas.$ZodReadonly, "innerType">;
export function _readonly<T extends schemas.$ZodObject>(
  Class: util.SchemaClass<schemas.$ZodReadonly>,
  innerType: T
): schemas.$ZodReadonly<T> {
  return new Class({
    type: "readonly",
    innerType,
  }) as any;
}

// ZodTemplateLiteral
export type $ZodTemplateLiteralParams = TypeParams<schemas.$ZodTemplateLiteral, "parts">;
export function _templateLiteral<const Parts extends schemas.$ZodTemplateLiteralPart[]>(
  Class: util.SchemaClass<schemas.$ZodTemplateLiteral>,
  parts: Parts,
  params?: string | $ZodTemplateLiteralParams
): schemas.$ZodTemplateLiteral<schemas.$PartsToTemplateLiteral<Parts>> {
  return new Class({
    type: "template_literal",
    parts,
    ...util.normalizeParams(params),
  }) as any;
}

// ZodLazy
export type $ZodLazyParams = TypeParams<schemas.$ZodLazy, "getter">;
export function _lazy<T extends schemas.$ZodType>(
  Class: util.SchemaClass<schemas.$ZodLazy>,
  getter: () => T
): schemas.$ZodLazy<T> {
  return new Class({
    type: "lazy",
    getter,
  }) as any;
}

// ZodPromise
export type $ZodPromiseParams = TypeParams<schemas.$ZodPromise, "innerType">;
export function _promise<T extends schemas.$ZodObject>(
  Class: util.SchemaClass<schemas.$ZodPromise>,
  innerType: T
): schemas.$ZodPromise<T> {
  return new Class({
    type: "promise",
    innerType,
  }) as any;
}

// ZodCustom
export type $ZodCustomParams = CheckTypeParams<schemas.$ZodCustom, "fn">;
export function _custom<O = unknown, I = O>(
  Class: util.SchemaClass<schemas.$ZodCustom>,
  fn: (data: O) => unknown,
  _params: string | $ZodCustomParams | undefined
): schemas.$ZodCustom<O, I> {
  const norm = util.normalizeParams(_params);
  norm.abort ??= true; // default to abort:false
  const schema = new Class({
    type: "custom",
    check: "custom",
    fn: fn as any,
    ...norm,
  });

  return schema as any;
}

// export function _refine<T>(
//   Class: util.SchemaClass<schemas.$ZodCustom>,
//   fn: (arg: NoInfer<T>) => util.MaybeAsync<unknown>,
//   _params: string | $ZodCustomParams = {}
// ): checks.$ZodCheck<T> {
//   return _custom(Class, fn, _params);
// }
// same as _custom but defaults to abort:false
export function _refine<O = unknown, I = O>(
  Class: util.SchemaClass<schemas.$ZodCustom>,
  fn: (data: O) => unknown,
  _params: string | $ZodCustomParams | undefined
): schemas.$ZodCustom<O, I> {
  const schema = new Class({
    type: "custom",
    check: "custom",
    fn: fn as any,
    ...util.normalizeParams(_params),
  });

  return schema as any;
}

// export type $ZodCustomParams = CheckTypeParams<schemas.$ZodCustom, "fn">

/////////    STRINGBOOL   /////////

// stringbool
export interface $ZodStringBoolParams extends TypeParams {
  truthy?: string[];
  falsy?: string[];
  /**
   * Options: `"sensitive"`, `"insensitive"`
   *
   * @default `"insensitive"`
   */
  case?: "sensitive" | "insensitive" | undefined;
}

export function _stringbool(
  Classes: {
    Pipe?: typeof schemas.$ZodPipe;
    Boolean?: typeof schemas.$ZodBoolean;
    Transform?: typeof schemas.$ZodTransform;
    String?: typeof schemas.$ZodString;
  },
  _params?: string | $ZodStringBoolParams
): schemas.$ZodPipe<
  schemas.$ZodPipe<schemas.$ZodString, schemas.$ZodTransform<boolean, string>>,
  schemas.$ZodBoolean<boolean>
> {
  const params = util.normalizeParams(_params);

  let truthyArray = params.truthy ?? ["true", "1", "yes", "on", "y", "enabled"];
  let falsyArray = params.falsy ?? ["false", "0", "no", "off", "n", "disabled"];
  if (params.case !== "sensitive") {
    truthyArray = truthyArray.map((v) => (typeof v === "string" ? v.toLowerCase() : v));
    falsyArray = falsyArray.map((v) => (typeof v === "string" ? v.toLowerCase() : v));
  }

  const truthySet = new Set(truthyArray);
  const falsySet = new Set(falsyArray);

  const _Pipe = Classes.Pipe ?? schemas.$ZodPipe;
  const _Boolean = Classes.Boolean ?? schemas.$ZodBoolean;
  const _String = Classes.String ?? schemas.$ZodString;
  const _Transform = Classes.Transform ?? schemas.$ZodTransform;

  const tx = new _Transform({
    type: "transform",
    transform: (input, payload: schemas.ParsePayload<unknown>) => {
      let data: string = input as string;
      if (params.case !== "sensitive") data = data.toLowerCase();
      if (truthySet.has(data)) {
        return true;
      } else if (falsySet.has(data)) {
        return false;
      } else {
        payload.issues.push({
          code: "invalid_value",
          expected: "stringbool",
          values: [...truthySet, ...falsySet],
          input: payload.value,
          inst: tx,
        });
        return {} as never;
      }
    },
    error: params.error,
  });
  // params.error;

  const innerPipe = new _Pipe({
    type: "pipe",
    in: new _String({ type: "string", error: params.error }),
    out: tx,
    error: params.error,
  });

  const outerPipe = new _Pipe({
    type: "pipe",
    in: innerPipe,
    out: new _Boolean({
      type: "boolean",
      error: params.error,
    }),
    error: params.error,
  });
  return outerPipe as any;
}

export function _stringFormat<Format extends string>(
  Class: typeof schemas.$ZodCustomStringFormat,
  format: Format,
  fnOrRegex: ((arg: string) => util.MaybeAsync<unknown>) | RegExp,
  _params: string | $ZodStringFormatParams = {}
): schemas.$ZodCustomStringFormat<Format> {
  const params = util.normalizeParams(_params);
  const def: schemas.$ZodCustomStringFormatDef = {
    ...util.normalizeParams(_params),
    check: "string_format",
    type: "string",
    format,
    fn: typeof fnOrRegex === "function" ? fnOrRegex : (val) => fnOrRegex.test(val),
    ...params,
  };
  if (fnOrRegex instanceof RegExp) {
    def.pattern = fnOrRegex;
  }

  const inst = new Class(def);
  return inst as any;
}

============================== END FILE ========================================

### AGENT (Windows .NET) ###
============================= BEGIN FILE =======================================
Path: C:\Users\Last Stop\Documents\Programming Projects\RemoteIQ V5\remoteiq-minimal-e2e\agent-windows\RemoteIQ.Agent\AgentConfig.cs
Name: AgentConfig.cs
-------------------------------------------------------------------------------// remoteiq-minimal-e2e/agent-windows/RemoteIQ.Agent/AgentConfig.cs
using Microsoft.Extensions.Configuration;

namespace RemoteIQ.Agent;

public sealed class AgentConfig
{
    public string ApiBase { get; init; } = "http://localhost:3001";
    public string EnrollmentSecret { get; init; } = "";

    public static AgentConfig From(IConfiguration cfg)
    {
        var section = cfg.GetSection("Agent");
        return new AgentConfig
        {
            ApiBase = section["ApiBase"] ?? "http://localhost:3001",
            EnrollmentSecret = section["EnrollmentSecret"] ?? ""
        };
    }
}

============================== END FILE ========================================
============================= BEGIN FILE =======================================
Path: C:\Users\Last Stop\Documents\Programming Projects\RemoteIQ V5\remoteiq-minimal-e2e\agent-windows\RemoteIQ.Agent\appsettings.json
Name: appsettings.json
-------------------------------------------------------------------------------{
  "Agent": {
    "ApiBase": "http://localhost:3001",
    "EnrollmentSecret": "N0x1sbo55!",
    "PollIntervalSeconds": 60,
    "InventoryIntervalMinutes": 30
  },
  "Logging": {
    "LogLevel": {
      "Default": "Information",
      "Microsoft": "Warning",
      "System": "Warning"
    }
  }
}
============================== END FILE ========================================
============================= BEGIN FILE =======================================
Path: C:\Users\Last Stop\Documents\Programming Projects\RemoteIQ V5\remoteiq-minimal-e2e\agent-windows\RemoteIQ.Agent\bin\Debug\net8.0-windows10.0.17763.0\win-x64\appsettings.json
Name: appsettings.json
-------------------------------------------------------------------------------{
  "Agent": {
    "ApiBase": "http://localhost:3001",
    "EnrollmentSecret": "N0x1sbo55!",
    "PollIntervalSeconds": 60,
    "InventoryIntervalMinutes": 30
  },
  "Logging": {
    "LogLevel": {
      "Default": "Information",
      "Microsoft": "Warning",
      "System": "Warning"
    }
  }
}
============================== END FILE ========================================
============================= BEGIN FILE =======================================
Path: C:\Users\Last Stop\Documents\Programming Projects\RemoteIQ V5\remoteiq-minimal-e2e\agent-windows\RemoteIQ.Agent\Models\Config.cs
Name: Config.cs
-------------------------------------------------------------------------------// remoteiq-minimal-e2e/agent-windows/RemoteIQ.Agent/Models/Config.cs
using Microsoft.Extensions.Configuration;

namespace RemoteIQ.Agent.Models;

public class AgentConfig
{
    public string ApiBase { get; set; } = "http://localhost:3001";
    public string EnrollmentSecret { get; set; } = "dev-secret";
    public int PollIntervalSeconds { get; set; } = 30;
    public int InventoryIntervalMinutes { get; set; } = 30;
    public int LogTailCount { get; set; } = 100;
    public bool AllowHttpOnLocalhost { get; set; } = true;
    public int TopNProcesses { get; set; } = 5;

    public static AgentConfig From(IConfiguration cfg)
    {
        var c = new AgentConfig();
        cfg.GetSection("Agent").Bind(c);

        // Env overrides
        c.ApiBase = Environment.GetEnvironmentVariable("AGENT_API_BASE") ?? c.ApiBase;
        c.EnrollmentSecret = Environment.GetEnvironmentVariable("ENROLLMENT_SECRET") ?? c.EnrollmentSecret;
        if (int.TryParse(Environment.GetEnvironmentVariable("AGENT_POLL_INTERVAL_SEC"), out var s)) c.PollIntervalSeconds = s;

        return c;
    }
}

============================== END FILE ========================================
============================= BEGIN FILE =======================================
Path: C:\Users\Last Stop\Documents\Programming Projects\RemoteIQ V5\remoteiq-minimal-e2e\agent-windows\RemoteIQ.Agent\Models\Contracts.cs
Name: Contracts.cs
-------------------------------------------------------------------------------// remoteiq-minimal-e2e/agent-windows/RemoteIQ.Agent/Models/Contracts.cs
using System;
using System.Collections.Generic;

namespace RemoteIQ.Agent.Models
{
    // ----- Enrollment -----
    // Backend expects: { enrollmentSecret, deviceId, hostname, os, arch, version }
    public record EnrollRequest(
        string EnrollmentSecret,
        string DeviceId,
        string Hostname,
        string Os,
        string Arch,
        string Version
    );

    public record EnrollResponse(
        string AgentId,
        string AgentToken,
        DateTime? RotateAfter
    );

    // ----- Ping (facts) -----
    // Sent by agent to /api/agent/ping (auth via Agent token)
    public record PingRequest(
        string? Os,
        string? Arch,
        string? Version,
        string? PrimaryIp,
        string? User
    );

    // ====== Legacy / future types (kept for later features) ======

    // OS/Agent info shapes you might reuse later for richer inventory
    public record OsInfo(string Family, string Edition, string Version, string Build, string Arch);
    public record AgentInfo(string Version, string Platform);

    // Optional: earlier heartbeat/inventory/metrics/logs contracts.
    // Safe to keep; they’re not used by the current flow.
    public record HeartbeatRequest(
        string AgentId,
        long UptimeSec,
        List<string> IpAddrs,
        string? LastInventoryHash,
        string AgentVersion
    );

    public record InventoryRequest(
        string AgentId,
        Hardware Hardware,
        OsInfo Os,
        Network Network,
        List<SoftwareItem> Software,
        List<ServiceItem> Services,
        List<ProcessItem> Processes
    );

    public record MetricsRequest(
        string AgentId,
        DateTime SampleTs,
        double CpuPct,
        double MemPct,
        Dictionary<string, double> DiskPct,
        List<TopProcess> TopProcesses
    );

    public record LogsRequest(
        string AgentId,
        string Source,
        string Level,
        List<LogEvent> Events
    );

    public record JobFetchResponse(
        string JobId,
        string Type,
        int TimeoutSec,
        string Command
    );

    public record JobResultRequest(
        string Status,
        int ExitCode,
        string Stdout,
        string Stderr
    );

    // ----- Inventory subtypes -----
    public record Hardware(
        Cpu Cpu,
        long RamBytes,
        List<Disk> Disks,
        List<Gpu> Gpu,
        Motherboard Motherboard,
        Bios Bios
    );
    public record Cpu(string Model, int Cores, int LogicalCpus);
    public record Disk(string Name, long SizeBytes, string Type);
    public record Gpu(string Name, string? DriverVersion);
    public record Motherboard(string Manufacturer, string Product);
    public record Bios(string Vendor, string Version, string? Date);

    public record Network(List<NetIf> Interfaces);
    public record NetIf(string Name, string Mac, List<string> Ipv4, List<string> Ipv6, string? Gateway, List<string> Dns);

    public record SoftwareItem(string DisplayName, string? Version, string? Publisher, string? InstallDate);
    public record ServiceItem(string Name, string DisplayName, string Status, string StartType);
    public record ProcessItem(int Pid, string Name, double CpuPct, long MemBytes);

    // ----- Metrics / Logs -----
    public record TopProcess(int Pid, string Name, double CpuPct, long MemBytes);
    public record LogEvent(int EventId, string Provider, DateTime Time, string Message);
}

============================== END FILE ========================================
============================= BEGIN FILE =======================================
Path: C:\Users\Last Stop\Documents\Programming Projects\RemoteIQ V5\remoteiq-minimal-e2e\agent-windows\RemoteIQ.Agent\Models\Fingerprint.cs
Name: Fingerprint.cs
-------------------------------------------------------------------------------// remoteiq-minimal-e2e/agent-windows/RemoteIQ.Agent/Models/Fingerprint.cs
using System;
using System.Collections.Generic;
using System.Linq;
using System.Management;
using System.Net.NetworkInformation;
using System.Runtime.InteropServices;
using System.Security.Cryptography;
using System.Text;

namespace RemoteIQ.Agent.Models
{
    /// <summary>
    /// Builds a stable machine fingerprint and basic platform facts
    /// without referencing OsInfo/AgentInfo.
    /// </summary>
    public static class Fingerprint
    {
        /// <summary>
        /// Returns (deviceId, hostname, os, arch).
        /// os:   "windows" | "linux" | "macos" (we hardcode "windows" here)
        /// arch: "x64" | "arm64" | "x86"
        /// </summary>
        public static (string deviceId, string hostname, string os, string arch) Build()
        {
            string hostname = Environment.MachineName;
            string os = "windows";
            string arch = MapArch(RuntimeInformation.ProcessArchitecture);

            var parts = new List<string>
            {
                hostname,
                GetBiosSerial(),
                string.Join(",", GetMacs())
            };

            var raw = string.Join("|", parts.Where(p => !string.IsNullOrWhiteSpace(p)));
            using var sha = SHA256.Create();
            var deviceId = Convert.ToHexString(sha.ComputeHash(Encoding.UTF8.GetBytes(raw))).ToLowerInvariant();

            return (deviceId, hostname, os, arch);
        }

        private static string GetBiosSerial()
        {
            try
            {
                using var mos = new ManagementObjectSearcher("SELECT SerialNumber FROM Win32_BIOS");
                foreach (ManagementObject mo in mos.Get())
                    return mo["SerialNumber"]?.ToString() ?? "";
            }
            catch { }
            return "";
        }

        private static IEnumerable<string> GetMacs()
        {
            try
            {
                return NetworkInterface.GetAllNetworkInterfaces()
                    .Where(n => n.NetworkInterfaceType != NetworkInterfaceType.Loopback &&
                                n.OperationalStatus == OperationalStatus.Up)
                    .Select(n => n.GetPhysicalAddress()?.ToString())
                    .Where(s => !string.IsNullOrWhiteSpace(s))!;
            }
            catch
            {
                return Array.Empty<string>();
            }
        }

        private static string MapArch(Architecture arch) => arch switch
        {
            Architecture.X64 => "x64",
            Architecture.Arm64 => "arm64",
            Architecture.X86 => "x86",
            _ => "x64"
        };
    }
}

============================== END FILE ========================================
============================= BEGIN FILE =======================================
Path: C:\Users\Last Stop\Documents\Programming Projects\RemoteIQ V5\remoteiq-minimal-e2e\agent-windows\RemoteIQ.Agent\Models\InstalledApp.cs
Name: InstalledApp.cs
-------------------------------------------------------------------------------//remoteiq-minimal-e2e\agent-windows\RemoteIQ.Agent\Models\InstalledApp.cs

namespace RemoteIQ.Agent.Models
{
    public record InstalledApp(
        string DisplayName,
        string? Version,
        string? Publisher,
        string? InstallDate
    );
}

============================== END FILE ========================================
============================= BEGIN FILE =======================================
Path: C:\Users\Last Stop\Documents\Programming Projects\RemoteIQ V5\remoteiq-minimal-e2e\agent-windows\RemoteIQ.Agent\Options\AgentOptions.cs
Name: AgentOptions.cs
-------------------------------------------------------------------------------// remoteiq-minimal-e2e/agent-windows/RemoteIQ.Agent/Options/AgentOptions.cs
namespace RemoteIQ.Agent.Options;

public sealed class AgentOptions
{
    public string ApiBase { get; set; } = "http://localhost:3001";
    public string EnrollmentSecret { get; set; } = "";
    public int PollIntervalSeconds { get; set; } = 60;
    public int InventoryIntervalMinutes { get; set; } = 30;
}

============================== END FILE ========================================
============================= BEGIN FILE =======================================
Path: C:\Users\Last Stop\Documents\Programming Projects\RemoteIQ V5\remoteiq-minimal-e2e\agent-windows\RemoteIQ.Agent\Program.cs
Name: Program.cs
-------------------------------------------------------------------------------// remoteiq-minimal-e2e/agent-windows/RemoteIQ.Agent/Program.cs
using System;
using System.IO;
using System.Net.Http;
using Microsoft.Extensions.Configuration;
using Microsoft.Extensions.Configuration.Binder; // for .Bind(...)
using Microsoft.Extensions.DependencyInjection;
using Microsoft.Extensions.Hosting;
using Microsoft.Extensions.Logging;
using Microsoft.Extensions.Logging.EventLog; // explicit (Windows Event Log)
using RemoteIQ.Agent;
using RemoteIQ.Agent.Options;
using RemoteIQ.Agent.Services;
using RemoteIQ.Agent.Services.Http;
using RemoteIQ.Agent.Services.Security;
using RemoteIQ.Agent.Services.Update;

Directory.SetCurrentDirectory(AppContext.BaseDirectory);

var builder = Host.CreateApplicationBuilder(args);

// ----- Configuration (appsettings.json + env) -----
builder.Configuration
    .AddJsonFile("appsettings.json", optional: true, reloadOnChange: true)
    .AddJsonFile($"appsettings.{builder.Environment.EnvironmentName}.json", optional: true, reloadOnChange: true)
    .AddEnvironmentVariables();

// ----- Logging -----
builder.Logging.ClearProviders();
// Console for interactive runs
builder.Logging.AddSimpleConsole(o =>
{
    o.SingleLine = true;
    o.TimestampFormat = "yyyy-MM-dd HH:mm:ss ";
});

// EventLog only when running as a Windows Service (avoids admin during dev)
if (!Environment.UserInteractive)
{
    builder.Logging.AddEventLog(o =>
    {
        o.SourceName = "RemoteIQ Agent";
        o.LogName = "Application";
    });
}

// (optional) Graceful shutdown window for background services
builder.Services.Configure<HostOptions>(o => o.ShutdownTimeout = TimeSpan.FromSeconds(15));

// ----- Windows Service support -----
builder.Services.AddWindowsService(options => options.ServiceName = "RemoteIQ Agent");

// ----- Options binding WITHOUT Options.ConfigurationExtensions -----
// Bind into a concrete POCO and register it as a singleton.
// (No IOptions<T> required anywhere.)
var agentOptions = new AgentOptions();
builder.Configuration.GetSection("Agent").Bind(agentOptions);
builder.Services.AddSingleton(agentOptions);

// ----- Resolve API base (env > config > default) -----
var apiBase =
    builder.Configuration["NEXT_PUBLIC_API_BASE"] ??
    builder.Configuration["Agent:ApiBase"] ??
    agentOptions.ApiBase ??
    "http://localhost:3001";

if (!Uri.TryCreate(apiBase, UriKind.Absolute, out var apiUri))
{
    apiUri = new Uri("http://localhost:3001");
}
Console.WriteLine($"[Startup] Agent API base: {apiUri}");

// ----- Typed HttpClient for ApiClient -----
builder.Services.AddHttpClient<ApiClient>(client =>
{
    client.BaseAddress = apiUri;
    client.Timeout = TimeSpan.FromSeconds(30);
})
.ConfigurePrimaryHttpMessageHandler(() =>
{
    var handler = new HttpClientHandler
    {
        ServerCertificateCustomValidationCallback = (req, cert, chain, errors) =>
        {
            var uri = req?.RequestUri;
            if (uri is null) return false;

            // Dev convenience ONLY: allow http://localhost/*
            if (uri.Scheme == Uri.UriSchemeHttp &&
                (uri.Host.Equals("localhost", StringComparison.OrdinalIgnoreCase) ||
                 uri.Host.Equals("127.0.0.1")))
            {
                return true;
            }

            // For HTTPS, require a clean chain
            return errors == System.Net.Security.SslPolicyErrors.None &&
                   uri.Scheme == Uri.UriSchemeHttps;
        }
    };
    return handler;
});

// ----- Core services -----
builder.Services.AddSingleton<TokenStore>();
builder.Services.AddSingleton<Updater>();
builder.Services.AddSingleton<EnrollmentClient>();
builder.Services.AddSingleton<WebSocketClient>();

// Background service that drives the agent loops
builder.Services.AddHostedService<AgentService>();

await builder.Build().RunAsync();

============================== END FILE ========================================
============================= BEGIN FILE =======================================
Path: C:\Users\Last Stop\Documents\Programming Projects\RemoteIQ V5\remoteiq-minimal-e2e\agent-windows\RemoteIQ.Agent\Services\AgentService.cs
Name: AgentService.cs
-------------------------------------------------------------------------------// remoteiq-minimal-e2e/agent-windows/RemoteIQ.Agent/Services/AgentService.cs
using Microsoft.Extensions.Hosting;
using Microsoft.Extensions.Logging;
using Microsoft.Extensions.Options;
using RemoteIQ.Agent.Models;
using RemoteIQ.Agent.Options;
using RemoteIQ.Agent.Services.Http;
using RemoteIQ.Agent.Services.Security;
using System.Net;
using System.Net.NetworkInformation;
using System.Net.Sockets;
using System.Runtime.InteropServices;
using System.Security.Principal;
using System.Threading;
using System.Threading.Tasks;
using System.Management;
using RemoteIQ.Agent.Services.Collectors;
using System;
using System.Linq;

namespace RemoteIQ.Agent.Services;

public class AgentService : BackgroundService
{
    private readonly ILogger<AgentService> _log;
    private readonly ApiClient _api;
    private readonly TokenStore _tokenStore;
    private readonly EnrollmentClient _enrollment;
    private readonly WebSocketClient _ws;
    private readonly AgentOptions _options;

    public AgentService(
        ILogger<AgentService> log,
        ApiClient api,
        TokenStore tokenStore,
        EnrollmentClient enrollment,
        WebSocketClient ws,
        IOptions<AgentOptions> options)
    {
        _log = log;
        _api = api;
        _tokenStore = tokenStore;
        _enrollment = enrollment;
        _ws = ws;
        _options = options.Value;
    }

    protected override async Task ExecuteAsync(CancellationToken stoppingToken)
    {
        _log.LogInformation("Agent starting…");

        // ✅ Enroll with required parameters: os, arch, version, hostname, ct
        var os = GetOsName();
        var arch = GetArch();
        var version = GetAgentVersion();
        var hostname = Environment.MachineName;
        await _enrollment.EnrollAsync(os, arch, version, hostname, stoppingToken);

        var tokenData = _tokenStore.Load();
        if (tokenData is null || string.IsNullOrWhiteSpace(tokenData.AgentToken) || tokenData.AgentId is null || tokenData.DeviceId is null)
        {
            _log.LogError("Enrollment/token missing after EnrollAsync. Agent cannot continue.");
            return;
        }

        _api.SetBearer(tokenData.AgentToken);

        try { await _ws.StartAsync(stoppingToken); } catch { /* non-fatal */ }

        var seconds = _options.PollIntervalSeconds > 0 ? _options.PollIntervalSeconds : 60;
        var period = TimeSpan.FromSeconds(seconds);
        using var timer = new PeriodicTimer(period);
        _log.LogInformation("Heartbeat every {Seconds}s", seconds);

        await SendPingOnce(stoppingToken);

        // One-shot software upload after first ping (best-effort)
        _ = Task.Run(() => SendSoftwareOnce(stoppingToken), stoppingToken);

        while (await timer.WaitForNextTickAsync(stoppingToken))
        {
            await SendPingOnce(stoppingToken);

            // Roughly hourly software refresh
            if (DateTimeOffset.UtcNow.Minute == 0)
                _ = Task.Run(() => SendSoftwareOnce(stoppingToken), stoppingToken);
        }
    }

    private async Task SendPingOnce(CancellationToken ct)
    {
        try
        {
            var os = GetOsName();
            var arch = GetArch();
            var version = GetAgentVersion();
            var primaryIp = GetPrimaryIPv4();
            var user = GetInteractiveUserViaWmi()
                       ?? GetLoggedInUserInteractive()
                       ?? GetLoggedInUserServiceContext();

            await _api.PingAsync(new PingRequest(
                Os: os,
                Arch: arch,
                Version: version,
                PrimaryIp: primaryIp,
                User: user
            ), ct);

            _log.LogDebug("Ping OK (os={Os} arch={Arch} ver={Ver} ip={Ip} user={User})",
                os, arch, version, primaryIp, user);
        }
        catch (OperationCanceledException) { }
        catch (HttpRequestException ex)
        {
            _log.LogWarning(ex, "Ping HTTP error.");
        }
        catch (Exception ex)
        {
            _log.LogError(ex, "Ping failed.");
        }
    }

    private async Task SendSoftwareOnce(CancellationToken ct)
    {
        try
        {
            var items = SoftwareCollector.Collect();
            if (items.Count == 0) return;

            await _api.SubmitSoftwareAsync(items, ct);
            _log.LogInformation("Uploaded {Count} software rows.", items.Count);
        }
        catch (OperationCanceledException) { }
        catch (HttpRequestException ex)
        {
            _log.LogWarning(ex, "Software upload HTTP error.");
        }
        catch (Exception ex)
        {
            _log.LogError(ex, "Software upload failed.");
        }
    }

    private static string GetOsName()
        => RuntimeInformation.IsOSPlatform(OSPlatform.Windows) ? "windows"
         : RuntimeInformation.IsOSPlatform(OSPlatform.Linux) ? "linux"
         : RuntimeInformation.IsOSPlatform(OSPlatform.OSX) ? "macos"
         : "unknown";

    private static string GetArch()
        => RuntimeInformation.OSArchitecture switch
        {
            Architecture.X64 => "x64",
            Architecture.X86 => "x86",
            Architecture.Arm64 => "arm64",
            _ => RuntimeInformation.OSArchitecture.ToString().ToLowerInvariant()
        };

    private static string GetAgentVersion()
    {
        try
        {
            return System.Reflection.Assembly.GetExecutingAssembly().GetName().Version?.ToString() ?? "1.0.0";
        }
        catch { return "1.0.0"; }
    }

    private static string? GetPrimaryIPv4()
    {
        try
        {
            foreach (var ni in NetworkInterface.GetAllNetworkInterfaces())
            {
                if (ni.OperationalStatus != OperationalStatus.Up) continue;
                var ipProps = ni.GetIPProperties();
                foreach (var ua in ipProps.UnicastAddresses)
                {
                    if (ua.Address.AddressFamily != AddressFamily.InterNetwork) continue;
                    var s = ua.Address.ToString();
                    if (IsPrivateIPv4(s)) return s;
                }
            }

            foreach (var addr in Dns.GetHostAddresses(Dns.GetHostName()))
            {
                if (addr.AddressFamily == AddressFamily.InterNetwork) return addr.ToString();
            }
        }
        catch { }
        return null;

        static bool IsPrivateIPv4(string ip)
        {
            if (IPAddress.TryParse(ip, out var addr))
            {
                var b = addr.GetAddressBytes();
                if (b[0] == 10) return true;
                if (b[0] == 172 && b[1] >= 16 && b[1] <= 31) return true;
                if (b[0] == 192 && b[1] == 168) return true;
            }
            return false;
        }
    }

    private static string? GetInteractiveUserViaWmi()
    {
        if (!RuntimeInformation.IsOSPlatform(OSPlatform.Windows))
            return null;

        try
        {
            using var cls = new ManagementClass("Win32_ComputerSystem");
            using var instances = cls.GetInstances();
            foreach (ManagementObject mo in instances)
            {
                var user = (mo["UserName"] as string)?.Trim();
                if (!string.IsNullOrWhiteSpace(user))
                    return user;
            }
        }
        catch { }
        return null;
    }

    private static string? GetLoggedInUserInteractive()
    {
        if (!RuntimeInformation.IsOSPlatform(OSPlatform.Windows))
            return null;

        try
        {
            uint sessionId = WTSGetActiveConsoleSessionId();
            if (sessionId == 0xFFFFFFFF) return null;

            if (!WTSQuerySessionInformation(IntPtr.Zero, sessionId, WTS_INFO_CLASS.WTSUserName, out var userPtr, out _)
                || userPtr == IntPtr.Zero) return null;

            try
            {
                var user = Marshal.PtrToStringUni(userPtr)?.Trim();
                if (string.IsNullOrWhiteSpace(user)) return null;

                string? domain = null;
                if (WTSQuerySessionInformation(IntPtr.Zero, sessionId, WTS_INFO_CLASS.WTSDomainName, out var domPtr, out _)
                    && domPtr != IntPtr.Zero)
                {
                    try { domain = Marshal.PtrToStringUni(domPtr)?.Trim(); }
                    finally { WTSFreeMemory(domPtr); }
                }

                return string.IsNullOrWhiteSpace(domain) ? user : $"{domain}\\{user}";
            }
            finally
            {
                WTSFreeMemory(userPtr);
            }
        }
        catch
        {
            return null;
        }
    }

    private static string GetLoggedInUserServiceContext()
    {
        try
        {
            using var wi = WindowsIdentity.GetCurrent();
            return wi?.Name ?? Environment.UserName;
        }
        catch
        {
            return Environment.UserName;
        }
    }

    public override async Task StopAsync(CancellationToken cancellationToken)
    {
        try { await _ws.DisposeAsync(); } catch { }
        await base.StopAsync(cancellationToken);
    }

    private enum WTS_INFO_CLASS
    {
        WTSInitialProgram = 0,
        WTSApplicationName = 1,
        WTSWorkingDirectory = 2,
        WTSOEMId = 3,
        WTSSessionId = 4,
        WTSUserName = 5,
        WTSWinStationName = 6,
        WTSDomainName = 7,
        WTSConnectState = 8,
        WTSClientBuildNumber = 9,
        WTSClientName = 10,
        WTSClientDirectory = 11,
        WTSClientProductId = 12,
        WTSClientHardwareId = 13,
        WTSClientAddress = 14,
        WTSClientDisplay = 15,
        WTSClientProtocolType = 16
    }

    [DllImport("wtsapi32.dll", CharSet = CharSet.Unicode, SetLastError = true)]
    private static extern bool WTSQuerySessionInformation(
        IntPtr hServer,
        uint sessionId,
        WTS_INFO_CLASS wtsInfoClass,
        out IntPtr ppBuffer,
        out int pBytesReturned);

    [DllImport("wtsapi32.dll")]
    private static extern void WTSFreeMemory(IntPtr pMemory);

    [DllImport("kernel32.dll")]
    private static extern uint WTSGetActiveConsoleSessionId();
}

============================== END FILE ========================================
============================= BEGIN FILE =======================================
Path: C:\Users\Last Stop\Documents\Programming Projects\RemoteIQ V5\remoteiq-minimal-e2e\agent-windows\RemoteIQ.Agent\Services\Collectors\InventoryCollector.cs
Name: InventoryCollector.cs
-------------------------------------------------------------------------------// remoteiq-minimal-e2e/agent-windows/RemoteIQ.Agent/Services/Collectors/InventoryCollector.cs
using System;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using System.Management;
using RemoteIQ.Agent.Models;

namespace RemoteIQ.Agent.Services.Collectors
{
    public class InventoryCollector
    {
        public (Hardware hw, Network net, List<SoftwareItem> sw, List<ServiceItem> svcs, List<ProcessItem> procs) Collect(int topN = 5)
        {
            var hw = GetHardware();
            var net = GetNetwork();
            var sw = GetSoftware();
            var svcs = GetServices();
            var procs = GetProcesses(topN);
            return (hw, net, sw, svcs, procs);
        }

        static Hardware GetHardware()
        {
            var cpu = new Cpu(GetCpuName(), GetCoreCount(), Environment.ProcessorCount);
            long ram = GetTotalRam();
            var disks = GetDisks();
            var gpus = GetGpus();
            var mobo = GetMotherboard();
            var bios = GetBios();
            return new Hardware(cpu, ram, disks, gpus, mobo, bios);
        }

        static string GetCpuName()
        {
            try
            {
                using var mos = new ManagementObjectSearcher("select Name from Win32_Processor");
                foreach (ManagementObject mo in mos.Get()) return mo["Name"]?.ToString() ?? "";
            }
            catch { }
            return "";
        }

        static int GetCoreCount()
        {
            try
            {
                using var mos = new ManagementObjectSearcher("select NumberOfCores from Win32_Processor");
                foreach (ManagementObject mo in mos.Get()) return Convert.ToInt32(mo["NumberOfCores"] ?? 0);
            }
            catch { }
            return Environment.ProcessorCount;
        }

        static long GetTotalRam()
        {
            try
            {
                using var mos = new ManagementObjectSearcher("select TotalVisibleMemorySize from Win32_OperatingSystem");
                foreach (ManagementObject mo in mos.Get())
                {
                    var kb = Convert.ToInt64(mo["TotalVisibleMemorySize"] ?? 0);
                    return kb * 1024;
                }
            }
            catch { }
            return 0;
        }

        static List<Disk> GetDisks()
        {
            var list = new List<Disk>();
            try
            {
                using var mos = new ManagementObjectSearcher("select Name,Size,MediaType from Win32_DiskDrive");
                foreach (ManagementObject mo in mos.Get())
                {
                    var name = mo["Name"]?.ToString() ?? "";
                    var size = Convert.ToInt64(mo["Size"] ?? 0);
                    var type = mo["MediaType"]?.ToString() ?? "";
                    list.Add(new Disk(name, size, type));
                }
            }
            catch { }
            return list;
        }

        static List<Gpu> GetGpus()
        {
            var list = new List<Gpu>();
            try
            {
                using var mos = new ManagementObjectSearcher("select Name,DriverVersion from Win32_VideoController");
                foreach (ManagementObject mo in mos.Get())
                    list.Add(new Gpu(mo["Name"]?.ToString() ?? "", mo["DriverVersion"]?.ToString()));
            }
            catch { }
            return list;
        }

        static Motherboard GetMotherboard()
        {
            try
            {
                using var mos = new ManagementObjectSearcher("select Manufacturer,Product from Win32_BaseBoard");
                foreach (ManagementObject mo in mos.Get())
                    return new Motherboard(mo["Manufacturer"]?.ToString() ?? "", mo["Product"]?.ToString() ?? "");
            }
            catch { }
            return new Motherboard("", "");
        }

        static Bios GetBios()
        {
            try
            {
                using var mos = new ManagementObjectSearcher("select Manufacturer,SMBIOSBIOSVersion,ReleaseDate from Win32_BIOS");
                foreach (ManagementObject mo in mos.Get())
                    return new Bios(mo["Manufacturer"]?.ToString() ?? "", mo["SMBIOSBIOSVersion"]?.ToString() ?? "", mo["ReleaseDate"]?.ToString());
            }
            catch { }
            return new Bios("", "", null);
        }

        static Network GetNetwork()
        {
            var list = new List<NetIf>();
            try
            {
                using var mos = new ManagementObjectSearcher(
                    "select Description,MACAddress,IPEnabled,IPAddress,DefaultIPGateway,DNSServerSearchOrder from Win32_NetworkAdapterConfiguration where IPEnabled = true");
                foreach (ManagementObject mo in mos.Get())
                {
                    var name = mo["Description"]?.ToString() ?? "Adapter";
                    var mac = mo["MACAddress"]?.ToString() ?? "";

                    var ips = mo["IPAddress"] as string[] ?? Array.Empty<string>();
                    var ipv4 = ips.Where(ip => ip != null && ip.Contains('.')).ToList();
                    var ipv6 = ips.Where(ip => ip != null && ip.Contains(':')).ToList();

                    var gw = (mo["DefaultIPGateway"] as string[] ?? Array.Empty<string>()).FirstOrDefault();
                    var dns = (mo["DNSServerSearchOrder"] as string[] ?? Array.Empty<string>()).ToList();

                    list.Add(new NetIf(name, mac, ipv4, ipv6, gw, dns));
                }
            }
            catch { }
            return new Network(list);
        }

        static List<SoftwareItem> GetSoftware()
        {
            var list = new List<SoftwareItem>();
            try
            {
                var roots = new[] {
                    Microsoft.Win32.Registry.LocalMachine.OpenSubKey(@"SOFTWARE\Microsoft\Windows\CurrentVersion\Uninstall"),
                    Microsoft.Win32.Registry.LocalMachine.OpenSubKey(@"SOFTWARE\WOW6432Node\Microsoft\Windows\CurrentVersion\Uninstall")
                };
                foreach (var root in roots.Where(r => r != null)!)
                {
                    foreach (var keyName in root!.GetSubKeyNames())
                    {
                        using var k = root.OpenSubKey(keyName);
                        var name = k?.GetValue("DisplayName")?.ToString();
                        if (string.IsNullOrWhiteSpace(name)) continue;
                        var ver = k?.GetValue("DisplayVersion")?.ToString();
                        var pub = k?.GetValue("Publisher")?.ToString();
                        var dt = k?.GetValue("InstallDate")?.ToString();
                        list.Add(new SoftwareItem(name!, ver, pub, dt));
                    }
                }
            }
            catch { }
            return list;
        }

        static List<ServiceItem> GetServices()
        {
            var list = new List<ServiceItem>();
            try
            {
                foreach (var sc in System.ServiceProcess.ServiceController.GetServices())
                {
                    string startType = "Unknown";
                    try
                    {
                        using var mos = new ManagementObjectSearcher(
                            $"select StartMode,DisplayName,Name from Win32_Service where Name='{sc.ServiceName.Replace("'", "''")}'");
                        foreach (ManagementObject mo in mos.Get())
                            startType = mo["StartMode"]?.ToString() ?? "Unknown";
                    }
                    catch { }
                    list.Add(new ServiceItem(sc.ServiceName, sc.DisplayName, sc.Status.ToString(), startType));
                }
            }
            catch { }
            return list;
        }

        static List<ProcessItem> GetProcesses(int topN)
        {
            var list = new List<ProcessItem>();
            try
            {
                foreach (var p in System.Diagnostics.Process.GetProcesses())
                {
                    long mem = 0;
                    try { mem = p.WorkingSet64; } catch { }
                    list.Add(new ProcessItem(p.Id, p.ProcessName + ".exe", 0, mem));
                }
                // Keep more than topN so server can choose what to display
                list = list.OrderByDescending(x => x.MemBytes).Take(Math.Max(10, topN * 3)).ToList();
            }
            catch { }
            return list;
        }
    }
}

============================== END FILE ========================================
============================= BEGIN FILE =======================================
Path: C:\Users\Last Stop\Documents\Programming Projects\RemoteIQ V5\remoteiq-minimal-e2e\agent-windows\RemoteIQ.Agent\Services\Collectors\MetricsCollector.cs
Name: MetricsCollector.cs
-------------------------------------------------------------------------------using System.Diagnostics;
using RemoteIQ.Agent.Models;
using System.Management; // <-- ADDED THIS
using System.Linq; // <-- ADDED THIS

namespace RemoteIQ.Agent.Services.Collectors;

public class MetricsCollector
{
    public (double cpuPct, double memPct, Dictionary<string, double> diskPct, List<TopProcess> tops) Sample(int topN = 5)
    {
        double cpu = GetCpuUsagePct();
        double mem = GetMemPct();
        var disk = GetDiskPct();
        var tops = GetTopProcesses(topN);
        return (cpu, mem, disk, tops);
    }

    static double GetCpuUsagePct()
    {
        try
        {
            using var cpu = new PerformanceCounter("Processor", "% Processor Time", "_Total");
            _ = cpu.NextValue();
            Thread.Sleep(500);
            return Math.Round(cpu.NextValue(), 1);
        }
        catch { return 0; }
    }

    // --- THIS METHOD IS UPDATED ---
    static double GetMemPct()
    {
        try
        {
            // Use WMI (System.Management) instead of VisualBasic
            using var searcher = new ManagementObjectSearcher("SELECT TotalVisibleMemorySize, FreePhysicalMemory FROM Win32_OperatingSystem");
            using var collection = searcher.Get();
            using var mem = collection.Cast<ManagementObject>().First();

            var totalMemKb = (ulong)mem["TotalVisibleMemorySize"];
            var freeMemKb = (ulong)mem["FreePhysicalMemory"];
            var usedMemKb = totalMemKb - freeMemKb;

            if (totalMemKb == 0) return 0; // Avoid divide by zero

            return Math.Round(100.0 * usedMemKb / totalMemKb, 1);
        }
        catch { return 0; }
    }

    static Dictionary<string, double> GetDiskPct()
    {
        var dict = new Dictionary<string, double>();
        try
        {
            foreach (var di in DriveInfo.GetDrives().Where(d => d.IsReady && d.DriveType == DriveType.Fixed))
            {
                var used = di.TotalSize - di.AvailableFreeSpace;
                var pct = 100.0 * used / Math.Max(1, (double)di.TotalSize);
                dict[di.Name.TrimEnd('\\')] = Math.Round(pct, 1);
            }
        }
        catch { }
        return dict;
    }

    static List<TopProcess> GetTopProcesses(int topN)
    {
        try
        {
            var list = Process.GetProcesses()
                .Select(p =>
                {
                    long mem = 0;
                    try { mem = p.WorkingSet64; } catch { }
                    return new { p.Id, p.ProcessName, Mem = mem };
                })
                .OrderByDescending(x => x.Mem)
                .Take(topN)
                .Select(x => new TopProcess(x.Id, x.ProcessName + ".exe", 0, x.Mem))
                .ToList();
            return list;
        }
        catch { return new List<TopProcess>(); }
    }
}
============================== END FILE ========================================
============================= BEGIN FILE =======================================
Path: C:\Users\Last Stop\Documents\Programming Projects\RemoteIQ V5\remoteiq-minimal-e2e\agent-windows\RemoteIQ.Agent\Services\Collectors\SoftwareCollector.cs
Name: SoftwareCollector.cs
-------------------------------------------------------------------------------//remoteiq-minimal-e2e\agent-windows\RemoteIQ.Agent\Services\Collectors\SoftwareCollector.cs

using Microsoft.Win32;
using RemoteIQ.Agent.Models;
using System;
using System.Collections.Generic;

namespace RemoteIQ.Agent.Services.Collectors
{
    public static class SoftwareCollector
    {
        public static List<InstalledApp> Collect()
        {
            var list = new List<InstalledApp>();
            try
            {
                ReadUninstall(RegistryHive.LocalMachine, RegistryView.Registry64, list);
                ReadUninstall(RegistryHive.LocalMachine, RegistryView.Registry32, list);
            }
            catch { /* ignore */ }

            var seen = new HashSet<string>(StringComparer.OrdinalIgnoreCase);
            var dedup = new List<InstalledApp>();
            foreach (var s in list)
            {
                if (string.IsNullOrWhiteSpace(s.DisplayName)) continue;
                var key = $"{s.DisplayName}|{s.Version}";
                if (seen.Add(key)) dedup.Add(s);
            }
            return dedup;
        }

        private static void ReadUninstall(RegistryHive hive, RegistryView view, List<InstalledApp> output)
        {
            using var baseKey = RegistryKey.OpenBaseKey(hive, view);
            using var uninstall = baseKey.OpenSubKey(@"SOFTWARE\Microsoft\Windows\CurrentVersion\Uninstall");
            if (uninstall == null) return;

            foreach (var sub in uninstall.GetSubKeyNames())
            {
                using var k = uninstall.OpenSubKey(sub);
                if (k == null) continue;

                var name = (k.GetValue("DisplayName") as string)?.Trim();
                if (string.IsNullOrWhiteSpace(name)) continue;

                var version = (k.GetValue("DisplayVersion") as string)?.Trim();
                var publisher = (k.GetValue("Publisher") as string)?.Trim();

                string? installDate = (k.GetValue("InstallDate") as string)?.Trim();
                installDate = NormalizeInstallDate(installDate);

                output.Add(new InstalledApp(
                    DisplayName: name,
                    Version: string.IsNullOrWhiteSpace(version) ? null : version,
                    Publisher: string.IsNullOrWhiteSpace(publisher) ? null : publisher,
                    InstallDate: string.IsNullOrWhiteSpace(installDate) ? null : installDate
                ));
            }
        }

        private static string? NormalizeInstallDate(string? raw)
        {
            if (string.IsNullOrWhiteSpace(raw)) return null;

            if (raw.Length == 8 && int.TryParse(raw, out _))
                return $"{raw[..4]}-{raw.Substring(4, 2)}-{raw.Substring(6, 2)}";

            if (DateTime.TryParse(raw, out var dt))
                return dt.ToString("yyyy-MM-dd");

            return null;
        }
    }
}

============================== END FILE ========================================
============================= BEGIN FILE =======================================
Path: C:\Users\Last Stop\Documents\Programming Projects\RemoteIQ V5\remoteiq-minimal-e2e\agent-windows\RemoteIQ.Agent\Services\EnrollmentClient.cs
Name: EnrollmentClient.cs
-------------------------------------------------------------------------------using System.Net.Http.Json;
using System.Text.Json;
using Microsoft.Extensions.Configuration;
using Microsoft.Extensions.Logging;
using Microsoft.Win32;
using RemoteIQ.Agent.Models;             // AgentConfig.From(...)
using RemoteIQ.Agent.Services.Security;  // TokenStore
using System.Runtime.InteropServices;

namespace RemoteIQ.Agent.Services;

public class EnrollmentClient
{
    private readonly ILogger<EnrollmentClient> _log;
    private readonly IConfiguration _cfg;
    private readonly TokenStore _tokenStore;

    public EnrollmentClient(ILogger<EnrollmentClient> log, IConfiguration cfg, TokenStore tokenStore)
    {
        _log = log;
        _cfg = cfg;
        _tokenStore = tokenStore;
    }

    public async Task EnrollAsync(
        string os,
        string arch,
        string version,
        string hostname,
        CancellationToken ct)
    {
        var baseUrl = AgentConfig.From(_cfg).ApiBase.TrimEnd('/');

        var enrollmentSecret = _cfg["Agent:EnrollmentSecret"] ?? _cfg["EnrollmentSecret"] ?? "";
        if (string.IsNullOrWhiteSpace(enrollmentSecret))
            throw new InvalidOperationException("Missing Agent:EnrollmentSecret in configuration.");

        var deviceId = _cfg["Agent:DeviceId"] ?? DeriveDeviceId(hostname);
        if (string.IsNullOrWhiteSpace(deviceId))
            throw new InvalidOperationException("Unable to resolve a deviceId.");

        if (deviceId.Length > 200) deviceId = deviceId[..200];
        if (enrollmentSecret.Length > 200) enrollmentSecret = enrollmentSecret[..200];

        var candidates = new[]
        {
            $"{baseUrl}/api/agents/enroll",
            $"{baseUrl}/api/agent/enroll",
            $"{baseUrl}/api/auth/agents/enroll",
        };

        var payload = new
        {
            deviceId,
            enrollmentSecret,
            hostname,
            os,
            arch,
            version
        };

        Exception? lastErr = null;
        using var http = new HttpClient() { Timeout = TimeSpan.FromSeconds(20) };

        foreach (var url in candidates)
        {
            try
            {
                _log.LogInformation(
                    "Enrolling device {Host} (os={Os} arch={Arch} ver={Ver}) via {Url}",
                    hostname, os, arch, version, url);

                using var res = await http.PostAsJsonAsync(url, payload, ct);

                if ((int)res.StatusCode == 404)
                {
                    _log.LogDebug("Enroll endpoint {Url} returned 404; trying next candidate.", url);
                    continue;
                }

                var text = await res.Content.ReadAsStringAsync(ct);
                if (!res.IsSuccessStatusCode)
                    throw new InvalidOperationException($"Enrollment failed ( {(int)res.StatusCode} ): {text}");

                var (token, agentIdStr, deviceIdStr) = ParseEnrollResponse(text);
                if (string.IsNullOrWhiteSpace(token))
                    throw new InvalidOperationException("Enrollment succeeded but no agent token was returned.");

                _tokenStore.Save(new TokenStore.TokenData
                {
                    AgentToken = token,
                    AgentId = agentIdStr,
                    DeviceId = deviceIdStr ?? deviceId, // fall back to our request deviceId
                    RotateAfter = DateTime.UtcNow.AddDays(7)
                });

                _log.LogInformation("Enrolled as agentId={AgentId} deviceId={DeviceId}", agentIdStr, deviceIdStr);
                return;
            }
            catch (Exception ex)
            {
                lastErr = ex;
                _log.LogDebug(ex, "Enroll attempt failed.");
            }
        }

        throw new InvalidOperationException(
            $"Enrollment failed: {lastErr?.Message ?? "no enroll endpoint responded successfully"}",
            lastErr
        );
    }

    private static (string token, string? agentIdStr, string? deviceIdStr) ParseEnrollResponse(string json)
    {
        using var doc = JsonDocument.Parse(json);
        var root = doc.RootElement;

        string? token = TryString(root, "agentToken")
                        ?? TryString(root, "token")
                        ?? TryString(root, "accessToken");

        string? agentIdStr = TryString(root, "agentId")
                             ?? TryNumberAsString(root, "agentId")
                             ?? TryNestedNumberAsString(root, "agent", "id")
                             ?? TryNestedString(root, "agent", "id");

        string? deviceIdStr = TryString(root, "deviceId")
                              ?? TryNumberAsString(root, "deviceId")
                              ?? TryNestedNumberAsString(root, "device", "id")
                              ?? TryNestedString(root, "device", "id");

        return (token ?? "", agentIdStr, deviceIdStr);

        static string? TryString(JsonElement el, string key)
            => el.TryGetProperty(key, out var p) && p.ValueKind == JsonValueKind.String ? p.GetString() : null;

        static string? TryNumberAsString(JsonElement el, string key)
        {
            if (el.TryGetProperty(key, out var p) && p.ValueKind == JsonValueKind.Number && p.TryGetInt64(out var n))
                return n.ToString();
            return null;
        }

        static string? TryNestedNumberAsString(JsonElement el, string objKey, string innerKey)
        {
            if (el.TryGetProperty(objKey, out var obj) && obj.ValueKind == JsonValueKind.Object)
            {
                if (obj.TryGetProperty(innerKey, out var p))
                {
                    if (p.ValueKind == JsonValueKind.Number && p.TryGetInt64(out var n)) return n.ToString();
                    if (p.ValueKind == JsonValueKind.String) return p.GetString();
                }
            }
            return null;
        }

        static string? TryNestedString(JsonElement el, string objKey, string innerKey)
        {
            if (el.TryGetProperty(objKey, out var obj) && obj.ValueKind == JsonValueKind.Object)
            {
                if (obj.TryGetProperty(innerKey, out var p) && p.ValueKind == JsonValueKind.String)
                    return p.GetString();
            }
            return null;
        }
    }

    private static string DeriveDeviceId(string hostname)
    {
        if (RuntimeInformation.IsOSPlatform(OSPlatform.Windows))
        {
            try
            {
                using var key = Registry.LocalMachine.OpenSubKey(@"SOFTWARE\Microsoft\Cryptography");
                var mg = key?.GetValue("MachineGuid") as string;
                if (!string.IsNullOrWhiteSpace(mg)) return $"win-{mg}";
            }
            catch { /* ignore */ }
        }
        return hostname;
    }
}

============================== END FILE ========================================
============================= BEGIN FILE =======================================
Path: C:\Users\Last Stop\Documents\Programming Projects\RemoteIQ V5\remoteiq-minimal-e2e\agent-windows\RemoteIQ.Agent\Services\Http\ApiClient.cs
Name: ApiClient.cs
-------------------------------------------------------------------------------// remoteiq-minimal-e2e/agent-windows/RemoteIQ.Agent/Services/Http/ApiClient.cs
using System;
using System.Linq;
using System.Net.Http;
using System.Net.Http.Headers;
using System.Text;
using System.Text.Json;
using System.Threading;
using System.Threading.Tasks;
using RemoteIQ.Agent.Models;

namespace RemoteIQ.Agent.Services.Http
{
    public sealed class ApiClient
    {
        private readonly HttpClient _http;
        private readonly JsonSerializerOptions _json;

        public readonly struct VoidType { }

        public ApiClient(HttpClient http)
        {
            _http = http;
            _json = new JsonSerializerOptions
            {
                PropertyNamingPolicy = JsonNamingPolicy.CamelCase,
                PropertyNameCaseInsensitive = true,
                WriteIndented = false
            };

            _http.DefaultRequestHeaders.Accept.Clear();
            _http.DefaultRequestHeaders.Accept.Add(new MediaTypeWithQualityHeaderValue("application/json"));
        }

        public void SetBearer(string? token)
        {
            _http.DefaultRequestHeaders.Authorization =
                string.IsNullOrWhiteSpace(token) ? null : new AuthenticationHeaderValue("Bearer", token);
        }

        // ---------- Health & Enrollment ----------
        public async Task<bool> HealthAsync(CancellationToken ct = default)
        {
            using var res = await _http.GetAsync("/healthz", ct).ConfigureAwait(false);
            return res.IsSuccessStatusCode;
        }

        public async Task<EnrollResponse> EnrollAsync(EnrollRequest body, CancellationToken ct = default)
            => await PostJsonAsync<EnrollRequest, EnrollResponse>("/api/agent/enroll", body, ct).ConfigureAwait(false);

        // ---------- Ping with facts ----------
        public async Task<VoidType> PingAsync(PingRequest body, CancellationToken ct = default)
            => await PostJsonAsync<PingRequest, VoidType>("/api/agent/ping", body, ct).ConfigureAwait(false);

        // ---------- Software inventory ----------
        public async Task<VoidType> SubmitSoftwareAsync(System.Collections.Generic.IEnumerable<InstalledApp> items, CancellationToken ct = default)
        {
            var payload = new
            {
                items = items?.Select(s => new
                {
                    name = s.DisplayName,
                    version = s.Version,
                    publisher = s.Publisher,
                    installDate = s.InstallDate
                }).ToArray() ?? Array.Empty<object>()
            };

            return await PostJsonAsync<object, VoidType>("/api/agent/software", payload, ct).ConfigureAwait(false);
        }

        // ---------- Generic helpers ----------
        public async Task<T> GetJsonAsync<T>(string path, CancellationToken ct = default)
        {
            using var res = await _http.GetAsync(path, ct).ConfigureAwait(false);
            await EnsureOk(res, ct).ConfigureAwait(false);
            if (typeof(T) == typeof(VoidType)) return default!;
            await using var s = await res.Content.ReadAsStreamAsync(ct).ConfigureAwait(false);
            return (await JsonSerializer.DeserializeAsync<T>(s, _json, ct).ConfigureAwait(false))!;
        }

        public async Task<TResponse> PostJsonAsync<TRequest, TResponse>(string path, TRequest body, CancellationToken ct = default)
        {
            var content = new StringContent(JsonSerializer.Serialize(body, _json), Encoding.UTF8, "application/json");
            using var res = await _http.PostAsync(path, content, ct).ConfigureAwait(false);
            await EnsureOk(res, ct).ConfigureAwait(false);
            if (typeof(TResponse) == typeof(VoidType)) return default!;
            await using var s = await res.Content.ReadAsStreamAsync(ct).ConfigureAwait(false);
            return (await JsonSerializer.DeserializeAsync<TResponse>(s, _json, ct).ConfigureAwait(false))!;
        }

        public async Task<TResponse> PostNoBodyAsync<TResponse>(string path, CancellationToken ct = default)
        {
            using var res = await _http.PostAsync(path, content: null, ct).ConfigureAwait(false);
            await EnsureOk(res, ct).ConfigureAwait(false);
            if (typeof(TResponse) == typeof(VoidType)) return default!;
            await using var s = await res.Content.ReadAsStreamAsync(ct).ConfigureAwait(false);
            return (await JsonSerializer.DeserializeAsync<TResponse>(s, _json, ct).ConfigureAwait(false))!;
        }

        public async Task DeleteAsync(string path, CancellationToken ct = default)
        {
            using var res = await _http.DeleteAsync(path, ct).ConfigureAwait(false);
            await EnsureOk(res, ct).ConfigureAwait(false);
        }

        internal static async Task EnsureOk(HttpResponseMessage res, CancellationToken ct)
        {
            if (res.IsSuccessStatusCode) return;
            string body;
            try { body = await res.Content.ReadAsStringAsync(ct).ConfigureAwait(false); }
            catch { body = "<no body>"; }
            var status = (int)res.StatusCode;
            var reason = res.ReasonPhrase ?? "Unknown";
            throw new HttpRequestException($"HTTP {status} {reason}: {body}");
        }
    }
}

============================== END FILE ========================================
============================= BEGIN FILE =======================================
Path: C:\Users\Last Stop\Documents\Programming Projects\RemoteIQ V5\remoteiq-minimal-e2e\agent-windows\RemoteIQ.Agent\Services\Jobs\CommandRunner.cs
Name: CommandRunner.cs
-------------------------------------------------------------------------------// remoteiq-minimal-e2e/agent-windows/RemoteIQ.Agent/Services/Jobs/CommandRunner.cs
using System.Diagnostics;
using System.Text;

namespace RemoteIQ.Agent.Services.Jobs;

public static class CommandRunner
{
    public static async Task<(int exitCode, string stdout, string stderr)> RunAsync(string command, TimeSpan timeout, CancellationToken ct)
    {
        var psi = new ProcessStartInfo
        {
            FileName = "cmd.exe",
            Arguments = "/c " + command,
            UseShellExecute = false,
            RedirectStandardOutput = true,
            RedirectStandardError = true,
            CreateNoWindow = true,
            WorkingDirectory = Environment.SystemDirectory
        };

        using var proc = new Process { StartInfo = psi, EnableRaisingEvents = true };
        var sbOut = new StringBuilder();
        var sbErr = new StringBuilder();
        var tcs = new TaskCompletionSource<int>(TaskCreationOptions.RunContinuationsAsynchronously);

        proc.OutputDataReceived += (s, e) => { if (e.Data != null) sbOut.AppendLine(e.Data); };
        proc.ErrorDataReceived += (s, e) => { if (e.Data != null) sbErr.AppendLine(e.Data); };
        proc.Exited += (s, e) => { try { tcs.TrySetResult(proc.ExitCode); } catch { } };

        if (!proc.Start()) throw new InvalidOperationException("Failed to start process");
        proc.BeginOutputReadLine();
        proc.BeginErrorReadLine();

        using var cts = CancellationTokenSource.CreateLinkedTokenSource(ct);
        cts.CancelAfter(timeout);

        try
        {
            var exit = await tcs.Task.WaitAsync(cts.Token);
            return (exit, sbOut.ToString(), sbErr.ToString());
        }
        catch (OperationCanceledException)
        {
            try { if (!proc.HasExited) proc.Kill(true); } catch { }
            return (-1, sbOut.ToString(), sbErr.ToString());
        }
    }
}

============================== END FILE ========================================
============================= BEGIN FILE =======================================
Path: C:\Users\Last Stop\Documents\Programming Projects\RemoteIQ V5\remoteiq-minimal-e2e\agent-windows\RemoteIQ.Agent\Services\Logger.cs
Name: Logger.cs
-------------------------------------------------------------------------------using System.IO;

namespace RemoteIQ.Agent.Services;

public static class Logger
{
    private static readonly object _lock = new();
    private static readonly string LogDir = Path.Combine(Environment.GetFolderPath(Environment.SpecialFolder.CommonApplicationData), "RemoteIQ");
    private static readonly string LogFile = Path.Combine(LogDir, "agent.log");

    public static void Info(string msg) => Write("INFO", msg);
    public static void Warn(string msg) => Write("WARN", msg);
    public static void Error(string msg) => Write("ERROR", msg);

    private static void Write(string level, string msg)
    {
        lock (_lock)
        {
            Directory.CreateDirectory(LogDir);
            File.AppendAllText(LogFile, $"{DateTime.UtcNow:o} [{level}] {msg}\n");
        }
    }
}
============================== END FILE ========================================
============================= BEGIN FILE =======================================
Path: C:\Users\Last Stop\Documents\Programming Projects\RemoteIQ V5\remoteiq-minimal-e2e\agent-windows\RemoteIQ.Agent\Services\ProcessRunner.cs
Name: ProcessRunner.cs
-------------------------------------------------------------------------------using System.Diagnostics;
using System.Text;

namespace RemoteIQ.Agent.Services;

public static class ProcessRunner
{
    public sealed record Result(int ExitCode, string Stdout, string Stderr, int DurationMs);

    public static async Task<Result> RunPowerShellAsync(
        string scriptText, string[] args, IDictionary<string, string> env, int timeoutSec, CancellationToken ct)
    {
        // Write script to a temp file (ASCII-safe)
        var scriptPath = Path.Combine(Path.GetTempPath(), $"riq_{Guid.NewGuid():N}.ps1");
        await File.WriteAllTextAsync(scriptPath, scriptText, new UTF8Encoding(false), ct);

        try
        {
            // Build args
            var psi = new ProcessStartInfo
            {
                FileName = "powershell.exe",
                Arguments = BuildPsArgs(scriptPath, args),
                UseShellExecute = false,
                RedirectStandardOutput = true,
                RedirectStandardError = true,
                CreateNoWindow = true
            };

            // Inject env
            foreach (var kv in env)
                psi.Environment[kv.Key] = kv.Value;

            var sw = Stopwatch.StartNew();
            using var proc = new Process { StartInfo = psi };
            var stdout = new StringBuilder();
            var stderr = new StringBuilder();

            var tcsOut = new TaskCompletionSource<object?>();
            var tcsErr = new TaskCompletionSource<object?>();

            proc.OutputDataReceived += (_, e) =>
            {
                if (e.Data is null) tcsOut.TrySetResult(null);
                else stdout.AppendLine(e.Data);
            };
            proc.ErrorDataReceived += (_, e) =>
            {
                if (e.Data is null) tcsErr.TrySetResult(null);
                else stderr.AppendLine(e.Data);
            };

            proc.Start();
            proc.BeginOutputReadLine();
            proc.BeginErrorReadLine();

            using var timeoutCts = CancellationTokenSource.CreateLinkedTokenSource(ct);
            timeoutCts.CancelAfter(TimeSpan.FromSeconds(Math.Max(1, timeoutSec)));

            try
            {
                await Task.WhenAny(Task.Run(() => proc.WaitForExit(), timeoutCts.Token), Task.Delay(-1, timeoutCts.Token));
            }
            catch (OperationCanceledException) { /* timeout or external cancel */ }

            if (!proc.HasExited)
            {
                try { proc.Kill(entireProcessTree: true); } catch { }
                return new Result(-1, stdout.ToString(), "Timeout", (int)sw.ElapsedMilliseconds);
            }

            // ensure async readers finished
            await Task.WhenAll(tcsOut.Task.TaskOrCompleted(), tcsErr.Task.TaskOrCompleted());
            return new Result(proc.ExitCode, stdout.ToString(), stderr.ToString(), (int)sw.ElapsedMilliseconds);
        }
        finally
        {
            try { File.Delete(scriptPath); } catch { }
        }
    }

    private static string BuildPsArgs(string scriptPath, string[] args)
    {
        // -NoLogo -NoProfile -ExecutionPolicy Bypass -File "<script>" [args...]
        var quoted = args.Select(a => $"\"{a.Replace("\"", "\\\"")}\"");
        return $"-NoLogo -NoProfile -ExecutionPolicy Bypass -File \"{scriptPath}\" {string.Join(' ', quoted)}";
    }

    private static Task TaskOrCompleted(this Task t) => t.IsCompleted ? Task.CompletedTask : t;
}

============================== END FILE ========================================
============================= BEGIN FILE =======================================
Path: C:\Users\Last Stop\Documents\Programming Projects\RemoteIQ V5\remoteiq-minimal-e2e\agent-windows\RemoteIQ.Agent\Services\ScriptRunner.cs
Name: ScriptRunner.cs
-------------------------------------------------------------------------------using System.Diagnostics;
using System.Text;

namespace RemoteIQ.Agent.Services;

public static class ScriptRunner
{
    /// <summary>
    /// Executes PowerShell scriptText with args/env. Writes script as UTF-8 **with BOM**
    /// so Unicode (em dash, smart quotes) is preserved on Windows PowerShell.
    /// Truncates stdout/stderr to maxOutputBytes (default 1MB).
    /// </summary>
    public static async Task<(int exitCode, string stdout, string stderr, int durationMs, bool timedOut)> RunPowerShellAsync(
        string scriptText,
        IEnumerable<string>? args,
        IDictionary<string, string>? env,
        int timeoutSec,
        int maxOutputBytes = 1_000_000,
        CancellationToken ct = default)
    {
        var sw = Stopwatch.StartNew();
        var tempPath = Path.Combine(Path.GetTempPath(), $"riq_{Guid.NewGuid():N}.ps1");
        var utf8Bom = new UTF8Encoding(encoderShouldEmitUTF8Identifier: true);

        await File.WriteAllTextAsync(tempPath, scriptText ?? string.Empty, utf8Bom, ct);

        try
        {
            var psi = new ProcessStartInfo
            {
                FileName = "powershell.exe",
                Arguments = $"-NoProfile -ExecutionPolicy Bypass -File \"{tempPath}\" {BuildArgs(args)}",
                RedirectStandardOutput = true,
                RedirectStandardError = true,
                UseShellExecute = false,
                CreateNoWindow = true
            };

            if (env != null)
            {
                foreach (var kv in env)
                    if (!string.IsNullOrWhiteSpace(kv.Key))
                        psi.Environment[kv.Key] = kv.Value ?? string.Empty;
            }

            using var proc = new Process { StartInfo = psi, EnableRaisingEvents = true };

            var stdout = new LimitedBuffer(maxOutputBytes);
            var stderr = new LimitedBuffer(maxOutputBytes);

            proc.OutputDataReceived += (_, e) => { if (e.Data != null) stdout.AppendLine(e.Data); };
            proc.ErrorDataReceived += (_, e) => { if (e.Data != null) stderr.AppendLine(e.Data); };

            proc.Start();
            proc.BeginOutputReadLine();
            proc.BeginErrorReadLine();

            var timeout = TimeSpan.FromSeconds(timeoutSec > 0 ? timeoutSec : 120);
            var exited = await Task.Run(() => proc.WaitForExit((int)timeout.TotalMilliseconds), ct);
            if (!exited)
            {
                TryKill(proc);
                return (124, stdout.ToStringWithTruncationNote(), "timeout", (int)sw.ElapsedMilliseconds, true);
            }

            proc.WaitForExit(); // ensure handlers flush
            return (proc.ExitCode, stdout.ToStringWithTruncationNote(), stderr.ToStringWithTruncationNote(), (int)sw.ElapsedMilliseconds, false);
        }
        finally
        {
            try { File.Delete(tempPath); } catch { /* ignore */ }
        }
    }

    private static string BuildArgs(IEnumerable<string>? args)
        => args == null ? string.Empty : string.Join(" ", args.Select(a => $"\"{a}\""));

    private static void TryKill(Process p)
    {
        try { if (!p.HasExited) p.Kill(entireProcessTree: true); } catch { /* ignore */ }
    }

    private sealed class LimitedBuffer
    {
        private readonly int _limit;
        private readonly MemoryStream _ms;
        private readonly StreamWriter _sw;
        private bool _truncated;

        public LimitedBuffer(int limitBytes)
        {
            _limit = limitBytes;
            _ms = new MemoryStream();
            _sw = new StreamWriter(_ms, new UTF8Encoding(false)) { AutoFlush = true };
        }

        public void AppendLine(string s)
        {
            var data = Encoding.UTF8.GetBytes(s + Environment.NewLine);
            if (_ms.Length + data.Length <= _limit)
            {
                _ms.Write(data, 0, data.Length);
            }
            else
            {
                var remaining = _limit - _ms.Length;
                if (remaining > 0)
                {
                    _ms.Write(data, 0, (int)remaining);
                }
                _truncated = true;
            }
        }

        public string ToStringWithTruncationNote()
        {
            _sw.Flush();
            var text = Encoding.UTF8.GetString(_ms.ToArray());
            return _truncated ? text + Environment.NewLine + "(truncated)" : text;
        }
    }
}

============================== END FILE ========================================
============================= BEGIN FILE =======================================
Path: C:\Users\Last Stop\Documents\Programming Projects\RemoteIQ V5\remoteiq-minimal-e2e\agent-windows\RemoteIQ.Agent\Services\Security\TokenStore.cs
Name: TokenStore.cs
-------------------------------------------------------------------------------using System.Text.Json;
using RemoteIQ.Agent.Util;

namespace RemoteIQ.Agent.Services.Security;

public class TokenStore
{
    private string _dir = default!;
    private string _file = default!;
    private readonly object _lock = new();

    public class TokenData
    {
        public string? AgentId { get; set; }     // keep as string for flexibility
        public string? DeviceId { get; set; }    // keep as string (hostname/guid/row id)
        public string? AgentToken { get; set; }
        public DateTime? RotateAfter { get; set; }
    }

    public TokenStore()
    {
        var baseDir = !Environment.UserInteractive
            ? Environment.GetFolderPath(Environment.SpecialFolder.CommonApplicationData) // C:\ProgramData
            : Environment.GetFolderPath(Environment.SpecialFolder.LocalApplicationData); // C:\Users\<you>\AppData\Local

        InitAt(Path.Combine(baseDir, "RemoteIQ"), harden: !Environment.UserInteractive);
    }

    private void InitAt(string targetDir, bool harden)
    {
        _dir = targetDir;
        _file = Path.Combine(_dir, "agent.json");

        Directory.CreateDirectory(_dir);
        if (harden)
        {
            Try(() => AclUtils.HardenDirectory(_dir));
        }
    }

    public TokenData? Load()
    {
        lock (_lock)
        {
            if (!File.Exists(_file)) return null;
            try
            {
                var json = File.ReadAllText(_file);
                return JsonSerializer.Deserialize<TokenData>(json);
            }
            catch
            {
                return null;
            }
        }
    }

    public void Save(TokenData data)
    {
        lock (_lock)
        {
            var json = JsonSerializer.Serialize(data, new JsonSerializerOptions { WriteIndented = true });

            if (TryWrite(_file, json, harden: !Environment.UserInteractive)) return;

            if (Environment.UserInteractive)
            {
                var fallbackDir = Path.Combine(
                    Environment.GetFolderPath(Environment.SpecialFolder.LocalApplicationData),
                    "RemoteIQ");

                if (!string.Equals(_dir, fallbackDir, StringComparison.OrdinalIgnoreCase))
                {
                    InitAt(fallbackDir, harden: false);
                    if (TryWrite(_file, json, harden: false))
                    {
                        Console.WriteLine($"[TokenStore] Saved token to user-local path: {_file}");
                        return;
                    }
                }
            }

            var tempFile = Path.Combine(Path.GetTempPath(), "RemoteIQ.agent.json");
            if (TryWrite(tempFile, json, harden: false))
            {
                _dir = Path.GetDirectoryName(tempFile)!;
                _file = tempFile;
                Console.WriteLine($"[TokenStore] Saved token to TEMP as a fallback: {_file}");
                return;
            }

            throw new UnauthorizedAccessException(
                $"Failed to save token to '{_file}'. Try running PowerShell as Administrator or fix directory ACLs.");
        }
    }

    public void Clear()
    {
        lock (_lock)
        {
            Try(() =>
            {
                if (File.Exists(_file)) File.Delete(_file);
            });
        }
    }

    private static bool TryWrite(string path, string contents, bool harden)
    {
        try
        {
            var dir = Path.GetDirectoryName(path)!;
            Directory.CreateDirectory(dir);
            File.WriteAllText(path, contents);

            if (harden)
            {
                Try(() => AclUtils.HardenFile(path));
            }
            return true;
        }
        catch
        {
            return false;
        }
    }

    private static void Try(Action a)
    {
        try { a(); } catch { /* best effort */ }
    }
}

============================== END FILE ========================================
============================= BEGIN FILE =======================================
Path: C:\Users\Last Stop\Documents\Programming Projects\RemoteIQ V5\remoteiq-minimal-e2e\agent-windows\RemoteIQ.Agent\Services\Update\Updater.cs
Name: Updater.cs
-------------------------------------------------------------------------------namespace RemoteIQ.Agent.Services.Update;
public class Updater { }

============================== END FILE ========================================
============================= BEGIN FILE =======================================
Path: C:\Users\Last Stop\Documents\Programming Projects\RemoteIQ V5\remoteiq-minimal-e2e\agent-windows\RemoteIQ.Agent\Services\WebSocketClient.cs
Name: WebSocketClient.cs
-------------------------------------------------------------------------------// remoteiq-minimal-e2e/agent-windows/RemoteIQ.Agent/Services/WebSocketClient.cs
using System.Diagnostics;
using System.Net.WebSockets;
using System.Runtime.InteropServices;
using System.Text;
using System.Text.Json;
using Microsoft.Extensions.Configuration;
using Microsoft.Extensions.Logging;
using RemoteIQ.Agent.Models;            // AgentConfig.From(...)
using RemoteIQ.Agent.Services.Security; // TokenStore

namespace RemoteIQ.Agent.Services;

/// <summary>
/// Optional WebSocket client. Connects to ws(s)://{ApiBaseHost}/ws,
/// sends an agent_hello right after connect, then listens for messages.
/// Supports "job_run_script" and replies with "job_result".
/// </summary>
public class WebSocketClient : IAsyncDisposable
{
    private readonly ILogger<WebSocketClient> _log;
    private readonly IConfiguration _configuration;
    private readonly TokenStore _tokenStore;

    private ClientWebSocket? _ws;
    private Uri? _endpoint;

    private const string AgentVersion = "1.0.0.0";

    public WebSocketClient(
        ILogger<WebSocketClient> log,
        IConfiguration configuration,
        TokenStore tokenStore)
    {
        _log = log;
        _configuration = configuration;
        _tokenStore = tokenStore;
    }

    public async Task StartAsync(CancellationToken ct)
    {
        var cfg = AgentConfig.From(_configuration);

        if (!Uri.TryCreate(cfg.ApiBase, UriKind.Absolute, out var apiBase))
        {
            _log.LogDebug("WebSocketClient: ApiBase not a valid URI; skipping WS.");
            return;
        }

        var wsScheme =
            apiBase.Scheme.Equals("https", StringComparison.OrdinalIgnoreCase) ? "wss" :
            apiBase.Scheme.Equals("http", StringComparison.OrdinalIgnoreCase) ? "ws" : null;

        if (wsScheme is null)
        {
            _log.LogDebug("WebSocketClient: ApiBase scheme not http/https; skipping WS.");
            return;
        }

        _endpoint = new UriBuilder(apiBase)
        {
            Scheme = wsScheme,
            Path = "/ws",
            Query = ""
        }.Uri;

        var tokenData = _tokenStore.Load();
        var token = tokenData?.AgentToken;
        if (string.IsNullOrWhiteSpace(token))
        {
            _log.LogDebug("WebSocketClient: no token yet; skipping WS connect.");
            return;
        }

        _ws = new ClientWebSocket();
        _ws.Options.SetRequestHeader("Authorization", $"Bearer {token}");

        try
        {
            _log.LogInformation("WebSocketClient: connecting to {Endpoint}", _endpoint);
            await _ws.ConnectAsync(_endpoint, ct);

            // Send hello immediately after connecting
            await SendHelloAsync(tokenData, token, ct);

            // Start the receive loop (fire-and-forget)
            _ = Task.Run(() => ReceiveLoopAsync(ct), ct);
        }
        catch (Exception ex)
        {
            _log.LogDebug(ex, "WebSocketClient: connect failed; continuing without WS.");
            await DisposeAsync();
        }
    }

    private async Task SendHelloAsync(TokenStore.TokenData? tokenData, string jwt, CancellationToken ct)
    {
        if (_ws is not { State: WebSocketState.Open }) return;

        var agentId = !string.IsNullOrWhiteSpace(tokenData?.AgentId)
            ? tokenData!.AgentId!
            : (TryGetClaimFromJwt(jwt, "agentId", "agent_id", "aid", "agent") ?? "unknown");

        var deviceId = !string.IsNullOrWhiteSpace(tokenData?.DeviceId)
            ? tokenData!.DeviceId!
            : (TryGetClaimFromJwt(jwt, "deviceId", "device_id", "did", "device") ?? "unknown");

        var hello = new
        {
            t = "agent_hello",
            agentId,
            deviceId,
            hostname = Environment.MachineName,
            os = "windows",
            arch = RuntimeInformation.OSArchitecture.ToString().ToLowerInvariant(),
            version = AgentVersion
        };

        await SendJsonAsync(hello, ct);
        _log.LogInformation("WebSocketClient: sent agent_hello (agentId={AgentId}, deviceId={DeviceId})", agentId, deviceId);
    }

    private static string? TryGetClaimFromJwt(string jwt, params string[] keys)
    {
        try
        {
            var parts = jwt.Split('.');
            if (parts.Length < 2) return null;

            static string Pad(string s) => s + new string('=', (4 - s.Length % 4) % 4);
            var payloadJson = Encoding.UTF8.GetString(
                Convert.FromBase64String(Pad(parts[1].Replace('-', '+').Replace('_', '/')))
            );

            using var doc = JsonDocument.Parse(payloadJson);
            var root = doc.RootElement;

            foreach (var key in keys)
            {
                if (root.TryGetProperty(key, out var el))
                {
                    return el.ValueKind switch
                    {
                        JsonValueKind.String => el.GetString(),
                        JsonValueKind.Number => el.TryGetInt64(out var n) ? n.ToString() : el.ToString(),
                        _ => el.ToString()
                    };
                }
            }

            if (root.TryGetProperty("claims", out var claims) && claims.ValueKind == JsonValueKind.Object)
            {
                foreach (var key in keys)
                {
                    if (claims.TryGetProperty(key, out var el2))
                    {
                        return el2.ValueKind == JsonValueKind.String ? el2.GetString() : el2.ToString();
                    }
                }
            }
        }
        catch { }
        return null;
    }

    private async Task ReceiveLoopAsync(CancellationToken ct)
    {
        if (_ws is null) return;

        var buffer = new byte[256 * 1024];
        var sb = new StringBuilder();

        while (!ct.IsCancellationRequested && _ws.State == WebSocketState.Open)
        {
            try
            {
                sb.Clear();
                WebSocketReceiveResult? result;
                do
                {
                    result = await _ws.ReceiveAsync(new ArraySegment<byte>(buffer), ct);
                    if (result.MessageType == WebSocketMessageType.Close)
                    {
                        _log.LogInformation("WebSocketClient: server closed connection.");
                        await DisposeAsync();
                        return;
                    }
                    sb.Append(Encoding.UTF8.GetString(buffer, 0, result.Count));
                } while (!result.EndOfMessage);

                var text = sb.ToString();
                if (string.IsNullOrWhiteSpace(text)) continue;

                HandleInbound(text, ct);
            }
            catch (OperationCanceledException) { }
            catch (Exception ex)
            {
                _log.LogDebug(ex, "WebSocketClient: receive error; closing.");
                break;
            }
        }

        await DisposeAsync();
    }

    private void HandleInbound(string json, CancellationToken ct)
    {
        try
        {
            using var doc = JsonDocument.Parse(json);
            var root = doc.RootElement;
            var t = root.TryGetProperty("t", out var tEl) && tEl.ValueKind == JsonValueKind.String ? tEl.GetString() : null;
            if (string.IsNullOrEmpty(t)) return;

            if (t == "job_run_script")
            {
                // Expected payload:
                // { t, jobId, language: "powershell" | "bash", scriptText, args?, env?, timeoutSec? }
                var jobId = root.GetProperty("jobId").GetString() ?? "";
                var language = root.GetProperty("language").GetString() ?? "powershell";
                var scriptText = root.GetProperty("scriptText").GetString() ?? "";
                var args = root.TryGetProperty("args", out var aEl) && aEl.ValueKind == JsonValueKind.Array
                    ? aEl.EnumerateArray().Select(x => x.GetString() ?? "").ToArray()
                    : Array.Empty<string>();
                var env = root.TryGetProperty("env", out var eEl) && eEl.ValueKind == JsonValueKind.Object
                    ? eEl.EnumerateObject().ToDictionary(p => p.Name, p => p.Value.GetString() ?? "")
                    : new Dictionary<string, string>();
                var timeoutSec = root.TryGetProperty("timeoutSec", out var toEl) && toEl.TryGetInt32(out var to)
                    ? to
                    : 120;

                _ = Task.Run(async () =>
                {
                    var sw = Stopwatch.StartNew();
                    int exitCode;
                    string stdout, stderr;
                    try
                    {
                        if (RuntimeInformation.IsOSPlatform(OSPlatform.Windows) && language.Equals("powershell", StringComparison.OrdinalIgnoreCase))
                        {
                            (exitCode, stdout, stderr) = await RunPowerShellAsync(scriptText, args, env, TimeSpan.FromSeconds(timeoutSec), ct);
                        }
                        else
                        {
                            (exitCode, stdout, stderr) = await RunShellAsync(scriptText, args, env, TimeSpan.FromSeconds(timeoutSec), ct);
                        }
                    }
                    catch (Exception ex)
                    {
                        exitCode = -1;
                        stdout = "";
                        stderr = $"Agent exception: {ex.Message}";
                    }
                    sw.Stop();

                    var result = new
                    {
                        t = "job_result",
                        jobId,
                        exitCode,
                        stdout,
                        stderr,
                        durationMs = (long)sw.ElapsedMilliseconds,
                        status = exitCode == 0 ? "succeeded" : "failed"
                    };
                    await SendJsonAsync(result, CancellationToken.None);
                }, ct);
            }
        }
        catch (Exception ex)
        {
            _log.LogDebug(ex, "WebSocketClient: failed to handle inbound message");
        }
    }

    private async Task SendJsonAsync(object payload, CancellationToken ct)
    {
        if (_ws is not { State: WebSocketState.Open }) return;
        var json = JsonSerializer.Serialize(payload);
        var bytes = Encoding.UTF8.GetBytes(json);
        await _ws.SendAsync(new ArraySegment<byte>(bytes), WebSocketMessageType.Text, true, ct);
    }

    private static async Task<(int exitCode, string stdout, string stderr)> RunPowerShellAsync(
        string scriptText,
        string[] args,
        Dictionary<string, string> env,
        TimeSpan timeout,
        CancellationToken ct)
    {
        // Use -NoProfile -NonInteractive for reliability; pass the script via -Command
        var psi = new ProcessStartInfo
        {
            FileName = "powershell.exe",
            Arguments = "-NoProfile -NonInteractive -ExecutionPolicy Bypass -Command -",
            RedirectStandardInput = true,
            RedirectStandardOutput = true,
            RedirectStandardError = true,
            UseShellExecute = false,
            CreateNoWindow = true,
        };

        foreach (var kv in env) psi.Environment[kv.Key] = kv.Value;

        using var proc = new Process { StartInfo = psi };
        proc.Start();

        await proc.StandardInput.WriteAsync(scriptText);
        await proc.StandardInput.FlushAsync();
        proc.StandardInput.Close();

        var stdoutTask = proc.StandardOutput.ReadToEndAsync();
        var stderrTask = proc.StandardError.ReadToEndAsync();

        using var cts = CancellationTokenSource.CreateLinkedTokenSource(ct);
        cts.CancelAfter(timeout);

        var exited = await Task.Run(() => proc.WaitForExit((int)timeout.TotalMilliseconds), cts.Token);
        if (!exited)
        {
            try { proc.Kill(true); } catch { }
            return (124, "", "Timeout");
        }

        var stdout = await stdoutTask;
        var stderr = await stderrTask;
        return (proc.ExitCode, stdout, stderr);
    }

    private static async Task<(int exitCode, string stdout, string stderr)> RunShellAsync(
        string scriptText,
        string[] args,
        Dictionary<string, string> env,
        TimeSpan timeout,
        CancellationToken ct)
    {
        // Generic /bin/bash -c 'script'
        var psi = new ProcessStartInfo
        {
            FileName = "/bin/bash",
            Arguments = "-c \"$@\" bash _ " + EscapeForBash(scriptText),
            RedirectStandardOutput = true,
            RedirectStandardError = true,
            UseShellExecute = false,
            CreateNoWindow = true,
        };

        foreach (var kv in env) psi.Environment[kv.Key] = kv.Value;

        using var proc = new Process { StartInfo = psi };
        proc.Start();

        var stdoutTask = proc.StandardOutput.ReadToEndAsync();
        var stderrTask = proc.StandardError.ReadToEndAsync();

        using var cts = CancellationTokenSource.CreateLinkedTokenSource(ct);
        cts.CancelAfter(timeout);

        var exited = await Task.Run(() => proc.WaitForExit((int)timeout.TotalMilliseconds), cts.Token);
        if (!exited)
        {
            try { proc.Kill(true); } catch { }
            return (124, "", "Timeout");
        }

        var stdout = await stdoutTask;
        var stderr = await stderrTask;
        return (proc.ExitCode, stdout, stderr);
    }

    private static string EscapeForBash(string s)
        => s.Replace("\\", "\\\\").Replace("\"", "\\\"").Replace("$", "\\$").Replace("`", "\\`");

    public async ValueTask DisposeAsync()
    {
        try
        {
            if (_ws is { State: WebSocketState.Open })
            {
                await _ws.CloseAsync(WebSocketCloseStatus.NormalClosure, "bye", CancellationToken.None);
            }
        }
        catch { }
        finally
        {
            _ws?.Dispose();
            _ws = null;
        }
    }
}

============================== END FILE ========================================
============================= BEGIN FILE =======================================
Path: C:\Users\Last Stop\Documents\Programming Projects\RemoteIQ V5\remoteiq-minimal-e2e\agent-windows\RemoteIQ.Agent\Util\AclUtils.cs
Name: AclUtils.cs
-------------------------------------------------------------------------------// Util/AclUtils.cs
using System.IO;
using System.Security.AccessControl;
using System.Security.Principal;
using System.Runtime.Versioning;

namespace RemoteIQ.Agent.Util;

[SupportedOSPlatform("windows")]
public static class AclUtils
{
    [SupportedOSPlatform("windows")]
    public static void HardenDirectory(string path)
    {
        if (!OperatingSystem.IsWindows()) return; // belt & suspenders
        try
        {
            var dirInfo = new DirectoryInfo(path);
            var sec = dirInfo.GetAccessControl();
            sec.SetAccessRuleProtection(true, false);

            var systemSid = new SecurityIdentifier(WellKnownSidType.LocalSystemSid, null);
            var adminsSid = new SecurityIdentifier(WellKnownSidType.BuiltinAdministratorsSid, null);

            foreach (FileSystemAccessRule r in sec.GetAccessRules(true, true, typeof(SecurityIdentifier)))
                sec.RemoveAccessRule(r);

            sec.AddAccessRule(new FileSystemAccessRule(systemSid, FileSystemRights.FullControl, AccessControlType.Allow));
            sec.AddAccessRule(new FileSystemAccessRule(adminsSid, FileSystemRights.FullControl, AccessControlType.Allow));
            dirInfo.SetAccessControl(sec);
        }
        catch { }
    }

    [SupportedOSPlatform("windows")]
    public static void HardenFile(string path)
    {
        if (!OperatingSystem.IsWindows()) return;
        try
        {
            var fi = new FileInfo(path);
            var sec = fi.GetAccessControl();
            sec.SetAccessRuleProtection(true, false);

            var systemSid = new SecurityIdentifier(WellKnownSidType.LocalSystemSid, null);
            var adminsSid = new SecurityIdentifier(WellKnownSidType.BuiltinAdministratorsSid, null);

            foreach (FileSystemAccessRule r in sec.GetAccessRules(true, true, typeof(SecurityIdentifier)))
                sec.RemoveAccessRule(r);

            sec.AddAccessRule(new FileSystemAccessRule(systemSid, FileSystemRights.FullControl, AccessControlType.Allow));
            sec.AddAccessRule(new FileSystemAccessRule(adminsSid, FileSystemRights.FullControl, AccessControlType.Allow));
            fi.SetAccessControl(sec);
        }
        catch { }
    }
}

============================== END FILE ========================================
============================= BEGIN FILE =======================================
Path: C:\Users\Last Stop\Documents\Programming Projects\RemoteIQ V5\remoteiq-minimal-e2e\agent-windows\RemoteIQ.Agent\Util\Json.cs
Name: Json.cs
-------------------------------------------------------------------------------using System.Text.Json;

namespace RemoteIQ.Agent.Util;

public static class Json
{
    public static readonly JsonSerializerOptions Options = new()
    {
        PropertyNamingPolicy = JsonNamingPolicy.CamelCase,
        WriteIndented = false
    };

    public static string Stringify<T>(T obj) => JsonSerializer.Serialize(obj, Options);
    public static T Parse<T>(string s) => JsonSerializer.Deserialize<T>(s, Options)!;
}
============================== END FILE ========================================
============================= BEGIN FILE =======================================
Path: C:\Users\Last Stop\Documents\Programming Projects\RemoteIQ V5\remoteiq-minimal-e2e\agent-windows\RemoteIQ.Agent\Util\JsonlQueue.cs
Name: JsonlQueue.cs
-------------------------------------------------------------------------------using System.Text.Json;

namespace RemoteIQ.Agent.Util;

public class JsonlQueue
{
    private readonly string _dir;
    private readonly object _lock = new();

    public JsonlQueue()
    {
        _dir = Path.Combine(Environment.GetFolderPath(Environment.SpecialFolder.CommonApplicationData), "RemoteIQ", "queue");
        Directory.CreateDirectory(_dir);
    }

    public void Enqueue(string type, object payload)
    {
        var line = JsonSerializer.Serialize(new QueueItem { Type = type, Payload = payload, Ts = DateTime.UtcNow });
        var file = Path.Combine(_dir, $"{DateTime.UtcNow:yyyyMMddHHmmssfff}-{Guid.NewGuid():N}.jsonl");
        lock (_lock)
        {
            File.WriteAllText(file, line);
        }
    }

    public IEnumerable<QueueItem> Drain()
    {
        var files = Directory.EnumerateFiles(_dir, "*.jsonl").OrderBy(f => f).ToList();
        foreach (var f in files)
        {
            QueueItem? item = null;
            try
            {
                var line = File.ReadAllText(f);
                item = JsonSerializer.Deserialize<QueueItem>(line);
            }
            catch { }
            finally
            {
                try { File.Delete(f); } catch { }
            }
            if (item != null) yield return item!;
        }
    }

    public class QueueItem
    {
        public string Type { get; set; } = "";
        public object? Payload { get; set; }
        public DateTime Ts { get; set; }
    }
}

============================== END FILE ========================================
============================= BEGIN FILE =======================================
Path: C:\Users\Last Stop\Documents\Programming Projects\RemoteIQ V5\remoteiq-minimal-e2e\agent-windows\RemoteIQ.Agent\Util\WindowsOnly.cs
Name: WindowsOnly.cs
-------------------------------------------------------------------------------//remoteiq-minimal-e2e\agent-windows\RemoteIQ.Agent\Util\WindowsOnly.cs

using System.Runtime.Versioning;
[assembly: SupportedOSPlatform("windows")]

============================== END FILE ========================================
