
########## BEGIN FILE: app\(auth)\login\page.tsx ##########
// app/(auth)/login/page.tsx
"use client";

import * as React from "react";
import {
    Card,
    CardContent,
    CardDescription,
    CardFooter,
    CardHeader,
    CardTitle,
} from "@/components/ui/card";
import { Button } from "@/components/ui/button";
import { Input } from "@/components/ui/input";
import { Label } from "@/components/ui/label";
import { Shield, Eye, EyeOff } from "lucide-react";
import Link from "next/link";
import { useRouter, useSearchParams } from "next/navigation";
import { useBranding } from "@/app/providers/BrandingProvider";

/** Only allow same-origin paths; never /login or legacy /auth/login */
function safeNext(raw: string | null): string {
    if (!raw) return "/";
    try {
        if (raw.startsWith("http://") || raw.startsWith("https://") || raw.startsWith("//")) return "/";
        if (!raw.startsWith("/")) return "/";
        if (raw === "/login" || raw.startsWith("/auth/login")) return "/";
        return raw;
    } catch {
        return "/";
    }
}

const API_BASE = (process.env.NEXT_PUBLIC_API_BASE || "http://localhost:3001").replace(/\/+$/, "");

export default function LoginPage() {
    const router = useRouter();
    const params = useSearchParams();
    const nextPath = safeNext(params.get("next"));

    const { branding } = useBranding();

    // Normalize nullable strings -> undefined for JSX props
    const loginBg = branding?.loginBackgroundUrl ?? undefined;
    const logoLight = branding?.logoLightUrl ?? undefined;
    const logoDark = branding?.logoDarkUrl ?? undefined;
    const effectiveLogo = logoLight ?? logoDark ?? "/logo.png"; // always a string

    // Form state
    const [email, setEmail] = React.useState(() => {
        if (typeof window !== "undefined") {
            return localStorage.getItem("riq_last_email") ?? "";
        }
        return "";
    });
    const [password, setPassword] = React.useState("");
    const [remember, setRemember] = React.useState(
        () => (typeof window !== "undefined" ? localStorage.getItem("riq_remember") === "1" : false)
    );
    const [isLoading, setIsLoading] = React.useState(false);
    const [error, setError] = React.useState<string | null>(null);
    const [showPw, setShowPw] = React.useState(false);
    const [capsLock, setCapsLock] = React.useState(false);

    // Keep localStorage aligned with the remember choice
    React.useEffect(() => {
        if (typeof window === "undefined") return;
        if (remember) {
            localStorage.setItem("riq_remember", "1");
            if (email) localStorage.setItem("riq_last_email", email);
        } else {
            localStorage.removeItem("riq_remember");
            // Optional: keep last email for convenience
        }
    }, [remember, email]);

    const canSubmit = email.trim().length > 0 && password.length > 0 && !isLoading;

    const handleLogin = async (e: React.FormEvent) => {
        e.preventDefault();
        setError(null);
        setIsLoading(true);

        const payload = { email: email.trim(), password };

        try {
            const res = await fetch(`${API_BASE}/api/auth/login`, {
                method: "POST",
                credentials: "include", // set httpOnly cookie
                headers: { "Content-Type": "application/json" },
                body: JSON.stringify(payload),
            });

            if (!res.ok) {
                // Try to show server validation details if present
                let msg = `Login failed (${res.status})`;
                try {
                    const j = await res.json();
                    if (j?.message) {
                        if (Array.isArray(j.message)) msg = j.message.join(", ");
                        else msg = String(j.message);
                    }
                } catch {
                    // ignore JSON parse errors
                }
                throw new Error(msg);
            }

            if (remember) {
                localStorage.setItem("riq_last_email", payload.email);
            }

            router.replace(nextPath);
        } catch (err: any) {
            setError(String(err?.message ?? err) || "Login failed");
        } finally {
            setIsLoading(false);
        }
    };

    return (
        <div
            className="relative flex min-h-screen items-center justify-center bg-background p-4 bg-cover bg-center"
            style={loginBg ? { backgroundImage: `url(${loginBg})` } : undefined}
        >
            {/* Subtle overlay for readability (only when bg is present) */}
            {loginBg && <div className="pointer-events-none absolute inset-0 bg-black/10" />}

            <Card className="relative z-10 w-full max-w-sm backdrop-blur supports-[backdrop-filter]:bg-background/80">
                <CardHeader className="text-center">
                    <div className="mb-3 flex items-center justify-center gap-2">
                        {/* Prefer brand logos; fall back to icon */}
                        {logoLight || logoDark ? (
                            <picture>
                                {logoDark ? <source srcSet={logoDark} media="(prefers-color-scheme: dark)" /> : null}
                                <img src={effectiveLogo} alt="RemoteIQ" className="h-7 w-auto rounded-sm" />
                            </picture>
                        ) : (
                            <Shield className="h-6 w-6" />
                        )}
                        <CardTitle className="text-2xl">RemoteIQ</CardTitle>
                    </div>
                    <CardDescription>Sign in to your account to continue</CardDescription>
                </CardHeader>

                <form onSubmit={handleLogin} noValidate>
                    <CardContent className="space-y-4">
                        <div className="space-y-2">
                            <Label htmlFor="email">Email</Label>
                            <Input
                                id="email"
                                type="email"
                                placeholder="admin@example.com"
                                required
                                value={email}
                                onChange={(e) => setEmail(e.target.value)}
                                disabled={isLoading}
                                autoComplete="username"
                                inputMode="email"
                            />
                        </div>

                        <div className="space-y-2">
                            <div className="flex items-center justify-between">
                                <Label htmlFor="password">Password</Label>
                                <Link href="/forgot-password" className="text-sm font-medium text-primary hover:underline">
                                    Forgot password?
                                </Link>
                            </div>

                            <div className="relative">
                                <Input
                                    id="password"
                                    type={showPw ? "text" : "password"}
                                    required
                                    value={password}
                                    onChange={(e) => setPassword(e.target.value)}
                                    onKeyUp={(e) => setCapsLock((e as any).getModifierState?.("CapsLock") === true)}
                                    disabled={isLoading}
                                    autoComplete="current-password"
                                />
                                <button
                                    type="button"
                                    className="absolute right-2 top-1/2 -translate-y-1/2 rounded-md p-1 text-muted-foreground hover:text-foreground"
                                    onClick={() => setShowPw((s) => !s)}
                                    aria-label={showPw ? "Hide password" : "Show password"}
                                >
                                    {showPw ? <EyeOff className="h-4 w-4" /> : <Eye className="h-4 w-4" />}
                                </button>
                            </div>

                            {capsLock && <p className="text-xs text-amber-600 dark:text-amber-400">Caps Lock is ON</p>}
                        </div>

                        <div className="flex items-center justify-between">
                            <label className="flex items-center gap-2 text-sm">
                                <input
                                    type="checkbox"
                                    className="accent-primary h-4 w-4"
                                    checked={remember}
                                    onChange={(e) => setRemember(e.target.checked)}
                                    disabled={isLoading}
                                />
                                Remember me
                            </label>
                        </div>

                        {error && <p className="text-sm text-destructive">{error}</p>}
                    </CardContent>

                    <CardFooter className="flex flex-col gap-3">
                        <Button type="submit" className="w-full" disabled={!canSubmit}>
                            {isLoading ? "Signing In..." : "Sign In"}
                        </Button>
                    </CardFooter>
                </form>
            </Card>
        </div>
    );
}

########## END FILE:   app\(auth)\login\page.tsx ##########

########## BEGIN FILE: app\account\tabs\SecurityTab.tsx ##########
// remoteiq-frontend/app/account/tabs/SecurityTab.tsx
"use client";

import * as React from "react";
import Image from "next/image";
import {
  Card,
  CardHeader,
  CardTitle,
  CardDescription,
  CardContent,
} from "@/components/ui/card";
import { Button } from "@/components/ui/button";
import { Input } from "@/components/ui/input";
import { Label } from "@/components/ui/label";
import { Switch } from "@/components/ui/switch";
import {
  Dialog,
  DialogContent,
  DialogDescription,
  DialogHeader,
  DialogTitle,
  DialogFooter,
} from "@/components/ui/dialog";
import {
  changePasswordSelf,
  confirm2FA,
  disable2FA,
  getSecurityOverview,
  regenerateRecoveryCodes,
  start2FA,
} from "@/lib/api";
import { useToast } from "@/lib/toast";
import {
  Ban,
  KeyRound,
  LockKeyhole,
  Loader2,
  QrCode,
  ShieldCheck,
  Smartphone,
} from "lucide-react";

type Props = {
  onDirtyChange: (dirty: boolean) => void;
  saveHandleRef: (h: { submit: () => void }) => void;
};

// ---- Small date helper (if needed later) ----
const dateFmt = new Intl.DateTimeFormat(undefined, {
  year: "numeric",
  month: "short",
  day: "2-digit",
  hour: "2-digit",
  minute: "2-digit",
});
function fmtDate(iso?: string | null) {
  if (!iso) return "—";
  try { return dateFmt.format(new Date(iso)); } catch { return iso as string; }
}

export default function SecurityTab({ onDirtyChange, saveHandleRef }: Props) {
  const { push } = useToast();

  // Track "dirty" for the page chrome; only the password form can be dirty
  const [isDirty, setIsDirty] = React.useState(false);
  React.useEffect(() => { onDirtyChange(isDirty); }, [isDirty, onDirtyChange]);
  React.useEffect(() => { saveHandleRef({ submit: () => void 0 }); }, [saveHandleRef]);

  const [loading, setLoading] = React.useState(true);
  const [twoFAEnabled, setTwoFAEnabled] = React.useState(false);

  // Password form
  const [currentPwd, setCurrentPwd] = React.useState("");
  const [newPwd, setNewPwd] = React.useState("");
  const [confirmPwd, setConfirmPwd] = React.useState("");
  const [pwdBusy, setPwdBusy] = React.useState(false);

  // Two-factor
  const [twoFaBusy, setTwoFaBusy] = React.useState(false);
  const [startData, setStartData] = React.useState<{ secret: string; otpauthUrl: string; qrPngDataUrl: string } | null>(null);
  const [totpOpen, setTotpOpen] = React.useState(false);
  const [totpCode, setTotpCode] = React.useState("");
  const [recoveryOpen, setRecoveryOpen] = React.useState(false);
  const [recoveryCodes, setRecoveryCodes] = React.useState<string[]>([]);
  const [disableOpen, setDisableOpen] = React.useState(false);
  const [disableWith, setDisableWith] = React.useState<"totp" | "recovery">("totp");
  const [disableTotp, setDisableTotp] = React.useState("");
  const [disableRecovery, setDisableRecovery] = React.useState("");

  // Load 2FA status on mount
  React.useEffect(() => {
    (async () => {
      setLoading(true);
      try {
        const ov = await getSecurityOverview();
        setTwoFAEnabled(!!ov.twoFactorEnabled);
      } catch (err) {
        console.error(err);
        push({ title: "Failed to load security", kind: "destructive" });
      } finally {
        setLoading(false);
      }
    })();
  }, [push]);

  // Track password dirtiness
  React.useEffect(() => {
    const dirty = Boolean(currentPwd || newPwd || confirmPwd);
    setIsDirty(dirty);
  }, [currentPwd, newPwd, confirmPwd]);

  // -------------------- Password change --------------------
  const PASSWORD_MIN_LEN = Number(process.env.NEXT_PUBLIC_PASSWORD_MIN_LEN || 8);
  const canChangePwd =
    currentPwd.length >= 1 &&
    newPwd.length >= PASSWORD_MIN_LEN &&
    newPwd === confirmPwd &&
    newPwd !== currentPwd;

  async function onChangePassword() {
    if (!canChangePwd) return;
    setPwdBusy(true);
    try {
      await changePasswordSelf(currentPwd, newPwd);
      push({ title: "Password changed", kind: "success" });
      setCurrentPwd("");
      setNewPwd("");
      setConfirmPwd("");
    } catch (err: any) {
      push({ title: err?.message || "Failed to change password", kind: "destructive" });
    } finally {
      setPwdBusy(false);
    }
  }

  // -------------------- 2FA: start/confirm/disable --------------------
  async function onStart2FA() {
    setTwoFaBusy(true);
    try {
      const data = await start2FA();
      setStartData(data);
      setTotpOpen(true);
    } catch (err: any) {
      push({ title: err?.message || "Failed to start 2FA", kind: "destructive" });
    } finally {
      setTwoFaBusy(false);
    }
  }

  async function onConfirm2FA() {
    if (!totpCode || totpCode.replace(/\s+/g, "").length !== 6) {
      push({ title: "Please enter a 6-digit code", kind: "destructive" });
      return;
    }
    setTwoFaBusy(true);
    try {
      await confirm2FA({ code: totpCode.replace(/\s+/g, "") });
      const codes = await regenerateRecoveryCodes();
      setRecoveryCodes(codes);
      setTwoFAEnabled(true);
      setTotpOpen(false);
      setRecoveryOpen(true);
      setTotpCode("");
      setStartData(null);
      push({ title: "Two-factor enabled", kind: "success" });
    } catch (err: any) {
      push({ title: err?.message || "Invalid code", kind: "destructive" });
    } finally {
      setTwoFaBusy(false);
    }
  }

  async function onDisable2FA() {
    setTwoFaBusy(true);
    try {
      const payload =
        disableWith === "totp"
          ? { code: disableTotp.replace(/\s+/g, "") }
          : { recoveryCode: disableRecovery.trim() };
      await disable2FA(payload);
      setTwoFAEnabled(false);
      setDisableTotp("");
      setDisableRecovery("");
      setDisableOpen(false);
      push({ title: "Two-factor disabled", kind: "success" });
    } catch (err: any) {
      push({ title: err?.message || "Failed to disable 2FA", kind: "destructive" });
    } finally {
      setTwoFaBusy(false);
    }
  }

  async function onRegenRecovery() {
    try {
      const codes = await regenerateRecoveryCodes();
      setRecoveryCodes(codes);
      setRecoveryOpen(true);
      push({ title: "New recovery codes generated", kind: "success" });
    } catch (err: any) {
      push({ title: err?.message || "Failed to regenerate codes", kind: "destructive" });
    }
  }

  if (loading) {
    return (
      <Card>
        <CardContent className="h-32 animate-pulse" />
      </Card>
    );
  }

  return (
    <div className="space-y-4">
      {/* Password */}
      <Card>
        <CardHeader className="pb-2">
          <CardTitle className="flex items-center gap-2">
            <KeyRound className="h-5 w-5" />
            Password
          </CardTitle>
          <CardDescription>Change your password and keep your account secure.</CardDescription>
        </CardHeader>
        <CardContent className="pt-2 space-y-4">
          <div className="grid gap-3">
            <div className="grid gap-2">
              <Label htmlFor="current">Current password</Label>
              <Input
                id="current"
                type="password"
                autoComplete="current-password"
                value={currentPwd}
                onChange={(e) => setCurrentPwd(e.target.value)}
              />
            </div>
            <div className="grid gap-2">
              <Label htmlFor="new">New password</Label>
              <Input
                id="new"
                type="password"
                autoComplete="new-password"
                value={newPwd}
                onChange={(e) => setNewPwd(e.target.value)}
                placeholder={`At least ${PASSWORD_MIN_LEN} characters`}
              />
            </div>
            <div className="grid gap-2">
              <Label htmlFor="confirm">Confirm new password</Label>
              <Input
                id="confirm"
                type="password"
                autoComplete="new-password"
                value={confirmPwd}
                onChange={(e) => setConfirmPwd(e.target.value)}
              />
            </div>
            <div className="flex items-center justify-between rounded-md border p-3">
              <div className="flex items-center gap-2 text-sm">
                <LockKeyhole className="h-4 w-4" />
                <span>Tip: sign out of other sessions after changing your password.</span>
              </div>
              <Button
                disabled={!canChangePwd || pwdBusy}
                onClick={onChangePassword}
                aria-label="Change Password"
              >
                {pwdBusy ? <Loader2 className="mr-2 h-4 w-4 animate-spin" /> : null}
                Change Password
              </Button>
            </div>
          </div>

          <div className="rounded-md border p-3 text-xs text-muted-foreground flex items-start gap-2">
            <ShieldCheck className="h-4 w-4 mt-0.5" />
            Recommendations: Enable 2FA, rotate passwords periodically, and keep your recovery codes safe.
          </div>
        </CardContent>
      </Card>

      {/* Two-Factor Authentication */}
      <Card>
        <CardHeader className="pb-2">
          <CardTitle className="flex items-center gap-2">
            <Smartphone className="h-5 w-5" />
            Two-factor authentication
          </CardTitle>
          <CardDescription>Use an authenticator app for a second layer of protection.</CardDescription>
        </CardHeader>
        <CardContent className="pt-2 space-y-3">
          <div className="flex items-center justify-between">
            <div className="text-sm">
              <div className="font-medium">Status</div>
              <div className="text-xs text-muted-foreground">
                {twoFAEnabled ? "Enabled" : "Disabled"}
              </div>
            </div>
            <Switch
              checked={twoFAEnabled}
              onCheckedChange={(checked) => {
                if (checked) onStart2FA();
                else setDisableOpen(true);
              }}
              aria-label="Toggle two factor"
            />
          </div>

          <div className="flex flex-wrap gap-2">
            {!twoFAEnabled ? (
              <Button onClick={onStart2FA} disabled={twoFaBusy}>
                {twoFaBusy ? <Loader2 className="mr-2 h-4 w-4 animate-spin" /> : <QrCode className="mr-2 h-4 w-4" />}
                Enable 2FA
              </Button>
            ) : (
              <>
                <Button variant="outline" onClick={onRegenRecovery}>
                  <KeyRound className="mr-2 h-4 w-4" />
                  Regenerate recovery codes
                </Button>
                <Button variant="destructive" onClick={() => setDisableOpen(true)}>
                  <Ban className="mr-2 h-4 w-4" />
                  Disable 2FA
                </Button>
              </>
            )}
          </div>
        </CardContent>
      </Card>

      {/* Dialog: TOTP confirm (after start) */}
      <Dialog open={totpOpen} onOpenChange={setTotpOpen}>
        <DialogContent>
          <DialogHeader>
            <DialogTitle>Scan the QR code</DialogTitle>
            <DialogDescription>
              Scan in your authenticator app, then enter a 6-digit code to confirm.
            </DialogDescription>
          </DialogHeader>
          {startData ? (
            <div className="space-y-3">
              <div className="flex items-center justify-center">
                <Image
                  src={startData.qrPngDataUrl}
                  alt="TOTP QR code"
                  width={220}
                  height={220}
                  className="rounded-md border"
                />
              </div>
              <div className="text-xs text-muted-foreground break-all">
                Secret: <span className="font-mono">{startData.secret}</span>
              </div>
              <div className="grid gap-2">
                <Label htmlFor="totp">6-digit code</Label>
                <Input
                  id="totp"
                  inputMode="numeric"
                  pattern="\d{6}"
                  placeholder="123 456"
                  value={totpCode}
                  onChange={(e) => setTotpCode(e.target.value)}
                />
              </div>
            </div>
          ) : null}
          <DialogFooter>
            <Button variant="outline" onClick={() => setTotpOpen(false)}>
              Cancel
            </Button>
            <Button onClick={onConfirm2FA} disabled={twoFaBusy}>
              {twoFaBusy ? <Loader2 className="mr-2 h-4 w-4 animate-spin" /> : <ShieldCheck className="mr-2 h-4 w-4" />}
              Confirm
            </Button>
          </DialogFooter>
        </DialogContent>
      </Dialog>

      {/* Dialog: Recovery codes */}
      <Dialog open={recoveryOpen} onOpenChange={setRecoveryOpen}>
        <DialogContent>
          <DialogHeader>
            <DialogTitle>Recovery codes</DialogTitle>
            <DialogDescription>Store these safely. Each code can be used once.</DialogDescription>
          </DialogHeader>
          <div className="grid grid-cols-2 gap-2 font-mono text-sm">
            {recoveryCodes.map((c) => (
              <div key={c} className="rounded-md border px-2 py-1">
                {c}
              </div>
            ))}
          </div>
          <DialogFooter>
            <Button variant="outline" onClick={() => setRecoveryOpen(false)}>
              Close
            </Button>
          </DialogFooter>
        </DialogContent>
      </Dialog>

      {/* Dialog: Disable 2FA */}
      <Dialog open={disableOpen} onOpenChange={setDisableOpen}>
        <DialogContent>
          <DialogHeader>
            <DialogTitle>Disable two-factor</DialogTitle>
            <DialogDescription>
              Confirm with a TOTP code or a recovery code to disable 2FA.
            </DialogDescription>
          </DialogHeader>
          <div className="space-y-3">
            <div className="flex items-center gap-3">
              <Button
                variant={disableWith === "totp" ? "default" : "outline"}
                size="sm"
                onClick={() => setDisableWith("totp")}
              >
                Use TOTP
              </Button>
              <Button
                variant={disableWith === "recovery" ? "default" : "outline"}
                size="sm"
                onClick={() => setDisableWith("recovery")}
              >
                Use recovery
              </Button>
            </div>
            {disableWith === "totp" ? (
              <div className="grid gap-2">
                <Label htmlFor="disable-totp">6-digit code</Label>
                <Input
                  id="disable-totp"
                  inputMode="numeric"
                  pattern="\d{6}"
                  placeholder="123 456"
                  value={disableTotp}
                  onChange={(e) => setDisableTotp(e.target.value)}
                />
              </div>
            ) : (
              <div className="grid gap-2">
                <Label htmlFor="disable-rec">Recovery code</Label>
                <Input
                  id="disable-rec"
                  placeholder="ABCD-EFGH-IJKL"
                  value={disableRecovery}
                  onChange={(e) => setDisableRecovery(e.target.value)}
                />
              </div>
            )}
          </div>
          <DialogFooter>
            <Button variant="outline" onClick={() => setDisableOpen(false)}>
              Cancel
            </Button>
            <Button variant="destructive" onClick={onDisable2FA} disabled={twoFaBusy}>
              {twoFaBusy ? <Loader2 className="mr-2 h-4 w-4 animate-spin" /> : <Ban className="mr-2 h-4 w-4" />}
              Disable
            </Button>
          </DialogFooter>
        </DialogContent>
      </Dialog>
    </div>
  );
}

########## END FILE:   app\account\tabs\SecurityTab.tsx ##########

########## BEGIN FILE: app\account\tabs\SessionsTab.tsx ##########
// app/account/tabs/SessionsTab.tsx
"use client";

import * as React from "react";
import {
  listMySessions,
  revokeMySession,
  revokeAllOtherSessions,
  trustMySession,
  type Session as MeSession,
  type SessionDTO,
} from "@/lib/api";

import { Card, CardHeader, CardTitle, CardDescription, CardContent } from "@/components/ui/card";
import { Button } from "@/components/ui/button";
import { Separator } from "@/components/ui/separator";
import { ShieldAlert, ShieldCheck, Globe, Smartphone, Monitor, LogOut, Loader2 } from "lucide-react";
import { useToast } from "@/lib/toast";

type Props = {
  onDirtyChange: (dirty: boolean) => void;
  saveHandleRef: (h: { submit: () => void }) => void;
};

// Map API session -> strict UI DTO (no undefineds for required fields)
function toDTO(s: MeSession): SessionDTO {
  return {
    id: String(s.id),
    device: (s as any).label ?? s.userAgent ?? "Unknown device",
    ip: (s as any).ip ?? "",
    lastActive: (s as any).lastSeenAt ?? "",
    current: Boolean((s as any).current),
    city: (s as any).city ?? "",
    isp: (s as any).isp ?? "",
    trusted: Boolean((s as any).trusted),
  } as SessionDTO;
}

export default function SessionsTab({ onDirtyChange, saveHandleRef }: Props) {
  const { push } = useToast();

  const [loading, setLoading] = React.useState(true);
  const [error, setError] = React.useState<string | null>(null);
  const [sessions, setSessions] = React.useState<SessionDTO[]>([]);

  const [busyAll, setBusyAll] = React.useState(false);
  const [busyOne, setBusyOne] = React.useState<string | null>(null);
  const [busyTrust, setBusyTrust] = React.useState<string | null>(null);

  // Loader
  const load = React.useCallback(async () => {
    setLoading(true);
    setError(null);
    try {
      const res = await listMySessions(); // GET /api/users/me/sessions/
      setSessions((res.items ?? []).map(toDTO));
    } catch (e: any) {
      if ((e?.message || "").toLowerCase().includes("unauthorized")) {
        push({ title: "Session expired — please sign in again.", kind: "destructive" });
        window.location.href = "/login";
        return;
      }
      setError(e?.message || "Failed to load sessions");
    } finally {
      setLoading(false);
    }
  }, [push]);

  React.useEffect(() => {
    onDirtyChange(false);
    saveHandleRef({ submit: () => void 0 });
    // eslint-disable-next-line react-hooks/exhaustive-deps
  }, []);

  // Initial load
  React.useEffect(() => {
    void load();
  }, [load]);

  // Refresh on tab focus
  React.useEffect(() => {
    const onFocus = () => void load();
    window.addEventListener("focus", onFocus);
    return () => window.removeEventListener("focus", onFocus);
  }, [load]);

  // Gentle polling (60s)
  React.useEffect(() => {
    const t = setInterval(() => void load(), 60_000);
    return () => clearInterval(t);
  }, [load]);

  const revokeOne = async (id: string) => {
    const target = sessions.find((s) => s.id === id);
    if (target?.current) {
      // Hard guard: never allow revoking the current session
      push({ title: "You can’t revoke your current session.", kind: "destructive" });
      return;
    }

    setBusyOne(id);
    const prev = sessions;
    setSessions(prev.filter((s) => s.id !== id));
    try {
      await revokeMySession(id); // DELETE/POST fallback handled in lib/api.ts
      push({ title: "Session revoked", kind: "success" });
    } catch (e: any) {
      setSessions(prev);
      push({ title: e?.message || "Failed to revoke session", kind: "destructive" });
    } finally {
      setBusyOne(null);
    }
  };

  const revokeOthers = async () => {
    setBusyAll(true);
    const prev = sessions;
    // Optimistic UI: keep only the current one
    setSessions(prev.filter((s) => s.current));
    try {
      await revokeAllOtherSessions(); // POST /api/users/me/sessions/revoke-all
      push({ title: "All other sessions revoked", kind: "success" });
      void load();
    } catch (e: any) {
      setSessions(prev);
      push({ title: e?.message || "Failed to revoke other sessions", kind: "destructive" });
    } finally {
      setBusyAll(false);
    }
  };

  const toggleTrust = async (s: SessionDTO) => {
    setBusyTrust(s.id);
    const prev = sessions;
    const nextTrusted = !s.trusted;
    setSessions(prev.map((x) => (x.id === s.id ? { ...x, trusted: nextTrusted } : x)));
    try {
      await trustMySession(s.id, nextTrusted); // POST /api/users/me/sessions/:id/trust (with fallbacks)
      // success toast
      push({
        title: nextTrusted ? "Device marked as trusted" : "Device untrusted",
        kind: "success",
      });
    } catch (e: any) {
      setSessions(prev);
      push({ title: e?.message || "Failed to update trust", kind: "destructive" });
    } finally {
      setBusyTrust(null);
    }
  };

  if (loading) {
    return (
      <Card>
        <CardContent className="h-32 animate-pulse" />
      </Card>
    );
  }

  if (error) {
    return (
      <Card>
        <CardContent className="p-4">
          <div role="alert" className="mb-3 rounded-md border border-amber-300 bg-amber-50 p-3 text-sm">
            {error}
          </div>
          <Button variant="outline" onClick={load}>
            Retry
          </Button>
        </CardContent>
      </Card>
    );
  }

  return (
    <div className="grid gap-6 md:grid-cols-3">
      <Card className="md:col-span-2">
        <CardHeader>
          <CardTitle>Active sessions</CardTitle>
          <CardDescription>Review and manage signed-in devices.</CardDescription>
        </CardHeader>

        <CardContent className="space-y-3">
          {sessions.map((s) => {
            const isMobile = /iphone|android|ios/i.test(s.device || "");
            const icon = isMobile ? <Smartphone className="h-4 w-4" /> : <Monitor className="h-4 w-4" />;
            const risk = s.city ? "low" : "med";

            return (
              <div key={s.id} className="rounded-md border p-3">
                <div className="flex items-center justify-between gap-3">
                  <div className="min-w-0">
                    <div className="flex items-center gap-2">
                      {icon}
                      <div className="font-medium truncate">
                        {s.device || "Unknown device"}
                        {s.current ? " • This device" : ""}
                      </div>
                    </div>

                    <div className="mt-1 text-xs text-muted-foreground flex flex-wrap items-center gap-2">
                      <Globe className="h-3.5 w-3.5" />
                      <span>{s.ip || "—"}</span>
                      {s.city && <span>• {s.city}</span>}
                      {s.isp && <span>• {s.isp}</span>}
                      {s.lastActive && <span>• Last active {s.lastActive}</span>}
                    </div>
                  </div>

                  <div className="flex items-center gap-2">
                    <Button
                      variant={s.trusted ? "outline" : "default"}
                      size="sm"
                      onClick={() => toggleTrust(s)}
                      disabled={busyTrust === s.id}
                      aria-label={s.trusted ? "Untrust device" : "Trust device"}
                    >
                      {busyTrust === s.id ? (
                        <Loader2 className="mr-2 h-4 w-4 animate-spin" />
                      ) : s.trusted ? (
                        <ShieldCheck className="mr-2 h-4 w-4" />
                      ) : (
                        <ShieldAlert className="mr-2 h-4 w-4" />
                      )}
                      {s.trusted ? "Trusted" : "Trust"}
                    </Button>

                    {/* Never allow revoking the current session */}
                    {!s.current && (
                      <Button
                        variant="outline"
                        size="sm"
                        onClick={() => revokeOne(s.id)}
                        disabled={busyOne === s.id}
                        aria-label="Revoke session"
                        title="Revoke this session"
                      >
                        {busyOne === s.id ? (
                          <Loader2 className="mr-2 h-4 w-4 animate-spin" />
                        ) : (
                          <LogOut className="mr-2 h-4 w-4" />
                        )}
                        Revoke
                      </Button>
                    )}
                  </div>
                </div>

                <div className="mt-2 text-xs text-muted-foreground">
                  Risk: {risk === "low" ? "Low" : "Medium"} — {s.trusted ? "Trusted device" : "New device or location"}
                </div>
              </div>
            );
          })}

          {sessions.length === 0 && (
            <div className="rounded-md border p-3 text-sm text-muted-foreground">No active sessions.</div>
          )}

          <Separator />

          <div className="flex justify-end">
            <Button
              variant="outline"
              onClick={revokeOthers}
              disabled={busyAll || sessions.every((s) => s.current)}
              aria-label="Revoke all other sessions"
              title="Revoke all sessions except this device"
            >
              {busyAll ? <Loader2 className="mr-2 h-4 w-4 animate-spin" /> : <LogOut className="mr-2 h-4 w-4" />}
              Revoke all other sessions
            </Button>
          </div>
        </CardContent>
      </Card>
      {/* Optional third column if you add an audit panel later */}
    </div>
  );
}

########## END FILE:   app\account\tabs\SessionsTab.tsx ##########

########## BEGIN FILE: app\hooks\useRequireAuth.ts ##########
// app/hooks/useRequireAuth.ts
"use client";
import * as React from "react";
import { usePathname, useRouter } from "next/navigation";

const API_BASE = (process.env.NEXT_PUBLIC_API_BASE || "http://localhost:3001").replace(/\/+$/, "");

type MeResponse =
    | { user: null }
    | { user: { id: string; email: string; name: string; role: string } };

export function useRequireAuth() {
    const [loading, setLoading] = React.useState(true);
    const [user, setUser] = React.useState<MeResponse["user"]>(null);
    const router = useRouter();
    const pathname = usePathname();

    React.useEffect(() => {
        let cancelled = false;

        async function run() {
            try {
                const res = await fetch(`${API_BASE}/api/auth/me`, {
                    method: "GET",
                    credentials: "include",
                });
                if (!res.ok) throw new Error(String(res.status));
                const data: MeResponse = await res.json();
                if (!cancelled) {
                    setUser(data.user ?? null);
                    if (!data.user) {
                        const next = encodeURIComponent(pathname || "/");
                        router.replace(`/login?next=${next}`);
                    }
                }
            } catch {
                if (!cancelled) {
                    const next = encodeURIComponent(pathname || "/");
                    router.replace(`/login?next=${next}`);
                }
            } finally {
                if (!cancelled) setLoading(false);
            }
        }

        run();
        return () => { cancelled = true; };
    }, [pathname, router]);

    return { loading, user };
}

########## END FILE:   app\hooks\useRequireAuth.ts ##########

########## BEGIN FILE: app\providers\BrandingProvider.tsx ##########
"use client";

import * as React from "react";

/**
 * Branding shape coming from GET /api/branding
 */
export interface Branding {
    primaryColor: string;
    secondaryColor: string;
    logoLightUrl: string;
    logoDarkUrl: string;
    loginBackgroundUrl: string;
    faviconUrl: string; // may be empty
    emailHeader: string;
    emailFooter: string;
    customCss: string;
    allowClientThemeToggle: boolean;
}

type PreviewPatch = Partial<Pick<Branding, "primaryColor" | "secondaryColor" | "faviconUrl">>;

interface BrandingContextType {
    branding: Branding | null;
    isLoaded: boolean;
    applyPreview: (patch: PreviewPatch) => void;
    clearPreview: () => void;
    refetch: () => Promise<void>;
}

const BrandingContext = React.createContext<BrandingContextType | undefined>(undefined);

const DEFAULT_PRIMARY = "#3b82f6";
const DEFAULT_SECONDARY = "#22c55e";
const DEFAULT_FAVICON = "/favicon.ico"; // <- default from public/
const HEX = /^#([0-9a-fA-F]{3}|[0-9a-fA-F]{6})$/;

/* ====================== CSS Var helpers ====================== */

function setCssVar(name: string, value: string) {
    document.documentElement.style.setProperty(name, value);
}

// converts hex -> hsl tuple string: "210 100% 56%"
function hexToHslTuple(hex: string): string {
    if (!HEX.test(hex)) {
        return "0 0% 0%";
    }
    let h = hex.slice(1);
    if (h.length === 3) h = h.split("").map((c) => c + c).join("");
    const num = parseInt(h, 16);
    const r = ((num >> 16) & 255) / 255;
    const g = ((num >> 8) & 255) / 255;
    const b = (num & 255) / 255;

    const max = Math.max(r, g, b);
    const min = Math.min(r, g, b);
    const l = (max + min) / 2;

    let hh = 0;
    let s = 0;

    if (max !== min) {
        const d = max - min;
        s = l > 0.5 ? d / (2 - max - min) : d / (max + min);
        switch (max) {
            case r:
                hh = (g - b) / d + (g < b ? 6 : 0);
                break;
            case g:
                hh = (b - r) / d + 2;
                break;
            default:
                hh = (r - g) / d + 4;
        }
        hh /= 6;
    }

    const H = Math.round(hh * 360);
    const S = Math.round(s * 100);
    const L = Math.round(l * 100);
    return `${H} ${S}% ${L}%`;
}

/* ====================== Favicon helpers ====================== */

function ensureFaviconLink(): HTMLLinkElement {
    // Prefer rel="icon", but also handle existing "shortcut icon"
    let link = document.querySelector<HTMLLinkElement>('link[rel="icon"]');
    if (!link) {
        link = document.createElement("link");
        link.rel = "icon";
        document.head.appendChild(link);
    }
    return link;
}

function setFavicon(href: string) {
    const link = ensureFaviconLink();
    link.href = href || DEFAULT_FAVICON;
}

/* ====================== Provider ====================== */

export function BrandingProvider({ children }: { children: React.ReactNode }) {
    const [branding, setBranding] = React.useState<Branding | null>(null);
    const [isLoaded, setIsLoaded] = React.useState(false);

    const applyThemeVars = React.useCallback((b: Branding | null) => {
        const primary = b?.primaryColor || DEFAULT_PRIMARY;
        const secondary = b?.secondaryColor || DEFAULT_SECONDARY;
        setCssVar("--primary", hexToHslTuple(primary));
        setCssVar("--secondary", hexToHslTuple(secondary));
    }, []);

    const applyInitialFavicon = React.useCallback((b: Branding | null) => {
        const src = b?.faviconUrl?.trim() || DEFAULT_FAVICON;
        setFavicon(src);
    }, []);

    const fetchBranding = React.useCallback(async () => {
        try {
            const res = await fetch(`${process.env.NEXT_PUBLIC_API_BASE}/api/branding`, {
                method: "GET",
                credentials: "include",
                headers: { "Accept": "application/json" },
            });
            if (!res.ok) {
                throw new Error(`GET /api/branding failed: ${res.status}`);
            }
            const data = (await res.json()) as Branding;
            setBranding(data);
            // apply CSS + favicon
            applyThemeVars(data);
            applyInitialFavicon(data);
        } catch (e) {
            // fall back to defaults if fetch fails
            setBranding({
                primaryColor: DEFAULT_PRIMARY,
                secondaryColor: DEFAULT_SECONDARY,
                logoLightUrl: "",
                logoDarkUrl: "",
                loginBackgroundUrl: "",
                faviconUrl: "",
                emailHeader: "<h1>{{org_name}}</h1>",
                emailFooter: "<p>Copyright 2025. All rights reserved.</p>",
                customCss: "/* ... */",
                allowClientThemeToggle: true,
            });
            applyThemeVars(null);
            applyInitialFavicon(null);
            // eslint-disable-next-line no-console
            console.warn(e);
        } finally {
            setIsLoaded(true);
        }
    }, [applyInitialFavicon, applyThemeVars]);

    React.useEffect(() => {
        fetchBranding();
    }, [fetchBranding]);

    /**
     * applyPreview:
     * - Accepts partial { primaryColor?, secondaryColor?, faviconUrl? }
     * - Applies CSS vars and/or favicon temporarily without mutating `branding`.
     */
    const applyPreview = React.useCallback(
        (patch: PreviewPatch) => {
            if (patch.primaryColor) {
                setCssVar("--primary", hexToHslTuple(patch.primaryColor));
            }
            if (patch.secondaryColor) {
                setCssVar("--secondary", hexToHslTuple(patch.secondaryColor));
            }
            if (patch.faviconUrl !== undefined) {
                setFavicon(patch.faviconUrl?.trim() || DEFAULT_FAVICON);
            }
        },
        []
    );

    /**
     * clearPreview:
     * - Reapplies CSS vars + favicon from the current saved branding (or defaults)
     */
    const clearPreview = React.useCallback(() => {
        applyThemeVars(branding);
        applyInitialFavicon(branding);
    }, [applyInitialFavicon, applyThemeVars, branding]);

    const value: BrandingContextType = React.useMemo(
        () => ({ branding, isLoaded, applyPreview, clearPreview, refetch: fetchBranding }),
        [branding, isLoaded, applyPreview, clearPreview, fetchBranding]
    );

    return <BrandingContext.Provider value={value}>{children}</BrandingContext.Provider>;
}

export function useBranding() {
    const ctx = React.useContext(BrandingContext);
    if (!ctx) throw new Error("useBranding must be used within BrandingProvider");
    return ctx;
}

########## END FILE:   app\providers\BrandingProvider.tsx ##########

########## BEGIN FILE: components\otp-input.tsx ##########
!! Missing file: components\otp-input.tsx !!
########## END FILE:   components\otp-input.tsx ##########

########## BEGIN FILE: lib\api.ts ##########
// lib/api.ts
// Centralized typed API client used by the frontend (Next.js / React).
// It reads NEXT_PUBLIC_API_BASE for the backend base URL.

// ---------------------------- ENV / BASE ------------------------------------
const API_BASE =
  (typeof process !== "undefined" && process.env.NEXT_PUBLIC_API_BASE) || "";

// Utility to join base + path safely
function url(path: string) {
  if (!API_BASE) return path;
  return `${API_BASE.replace(/\/+$/, "")}${path.startsWith("/") ? "" : "/"}${path}`;
}

type JsonInit = Omit<RequestInit, "body" | "method"> & {
  body?: any;
  method?: "GET" | "POST" | "PUT" | "PATCH" | "DELETE";
};

// unified fetch wrapper w/ JSON
export async function jfetch<T>(path: string, init: JsonInit = {}): Promise<T> {
  const { body, ...rest } = init;
  const res = await fetch(url(path), {
    method: init.method ?? (body != null ? "POST" : "GET"),
    credentials: "include",
    headers: {
      "Content-Type": "application/json",
      ...(init.headers ?? {}),
    },
    body: body != null ? JSON.stringify(body) : undefined,
    ...rest,
  });

  if (!res.ok) {
    // try to surface JSON message; fall back to text
    let msg = "";
    try {
      const data = await res.json();
      msg = typeof (data as any)?.message === "string" ? (data as any).message : JSON.stringify(data);
    } catch {
      try {
        msg = await res.text();
      } catch {
        // ignore
      }
    }
    const err = new Error(msg || `Request failed: ${res.status}`);
    (err as any).status = res.status; // preserve status for caller fallbacks
    throw err;
  }

  if (res.status === 204) return undefined as unknown as T;
  try {
    return (await res.json()) as T;
  } catch {
    // when backend returns 200 with empty body
    return undefined as unknown as T;
  }
}

// ---------------------------------------------------------------------------
// Devices (grid + details)
// ---------------------------------------------------------------------------
export type Device = {
  id: string;
  hostname: string;
  os: string;
  arch?: string | null;
  lastSeen?: string | null;
  status: "online" | "offline";
  client?: string | null;
  site?: string | null;
  user?: string | string[] | null;
};

export type DevicesResponse = {
  items: Device[];
  nextCursor: string | null;
};

export type DeviceFilters = {
  q?: string;
  status?: "online" | "offline";
  os?: string[];
};

export async function fetchDevices(
  pageSize = 25,
  cursor: string | null = null,
  filters?: DeviceFilters
): Promise<DevicesResponse> {
  const sp = new URLSearchParams();
  sp.set("pageSize", String(pageSize));
  if (cursor) sp.set("cursor", cursor);
  if (filters?.q) sp.set("q", filters.q);
  if (filters?.status) sp.set("status", filters.status);
  (filters?.os ?? []).forEach((o) => sp.append("os", o));
  return await jfetch<DevicesResponse>(`/api/devices?${sp.toString()}`);
}

export async function fetchDevice(id: string): Promise<Device> {
  return await jfetch<Device>(`/api/devices/${encodeURIComponent(id)}`);
}

// ---------------------------------------------------------------------------
// Device insights (checks / software)
// ---------------------------------------------------------------------------
export type DeviceCheck = {
  id: string;
  name: string;
  status: "Passing" | "Warning" | "Failing";
  lastRun: string;
  output: string;
};

export async function fetchDeviceChecks(deviceId: string): Promise<{ items: DeviceCheck[] }> {
  return await jfetch(`/api/devices/${encodeURIComponent(deviceId)}/checks`);
}

export type DeviceSoftware = {
  id: string;
  name: string;
  version: string;
  publisher?: string | null;
  installDate?: string | null;
};

export async function fetchDeviceSoftware(deviceId: string): Promise<{ items: DeviceSoftware[] }> {
  return await jfetch(`/api/devices/${encodeURIComponent(deviceId)}/software`);
}

// ---------------------------------------------------------------------------
// Device actions
// ---------------------------------------------------------------------------
export async function rebootDevice(id: string): Promise<{ accepted: true; jobId: string }> {
  return await jfetch(`/api/devices/${encodeURIComponent(id)}/actions/reboot`, { method: "POST" });
}
export async function patchDevice(id: string): Promise<{ accepted: true; jobId: string }> {
  return await jfetch(`/api/devices/${encodeURIComponent(id)}/actions/patch`, { method: "POST" });
}

// ---------------------------------------------------------------------------
// Automation / Runs
// ---------------------------------------------------------------------------
export type RunScriptRequest = {
  deviceId: string;
  script: string;
  shell?: "powershell" | "bash" | "cmd";
  timeoutSec?: number;
};

export async function postRunScript(req: RunScriptRequest): Promise<{ jobId: string }> {
  return await jfetch(`/api/automation/runs`, { method: "POST", body: req });
}

export type JobSnapshot = {
  jobId: string;
  deviceId: string;
  status: "queued" | "running" | "succeeded" | "failed" | "canceled";
  log: string;
  exitCode?: number | null;
  startedAt: number;
  finishedAt?: number | null;
};

export async function fetchJob(jobId: string): Promise<JobSnapshot> {
  return await jfetch(`/api/automation/runs/${encodeURIComponent(jobId)}`);
}
export async function fetchJobLog(jobId: string): Promise<{ jobId: string; log: string }> {
  return await jfetch(`/api/automation/runs/${encodeURIComponent(jobId)}/log`);
}

// ---------------------------------------------------------------------------
// Admin → Database configuration
// ---------------------------------------------------------------------------
export type DbEngine = "postgresql" | "mysql" | "mssql" | "sqlite" | "mongodb";
export type DbAuthMode = "fields" | "url";
export type StorageDomain =
  | "users" | "roles" | "sessions" | "audit_logs" | "devices" | "policies" | "email_queue";

export type DatabaseMappings = Record<StorageDomain, string>;

export type DatabaseConfig = {
  enabled: boolean;
  engine: DbEngine;
  authMode: DbAuthMode;
  url?: string;
  host?: string;
  port?: number;
  dbName?: string;
  username?: string;
  password?: string;
  ssl: boolean;
  poolMin: number;
  poolMax: number;
  readReplicas?: string;
  mappings: DatabaseMappings;
};

export type DbTestResult = {
  ok: boolean;
  engine: DbEngine;
  primary: { ok: boolean; message?: string };
  replicas?: Array<{ url: string; ok: boolean; message?: string }>;
  note?: string;
};

export async function getDatabaseConfig(): Promise<DatabaseConfig | { enabled: false }> {
  return await jfetch(`/api/admin/database`);
}

export async function testDatabaseConfig(cfg: DatabaseConfig): Promise<DbTestResult> {
  return await jfetch(`/api/admin/database/test`, { method: "POST", body: cfg });
}

export async function saveDatabaseConfig(cfg: DatabaseConfig): Promise<void> {
  await jfetch<void>(`/api/admin/database/save`, { method: "POST", body: cfg });
}

export async function dryRunDatabaseMigration(): Promise<{ ok: true; destructive: false; steps: string[] }> {
  return await jfetch(`/api/admin/database/migrate/dry-run`, { method: "POST" });
}

// --- Company profile (admin) ---
export type CompanyProfile = {
  name: string;
  legalName?: string;
  email?: string;
  phone?: string;
  fax?: string;
  website?: string;
  vatTin?: string;
  address1?: string;
  address2?: string;
  city?: string;
  state?: string;
  postal?: string;
  country?: string;
};

export async function getCompanyProfile(): Promise<CompanyProfile> {
  return await jfetch(`/api/admin/company`);
}

export async function saveCompanyProfile(p: CompanyProfile): Promise<void> {
  await jfetch(`/api/admin/company/save`, { method: "POST", body: p });
}

// --- Localization (admin) ---
export type LocalizationSettings = {
  language: string;                // "en-US"
  dateFormat: string;              // "MM/DD/YYYY"
  timeFormat: "12h" | "24h";       // strictly 12h/24h for UI consistency
  numberFormat: string;            // "1,234.56"
  timeZone: string;                // "America/New_York"
  firstDayOfWeek: "sunday" | "monday";
  currency?: string;               // "USD"
};

export async function getLocalizationSettings(): Promise<LocalizationSettings> {
  const res = await jfetch<LocalizationSettings | { exists: false }>(`/api/admin/localization`);
  if ((res as any)?.exists === false) {
    return {
      language: "en-US",
      dateFormat: "MM/DD/YYYY",
      timeFormat: "12h",
      numberFormat: "1,234.56",
      timeZone: "America/New_York",
      firstDayOfWeek: "sunday",
      currency: "USD",
    };
  }
  // Back-compat: normalize any legacy strings to the union
  const tfRaw = (res as any).timeFormat as string | undefined;
  const timeFormat: "12h" | "24h" = tfRaw === "24h" || tfRaw === "HH:mm" ? "24h" : "12h";
  return { ...(res as LocalizationSettings), timeFormat };
}

export async function saveLocalizationSettings(p: LocalizationSettings): Promise<void> {
  await jfetch(`/api/admin/localization/save`, { method: "POST", body: p });
}

// --- Support & Legal (admin) ---
export type SupportLegalSettings = {
  id?: number;                 // present on GET only
  supportEmail?: string;
  supportPhone?: string;
  knowledgeBaseUrl?: string;
  statusPageUrl?: string;
  privacyPolicyUrl?: string;
  termsUrl?: string;
  gdprContactEmail?: string;
  legalAddress?: string;
  ticketPortalUrl?: string;
  phoneHours?: string;
  notesHtml?: string;
};

export async function getSupportLegalSettings(): Promise<SupportLegalSettings> {
  return await jfetch(`/api/admin/support-legal`);
}

export async function saveSupportLegalSettings(
  p: Omit<SupportLegalSettings, "id">
): Promise<void> {
  await jfetch(`/api/admin/support-legal/save`, { method: "POST", body: p });
}

// ======================= Users & Roles (Admin) =======================
export type RoleDTO = { id: string; name: string };
export type UserDTO = {
  id: string;
  name: string;
  email: string;
  role: string;
  twoFactorEnabled: boolean;
  suspended: boolean;
  lastSeen: string | null;
  status: "active" | "invited" | "suspended";
  createdAt?: string;
  updatedAt?: string;

  // Optional profile fields (present if your DB exposes them)
  phone?: string | null;
  address1?: string | null;
  address2?: string | null;
  city?: string | null;
  state?: string | null;
  postal?: string | null;
  country?: string | null;
};

export async function getAdminRoles(): Promise<{ items: RoleDTO[] }> {
  // Wrap server response (array) into {items} for consistency
  const arr = await jfetch<RoleDTO[]>(`/api/admin/users/roles`);
  return { items: arr };
}

export async function getAdminUsers(): Promise<{ items: UserDTO[]; total?: number }> {
  // backend returns {items, total}
  return await jfetch(`/api/admin/users`);
}

export type InvitePayload = { name?: string; email: string; role?: string; message?: string };

/** Invite one-by-one under the hood to keep types simple */
export async function inviteUsers(invites: InvitePayload[]): Promise<{ created: UserDTO[] }> {
  const created: UserDTO[] = [];
  for (const i of invites) {
    const resp = await jfetch<{ id: string }>(`/api/admin/users/invite`, {
      method: "POST",
      body: i,
    });
    created.push({
      id: resp.id,
      name: i.name ?? i.email.split("@")[0],
      email: i.email,
      role: i.role ?? "User",
      status: "invited",
      twoFactorEnabled: false,
      suspended: false,
      lastSeen: null,
    });
  }
  return { created };
}

/** Change a user's role */
export async function updateUserRole(userId: string, role: string): Promise<void> {
  await jfetch<void>(`/api/admin/users/${encodeURIComponent(userId)}/role`, {
    method: "PATCH",
    body: { role },
  });
}

/** Trigger a 2FA reset */
export async function resetUser2FA(userId: string): Promise<void> {
  await jfetch<void>(`/api/admin/users/${encodeURIComponent(userId)}/reset-2fa`, {
    method: "POST",
  });
}

/** Remove (delete) a user */
export async function removeUser(userId: string): Promise<void> {
  await jfetch<void>(`/api/admin/users/${encodeURIComponent(userId)}`, {
    method: "DELETE",
  });
}

/** Suspend / Unsuspend user */
export async function setUserSuspended(userId: string, suspended: boolean): Promise<void> {
  await jfetch<void>(`/api/admin/users/${encodeURIComponent(userId)}/suspend`, {
    method: "POST",
    body: { suspended },
  });
}

/* -------- Admin create + reset password -------- */
export type CreateUserPayload = {
  name: string;
  email: string;
  role?: string;
  password: string;
  status?: "active" | "invited" | "suspended";
};

export async function createAdminUser(p: CreateUserPayload): Promise<{ id: string }> {
  return await jfetch(`/api/admin/users/create`, { method: "POST", body: p });
}

export async function setUserPassword(userId: string, password: string): Promise<void> {
  await jfetch(`/api/admin/users/${encodeURIComponent(userId)}/password`, {
    method: "POST",
    body: { password },
  });
}

/* -------- NEW: Update user details (partial) -------- */
export type UpdateUserPayload = Partial<{
  name: string;
  email: string;
  role: string;
  phone: string;
  address1: string;
  address2: string;
  city: string;
  state: string;
  postal: string;
  country: string;
}>;

export async function updateUser(userId: string, p: UpdateUserPayload): Promise<void> {
  await jfetch<void>(`/api/admin/users/${encodeURIComponent(userId)}`, {
    method: "PATCH",
    body: p,
  });
}

// ---------------------------------------------------------------------------
// Account (current user) - Profile
// ---------------------------------------------------------------------------
export type MeProfile = {
  id: string;
  name: string;
  email: string;
  username?: string;
  phone?: string | null;
  address1?: string | null;
  address2?: string | null;
  city?: string | null;
  state?: string | null;
  postal?: string | null;
  country?: string | null;
  timezone?: string | null;
  locale?: string | null;
  avatarUrl?: string | null; // backend may store as avatar_url; mapped server-side
  createdAt?: string;
  updatedAt?: string;
};

export type UpdateMePayload = Partial<{
  name: string;
  email: string;
  username: string;
  phone: string | null;
  address1: string | null;
  address2: string | null;
  city: string | null;
  state: string | null;
  postal: string | null;
  country: string | null;
  timezone: string | null;
  locale: string | null;
  avatarUrl: string | null;
}>;

/** Load the signed-in user's profile */
export async function getMyProfile(): Promise<MeProfile> {
  return await jfetch<MeProfile>(`/api/users/me`);
}

/** Patch the signed-in user's profile (only sends provided keys) */
export async function updateMyProfile(patch: UpdateMePayload): Promise<MeProfile> {
  const body = Object.fromEntries(Object.entries(patch).filter(([, v]) => v !== undefined));
  return await jfetch<MeProfile>(`/api/users/me`, { method: "PATCH", body });
}

// ---------------------------------------------------------------------------
// Account (current user) - Security & Sessions (legacy helpers kept)
// ---------------------------------------------------------------------------
export type SecuritySettings = {
  twoFaEnabled: boolean;
  autoRevokeSessions?: boolean;
};

export async function getSecuritySettings(): Promise<SecuritySettings> {
  return await jfetch(`/api/users/security`);
}
export async function saveSecuritySettings(p: Partial<SecuritySettings>): Promise<void> {
  await jfetch(`/api/users/security`, { method: "PATCH", body: p });
}

export type SessionDTO = {
  id: string;
  device: string;
  ip: string;
  lastActive: string;
  current: boolean;
  city?: string;
  isp?: string;
  trusted?: boolean;
};

export async function listSessions(): Promise<{ items: SessionDTO[] }> {
  return await jfetch(`/api/users/sessions`);
}
export async function toggleTrustSession(sessionId: string, trusted: boolean): Promise<void> {
  await jfetch(`/api/users/sessions/${encodeURIComponent(sessionId)}/trust`, {
    method: "POST",
    body: { trusted },
  });
}
export async function revokeSession(sessionId: string): Promise<void> {
  await jfetch(`/api/users/sessions/${encodeURIComponent(sessionId)}`, { method: "DELETE" });
}
export async function revokeAllSessions(): Promise<void> {
  await jfetch(`/api/users/sessions`, { method: "DELETE" });
}

// ---------------------------------------------------------------------------
// Account (current user) - Notifications
// ---------------------------------------------------------------------------
export type NotificationSettings = {
  email: boolean;
  push: boolean;
  product: boolean;
  digest: "off" | "daily" | "weekly";
  quiet?: { enabled: boolean; start?: string; end?: string };
  products?: string[];
};

export async function getNotificationSettings(): Promise<NotificationSettings> {
  return await jfetch(`/api/users/notifications`);
}
export async function saveNotificationSettings(p: Partial<NotificationSettings>): Promise<void> {
  await jfetch(`/api/users/notifications`, { method: "PATCH", body: p });
}

// ---------------------------------------------------------------------------
// Account (current user) - Integrations (Slack + generic webhook)
// ---------------------------------------------------------------------------
export type IntegrationsSettings = {
  slackWebhook?: string;
  webhookUrl?: string;
  webhookSigningSecret?: string;
  events?: string[];
};

export async function getIntegrationsSettings(): Promise<IntegrationsSettings> {
  return await jfetch(`/api/users/integrations`);
}
export async function saveIntegrationsSettings(p: Partial<IntegrationsSettings>): Promise<void> {
  await jfetch(`/api/users/integrations`, { method: "PATCH", body: p });
}

export async function testSlackWebhook(urlStr: string): Promise<{ ok: boolean; status: number; ms?: number }> {
  return await jfetch(`/api/users/integrations/test/slack`, { method: "POST", body: { url: urlStr } });
}
export async function testGenericWebhook(urlStr: string): Promise<{ ok: boolean; status: number; ms?: number }> {
  return await jfetch(`/api/users/integrations/test/webhook`, { method: "POST", body: { url: urlStr } });
}
export async function rotateSigningSecret(): Promise<{ secret: string }> {
  return await jfetch(`/api/users/integrations/rotate-signing-secret`, { method: "POST" });
}

// ---------------------------------------------------------------------------
// Account (current user) - API Keys
// ---------------------------------------------------------------------------
export type ApiKeyDTO = {
  id: string;          // token id (e.g., "rk_live_xxx")
  label: string;
  lastUsed?: string;
  scopes?: string[];
  expiresAt?: string;  // iso or empty string if never
};

export async function listApiKeys(): Promise<{ items: ApiKeyDTO[] }> {
  const arr = await jfetch<ApiKeyDTO[]>(`/api/users/api-keys`);
  return { items: arr };
}

export async function createApiKey(
  label: string,
  scopes: string[],
  expiresIn: "never" | "30d" | "90d",
  ipAllowlist?: string
): Promise<ApiKeyDTO> {
  return await jfetch(`/api/users/api-keys`, {
    method: "POST",
    body: { label, scopes, expiresIn, ipAllowlist },
  });
}

export async function revokeApiKey(id: string): Promise<void> {
  await jfetch(`/api/users/api-keys/${encodeURIComponent(id)}`, { method: "DELETE" });
}

export async function regenerateApiKey(id: string): Promise<{ oldId: string; newKey: string }> {
  return await jfetch(`/api/users/api-keys/${encodeURIComponent(id)}/regenerate`, { method: "POST" });
}

// Upload avatar to the dedicated endpoint
export async function uploadMyAvatar(file: File): Promise<{ url: string }> {
  const form = new FormData();
  form.append("file", file, file.name || "avatar.png");

  const base = (typeof process !== "undefined" && process.env.NEXT_PUBLIC_API_BASE) || "";
  const res = await fetch(`${base.replace(/\/+$/, "")}/api/users/me/avatar`, {
    method: "POST",
    credentials: "include",
    body: form,
  });
  if (!res.ok) {
    let msg = "";
    try { msg = (await res.json())?.message || ""; } catch { }
    if (!msg) try { msg = await res.text(); } catch { }
    throw new Error(msg || `Upload failed (${res.status})`);
  }
  return (await res.json()) as { url: string };
}

export async function removeMyAvatar(): Promise<void> {
  await jfetch<void>(`/api/users/me/avatar`, { method: "DELETE" });
}

/* ============================================================================
   NEW: Security Overview + TOTP + Sessions (ME scope) + PAT + WebAuthn stubs
   ==========================================================================*/

// ---- Types used by the Security tab ----
export type SecurityEvent = {
  id: string;
  type:
  | "signed_in"
  | "password_changed"
  | "2fa_enabled"
  | "2fa_disabled"
  | "recovery_codes_regenerated"
  | "session_revoked";
  at: string;
  ip?: string;
  userAgent?: string;
};

export type WebAuthnCredential = {
  id: string;
  label: string;
  createdAt: string;
  lastUsedAt?: string;
};

export type RecoveryCodes = string[];

// ---- Sessions (ME) ----
export type Session = {
  id: string;
  createdAt: string;
  lastSeenAt: string | null;
  ip: string | null;
  userAgent: string | null;
  current: boolean;
  trusted?: boolean;
  label?: string | null;
  revokedAt?: string | null; // <-- include so we can filter locally
};

export type SecurityOverview = {
  twoFactorEnabled: boolean;
  sessions: Session[];
  events: SecurityEvent[];
  webAuthn?: WebAuthnCredential[];
};

export type TOTPInit = { secret: string; otpauthUrl: string; qrPngDataUrl: string };

// ---- Overview ----
export async function getSecurityOverview(): Promise<SecurityOverview> {
  return await jfetch<SecurityOverview>(`/api/users/me/security`);
}

// ---- Change Password ----
export async function changePasswordSelf(current: string, next: string): Promise<void> {
  await jfetch(`/api/users/me/password`, { method: "POST", body: { current, next } });
}

// ---- TOTP 2FA ----
export async function start2FA(): Promise<TOTPInit> {
  return await jfetch<TOTPInit>(`/api/users/me/2fa/start`, { method: "POST" });
}

export async function confirm2FA(p: { code: string }): Promise<void> {
  await jfetch(`/api/users/me/2fa/confirm`, { method: "POST", body: p });
}

export async function disable2FA(p?: { code?: string; recoveryCode?: string }): Promise<void> {
  await jfetch(`/api/users/me/2fa/disable`, { method: "POST", body: p ?? {} });
}

export async function regenerateRecoveryCodes(): Promise<RecoveryCodes> {
  const res = await jfetch<{ recoveryCodes: string[] }>(`/api/users/me/2fa/recovery/regen`, {
    method: "POST",
  });
  return res.recoveryCodes;
}

// ---- Sessions (ME) ----
// NOTE: some servers include revoked sessions in the list; we filter them out.
export async function listMySessions(): Promise<{ items: Session[]; currentJti?: string }> {
  const res = await jfetch<{ items: Session[]; currentJti?: string }>(`/api/users/me/sessions/`);
  const items = (res.items ?? []).filter((s) => !s.revokedAt); // <-- hide revoked
  return { items, currentJti: res.currentJti };
}

export async function revokeAllOtherSessions(): Promise<void> {
  await jfetch(`/api/users/me/sessions/revoke-all`, { method: "POST" });
}

/**
 * Revoke a single session (ME).
 * Tries a sequence of plausible endpoints so we work with whatever the backend exposes.
 */
export async function revokeMySession(sessionId: string): Promise<void> {
  const enc = encodeURIComponent(sessionId);
  const base = `/api/users/me/sessions/${enc}`;

  // 1) Preferred: DELETE /me/sessions/:id
  try {
    await jfetch(base, { method: "DELETE" });
    return;
  } catch (e: any) {
    const msg = String(e?.message || "").toLowerCase();
    const status = e?.status ?? e?.code;
    if (!(status === 404 || status === 405 || msg.includes("cannot delete"))) throw e;
  }

  // 2) Alt: POST /me/sessions/:id/revoke
  try {
    await jfetch(`${base}/revoke`, { method: "POST" });
    return;
  } catch (e: any) {
    const status = e?.status ?? e?.code;
    if (!(status === 404 || status === 405)) throw e;
  }

  // 3) Alt: POST /me/sessions/revoke  { sessionId }
  try {
    await jfetch(`/api/users/me/sessions/revoke`, { method: "POST", body: { sessionId } });
    return;
  } catch (e: any) {
    const status = e?.status ?? e?.code;
    if (!(status === 404 || status === 405)) throw e;
  }

  // 4) Alt: POST /me/sessions/revoke/:id
  try {
    await jfetch(`/api/users/me/sessions/revoke/${enc}`, { method: "POST" });
    return;
  } catch (e: any) {
    const status = e?.status ?? e?.code;
    if (!(status === 404 || status === 405)) throw e;
  }

  // 5) Last-resort: PATCH /me/sessions/:id { action: "revoke" }
  await jfetch(base, { method: "PATCH", body: { action: "revoke" } });
}

/** Trust / untrust a session (ME) with fallbacks similar to revoke */
export async function trustMySession(
  sessionId: string,
  trusted: boolean
): Promise<{ trusted: boolean }> {
  const enc = encodeURIComponent(sessionId);
  const base = `/api/users/me/sessions/${enc}`;

  // 1) Preferred: POST /me/sessions/:id/trust { trusted }
  try {
    return await jfetch(`${base}/trust`, { method: "POST", body: { trusted } });
  } catch (e: any) {
    const status = e?.status ?? e?.code;
    if (!(status === 404 || status === 405)) throw e;
  }

  // 2) Alt: POST /me/sessions/trust { sessionId, trusted }
  try {
    return await jfetch(`/api/users/me/sessions/trust`, {
      method: "POST",
      body: { sessionId, trusted },
    });
  } catch (e: any) {
    const status = e?.status ?? e?.code;
    if (!(status === 404 || status === 405)) throw e;
  }

  // 3) Last-resort: PATCH /me/sessions/:id { trusted }
  return await jfetch(base, { method: "PATCH", body: { trusted } });
}

/** Optional: label a session (ME) */
export async function labelMySession(sessionId: string, label: string): Promise<void> {
  await jfetch(`/api/users/me/sessions/${encodeURIComponent(sessionId)}/label`, {
    method: "POST",
    body: { label },
  });
}

// lib/api.ts → mapMeSessionToDTO
export function mapMeSessionToDTO(s: Session): SessionDTO {
  return {
    id: s.id,
    device: s.label || s.userAgent || "Unknown device",
    ip: s.ip ?? "",                 // string (never undefined)
    lastActive: s.lastSeenAt ?? "", // string (never undefined)
    current: !!s.current,           // boolean
    city: undefined,
    isp: undefined,
    trusted: s.trusted ?? false,
  };
}


// ---- Personal Tokens (ME) ----
export type PersonalToken = {
  id: string;
  name: string;
  createdAt: string;
  lastUsedAt?: string;
  revokedAt?: string;
};

export async function listMyTokens(): Promise<{ items: PersonalToken[] }> {
  return await jfetch(`/api/users/me/tokens`);
}

export async function createMyToken(name: string): Promise<{ token: string; id: string }> {
  return await jfetch(`/api/users/me/tokens`, { method: "POST", body: { name } });
}

export async function revokeMyToken(id: string): Promise<void> {
  await jfetch(`/api/users/me/tokens/revoke`, { method: "POST", body: { id } });
}

// ---- WebAuthn (optional / stubbed) ----
export async function webauthnCreateOptions(): Promise<PublicKeyCredentialCreationOptions> {
  return await jfetch(`/api/users/me/webauthn/create-options`);
}

export async function webauthnFinishRegistration(attestationResponse: any): Promise<WebAuthnCredential> {
  return await jfetch(`/api/users/me/webauthn/finish`, { method: "POST", body: attestationResponse });
}

export async function deleteWebAuthnCredential(id: string): Promise<void> {
  await jfetch(`/api/users/me/webauthn/${encodeURIComponent(id)}`, { method: "DELETE" });
}

########## END FILE:   lib\api.ts ##########

########## BEGIN FILE: lib\auth.ts ##########
// app/lib/auth.ts
export async function getMe() {
    const res = await fetch(`${process.env.NEXT_PUBLIC_API_BASE}/api/auth/me`, {
        credentials: 'include',
    });
    return res.json() as Promise<{ user: null | { id: string; email: string; name: string; role: string } }>;
}
export async function logout() {
    await fetch(`${process.env.NEXT_PUBLIC_API_BASE}/api/auth/logout`, { method: 'POST', credentials: 'include' });
}

########## END FILE:   lib\auth.ts ##########

########## BEGIN FILE: lib\toast.tsx ##########
"use client";
import * as React from "react";
import { cn } from "@/lib/utils";

export type ToastKind = "success" | "warning" | "destructive" | "default";
export type Toast = { id: string; title: string; desc?: string; kind?: ToastKind; action?: { label: string; onClick: () => void } };
type Store = { toasts: Toast[]; push: (t: Omit<Toast, "id">) => void; remove: (id: string) => void; };
const ToastCtx = React.createContext<Store | null>(null);

export function ToastProvider({ children }: { children: React.ReactNode }) {
  const [toasts, setToasts] = React.useState<Toast[]>([]);
  const remove = React.useCallback((id: string) => setToasts((x) => x.filter((t) => t.id !== id)), []);
  const push = React.useCallback((t: Omit<Toast, "id">) => {
    const id = Math.random().toString(36).slice(2);
    setToasts((prev) => [...prev, { id, kind: "default", ...t }]);
    window.setTimeout(() => remove(id), 4200);
  }, [remove]);
  const value = React.useMemo(() => ({ toasts, push, remove }), [toasts, push, remove]);
  return <ToastCtx.Provider value={value}>{children}</ToastCtx.Provider>;
}
export function useToast() { const ctx = React.useContext(ToastCtx); if (!ctx) throw new Error("useToast must be used within <ToastProvider>"); return ctx; }
export function ToastViewport() {
  const { toasts } = useToast();
  return (<div className="fixed bottom-4 right-4 z-[100] space-y-2">{toasts.map((t) => (<ToastItem key={t.id} toast={t} />))}</div>);
}
function ToastItem({ toast: t }: { toast: Toast }) {
  const { remove } = useToast();
  const klass = t.kind === "success" ? "border-emerald-200 bg-emerald-50 text-emerald-900 dark:border-emerald-700 dark:bg-emerald-900/20 dark:text-emerald-200"
    : t.kind === "warning" ? "border-amber-300 bg-amber-50 text-amber-900 dark:border-amber-600 dark:bg-amber-900/20 dark:text-amber-200"
    : t.kind === "destructive" ? "border-red-200 bg-red-50 text-red-900 dark:border-red-700 dark:bg-red-900/20 dark:text-red-200"
    : "border-border bg-card text-card-foreground";
  return (
    <div className={cn("w-[340px] rounded-md border px-4 py-3 shadow-md", klass)} role="status" aria-live="polite">
      <div className="flex items-start justify-between gap-3">
        <div>
          <div className="text-sm font-medium">{t.title}</div>
          {t.desc && <div className="mt-1 text-xs/5 opacity-90">{t.desc}</div>}
        </div>
        <div className="flex items-center gap-2">
          {t.action && (<button className="text-xs underline underline-offset-2 hover:opacity-80" onClick={t.action.onClick}>{t.action.label}</button>)}
          <button aria-label="Dismiss" className="text-xs opacity-70 hover:opacity-100" onClick={() => remove(t.id)}>×</button>
        </div>
      </div>
    </div>
  );
}

########## END FILE:   lib\toast.tsx ##########

########## BEGIN FILE: middleware.ts ##########
import type { NextRequest } from "next/server";
import { NextResponse } from "next/server";

const PUBLIC_PATHS = new Set<string>([
    "/login",
    "/favicon.ico",
    "/robots.txt",
    "/sitemap.xml",
]);

export function middleware(req: NextRequest) {
    const { pathname } = req.nextUrl;

    // Normalize legacy route to the new one
    if (pathname === "/auth/login") {
        const url = req.nextUrl.clone();
        url.pathname = "/login";
        // default to home after login
        url.searchParams.set("next", "/");
        return NextResponse.redirect(url);
    }

    // Never run on /login or static assets (avoid loops)
    if (
        pathname === "/login" ||
        pathname.startsWith("/_next/") ||
        pathname.startsWith("/static/") ||
        pathname.startsWith("/images/") ||
        pathname.startsWith("/fonts/")
    ) {
        return NextResponse.next();
    }

    // Allow any frontend /api if you have them
    if (pathname.startsWith("/api/")) {
        return NextResponse.next();
    }

    if (PUBLIC_PATHS.has(pathname)) {
        return NextResponse.next();
    }

    const token = req.cookies.get("auth_token")?.value;

    if (!token) {
        const url = req.nextUrl.clone();
        url.pathname = "/login";
        // set next to the requested path; it’s sanitized on the login page
        url.searchParams.set("next", pathname || "/");
        return NextResponse.redirect(url);
    }

    return NextResponse.next();
}

export const config = {
    matcher: [
        "/((?!_next/static|_next/image|favicon.ico|robots.txt|sitemap.xml|login).*)",
    ],
};

########## END FILE:   middleware.ts ##########

========== SUMMARY ==========
Generated: 2025-10-21 13:29:22
RepoRoot : C:\Users\Last Stop\Documents\Programming Projects\RemoteIQ V3 - Copy\remoteiq-frontend
Mode     : STRICT (no fallbacks)

Missing files (also noted inline above):
  - components\otp-input.tsx
