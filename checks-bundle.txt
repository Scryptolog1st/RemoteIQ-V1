### RemoteIQ Checks Bundle
# Generated: 2025-10-30 20:55:55Z
# Repo root: C:\Users\Last Stop\Documents\Programming Projects\RemoteIQ V6
# Files found: 51

===== FILE: remoteiq-minimal-e2e\backend\src\checks\checks.module.ts (20 lines) =====
// backend/src/checks/checks.module.ts
import { Module, forwardRef } from '@nestjs/common';
import { ChecksService } from './checks.service';
import { ChecksController, DeviceChecksController } from './checks.controller';
import { StorageModule } from '../storage/storage.module';
import { CommonModule } from '../common/common.module'; // <-- add
import { WsModule } from '../ws/ws.module';             // (optional, only if you also use DashboardGateway)

@Module({
    imports: [
        StorageModule,
        CommonModule,               // <-- needed for UiSocketRegistry
        forwardRef(() => WsModule), // ok to keep if you’re also using DashboardGateway elsewhere
    ],
    controllers: [ChecksController, DeviceChecksController],
    providers: [ChecksService],
    exports: [ChecksService],
})
export class ChecksModule { }

===== END FILE remoteiq-minimal-e2e\backend\src\checks\checks.module.ts =====

===== FILE: remoteiq-minimal-e2e\backend\src\checks\checks.controller.ts (150 lines) =====
//remoteiq-minimal-e2e\backend\src\checks\checks.controller.ts

import {
    Body,
    Controller,
    Delete,
    Get,
    HttpCode,
    HttpStatus,
    Param,
    ParseUUIDPipe,
    Post,
    Put,
    Query,
} from '@nestjs/common';
import { IsBoolean, IsEnum, IsInt, IsOptional, IsString, IsUUID, Max, Min, ValidateIf } from 'class-validator';
import { ChecksService, CheckScope, CheckType } from './checks.service';

/* ========================= DTOs for /api/checks ========================== */

class ListChecksQuery {
    @IsOptional() @IsEnum(CheckScope) scope?: CheckScope;
    @IsOptional() @IsEnum(CheckType) type?: CheckType;
    @IsOptional() @IsBoolean() enabled?: boolean;
    @IsOptional() @IsUUID() clientId?: string;
    @IsOptional() @IsUUID() siteId?: string;
    @IsOptional() @IsUUID() deviceId?: string;
    @IsOptional() @IsInt() @Min(1) @Max(200) limit?: number;
    @IsOptional() @IsString() cursor?: string;
}

class CreateCheckDto {
    @IsEnum(CheckScope) scope!: CheckScope;
    @ValidateIf((o) => o.scope !== CheckScope.GLOBAL) @IsUUID() @IsOptional() scopeId?: string;

    @IsEnum(CheckType) type!: CheckType;

    @IsString() name!: string;
    @IsString() @IsOptional() description?: string;

    @IsOptional() config?: unknown;     // per-type JSON schema validated in service
    @IsOptional() threshold?: unknown;  // per-type JSON schema validated in service

    @IsString() severityDefault!: 'WARN' | 'CRIT';

    @IsInt() @Min(15) @Max(86400) intervalSec!: number;
    @IsInt() @Min(1) @Max(600) timeoutSec!: number;

    @IsBoolean() enabled!: boolean;
}

class UpdateCheckDto {
    @IsOptional() @IsEnum(CheckScope) scope?: CheckScope;
    @ValidateIf((o) => o.scope && o.scope !== CheckScope.GLOBAL) @IsUUID() @IsOptional() scopeId?: string;

    @IsOptional() @IsEnum(CheckType) type?: CheckType;
    @IsOptional() @IsString() name?: string;
    @IsOptional() @IsString() description?: string;
    @IsOptional() config?: unknown;
    @IsOptional() threshold?: unknown;
    @IsOptional() @IsString() severityDefault?: 'WARN' | 'CRIT';
    @IsOptional() @IsInt() @Min(15) @Max(86400) intervalSec?: number;
    @IsOptional() @IsInt() @Min(1) @Max(600) timeoutSec?: number;
    @IsOptional() @IsBoolean() enabled?: boolean;
}

class RunOnDemandDto {
    @IsOptional() deviceIds?: string[] | null;
}

/* ===================== Existing /api/checks controller ==================== */

@Controller('api/checks')
export class ChecksController {
    constructor(private readonly checks: ChecksService) { }

    // TODO: add @UseGuards(AuthGuard) once your authZ guard is ready.

    @Get()
    async list(@Query() query: ListChecksQuery) {
        return this.checks.list(query);
    }

    @Post()
    async create(@Body() dto: CreateCheckDto) {
        // NOTE: Service will perform per-type schema validation server-side.
        return this.checks.create({
            ...dto,
            createdBy: 'system', // TODO: replace with req.user.id
            updatedBy: null,
            createdAt: new Date().toISOString(),
            updatedAt: new Date().toISOString(),
            id: '00000000-0000-0000-0000-000000000000', // placeholder, service should generate
        } as any);
    }

    @Put(':id')
    async update(@Param('id', new ParseUUIDPipe()) id: string, @Body() dto: UpdateCheckDto) {
        return this.checks.update(id, dto as any);
    }

    @Delete(':id')
    @HttpCode(HttpStatus.NO_CONTENT)
    async remove(@Param('id', new ParseUUIDPipe()) id: string) {
        await this.checks.remove(id);
        return;
    }

    @Post(':id/assignments/rebuild')
    async rebuild(@Param('id', new ParseUUIDPipe()) id: string) {
        return this.checks.rebuildAssignments(id);
    }

    @Post(':id/run')
    async runOnDemand(@Param('id', new ParseUUIDPipe()) id: string, @Body() dto: RunOnDemandDto) {
        return this.checks.runOnDemand(id, dto);
    }
}

/* ================= New device-scoped /api/devices/:id/checks route ========= */

function clamp(n: any, min: number, max: number, def: number): number {
    const x = Number(n);
    if (!Number.isFinite(x)) return def;
    return Math.max(min, Math.min(max, Math.trunc(x)));
}

@Controller('api/devices')
export class DeviceChecksController {
    constructor(private readonly checks: ChecksService) { }

    /**
     * Device-scoped checks for the UI:
     * GET /api/devices/:deviceId/checks?limit=100
     *
     * Returns:
     *  { items: Array<{ id, name, status, lastRun, output, ...optional fields }> }
     *  Optional advanced fields (type, severity, metrics, thresholds, tags, maintenance, dedupeKey)
     *  will be included by the service when available.
     */
    @Get(':deviceId/checks')
    async deviceChecks(
        @Param('deviceId', new ParseUUIDPipe()) deviceId: string,
        @Query('limit') limit?: string,
    ) {
        const lim = clamp(limit, 1, 200, 100);
        return this.checks.listByDevice(deviceId, lim);
    }
}

===== END FILE remoteiq-minimal-e2e\backend\src\checks\checks.controller.ts =====

===== FILE: remoteiq-minimal-e2e\backend\src\checks\checks.service.ts (450 lines) =====
// backend/src/checks/checks.service.ts
import { Injectable, Logger, NotImplementedException } from '@nestjs/common';
import { PgPoolService } from '../storage/pg-pool.service';
import { UiSocketRegistry } from '../common/ui-socket-registry.service';

/* ========================= Types / helpers ========================= */

export enum CheckScope {
    DEVICE = 'DEVICE',
    SITE = 'SITE',
    CLIENT = 'CLIENT',
    GLOBAL = 'GLOBAL',
}

export enum CheckType {
    PING = 'PING',
    CPU = 'CPU',
    MEMORY = 'MEMORY',
    DISK = 'DISK',
    SERVICE = 'SERVICE',
    PROCESS = 'PROCESS',
    PORT = 'PORT',
    WINEVENT = 'WINEVENT',
    SOFTWARE = 'SOFTWARE',
    SECURITY = 'SECURITY',
    SCRIPT = 'SCRIPT',
    PATCH = 'PATCH',
    CERT = 'CERT',
    SMART = 'SMART',
    RDP = 'RDP',
    SMB = 'SMB',
    FIREWALL = 'FIREWALL',
}

export type DeviceCheckDTO = {
    id: string; // assignment id (device-scoped)
    name: string;
    status: 'Passing' | 'Warning' | 'Failing';
    lastRun: string | null;
    output: string;
};

type NormalizedRunStatus = 'OK' | 'WARN' | 'CRIT' | 'TIMEOUT' | 'UNKNOWN';

function normalizeStatus(s?: string | null): NormalizedRunStatus {
    const t = String(s || '').trim().toUpperCase();
    if (t === 'OK' || t === 'PASS' || t === 'PASSING') return 'OK';
    if (t === 'WARN' || t === 'WARNING') return 'WARN';
    if (t === 'TIMEOUT') return 'TIMEOUT';
    if (t === 'CRIT' || t === 'ERROR' || t === 'FAIL' || t === 'FAILING') return 'CRIT';
    return 'UNKNOWN';
}

function toUiStatus(s?: string | null): DeviceCheckDTO['status'] {
    switch (normalizeStatus(s)) {
        case 'OK': return 'Passing';
        case 'WARN': return 'Warning';
        default: return 'Failing';
    }
}

/* =============================== Service =============================== */

@Injectable()
export class ChecksService {
    private readonly logger = new Logger(ChecksService.name);

    // per-device debounce to avoid floods; value is NodeJS.Timeout in Node
    private readonly deviceDebounce = new Map<string, ReturnType<typeof setTimeout>>();

    constructor(
        private readonly pg: PgPoolService,
        private readonly uiSockets: UiSocketRegistry,
    ) { }

    /* ================= Schema guard (idempotent) ================= */

    /** Ensure minimal schema for checks exists (TEXT device_id). Safe to call often. */
    private async ensureSchema() {
        await this.pg.query(`
      CREATE EXTENSION IF NOT EXISTS pgcrypto;

      CREATE TABLE IF NOT EXISTS public.check_assignments (
        id          uuid PRIMARY KEY DEFAULT gen_random_uuid(),
        device_id   text NOT NULL,
        dedupe_key  text,
        check_type  text,
        check_name  text,
        created_at  timestamptz DEFAULT now(),
        updated_at  timestamptz DEFAULT now()
      );

      CREATE TABLE IF NOT EXISTS public.check_runs (
        id            uuid PRIMARY KEY DEFAULT gen_random_uuid(),
        assignment_id uuid,
        device_id     text NOT NULL,
        status        text NOT NULL,
        severity      text,
        metrics       jsonb,
        output        text,
        started_at    timestamptz,
        finished_at   timestamptz,
        created_at    timestamptz DEFAULT now()
      );

      -- Unique dedupe per device: explicit key OR type|name fallback
      CREATE UNIQUE INDEX IF NOT EXISTS check_assignments_uk
        ON public.check_assignments (
          device_id,
          COALESCE(
            NULLIF(dedupe_key, ''),
            LOWER(COALESCE(check_type,'')) || '|' || LOWER(COALESCE(check_name,''))
          )
        );

      CREATE INDEX IF NOT EXISTS check_assignments_device_id_idx ON public.check_assignments (device_id);
      CREATE INDEX IF NOT EXISTS check_runs_assignment_id_idx    ON public.check_runs (assignment_id);
      CREATE INDEX IF NOT EXISTS check_runs_device_id_idx        ON public.check_runs (device_id);
      CREATE INDEX IF NOT EXISTS check_runs_created_at_idx       ON public.check_runs (created_at);
    `);
    }

    /* ====================== Public read for UI ====================== */

    async listByDevice(deviceId: string, limit = 100): Promise<{ items: DeviceCheckDTO[] }> {
        if (!Number.isFinite(limit) || limit < 1) limit = 1;
        if (limit > 200) limit = 200;

        await this.ensureSchema();

        // Latest run per assignment + assignment name (no dependency on separate "checks" table)
        const sql = `
      WITH latest_run AS (
        SELECT
          cr.assignment_id,
          cr.status,
          cr.output,
          cr.finished_at AS last_run,
          ROW_NUMBER() OVER (PARTITION BY cr.assignment_id ORDER BY cr.finished_at DESC NULLS LAST) AS rn
        FROM public.check_runs cr
        WHERE cr.device_id = $1
      )
      SELECT
        a.id                      AS assignment_id,
        COALESCE(NULLIF(a.check_name,''), NULLIF(a.check_type,''), 'Check') AS check_name,
        lr.status                 AS run_status,
        lr.output                 AS run_output,
        lr.last_run               AS last_run
      FROM public.check_assignments a
      LEFT JOIN latest_run lr ON lr.assignment_id = a.id AND lr.rn = 1
      WHERE a.device_id = $1
      ORDER BY lr.last_run DESC NULLS LAST, check_name ASC
      LIMIT $2
    `;

        try {
            const { rows } = await this.pg.query<{
                assignment_id: string;
                check_name: string | null;
                run_status: string | null;
                run_output: string | null;
                last_run: Date | string | null;
            }>(sql, [deviceId, limit]);

            const items: DeviceCheckDTO[] = (rows || []).map((r) => ({
                id: r.assignment_id,
                name: r.check_name ?? 'Check',
                status: toUiStatus(r.run_status),
                lastRun: r.last_run ? new Date(r.last_run as any).toISOString() : null,
                output:
                    (r.run_output ?? '').length > 8192
                        ? (r.run_output ?? '').slice(0, 8192) + '…'
                        : r.run_output ?? '',
            }));

            return { items };
        } catch (err: any) {
            const msg = String(err?.message || '').toLowerCase();
            const code = String((err && (err.code || err?.original?.code)) || '');
            if (code === '42P01' || code === '42703' || (msg.includes('relation') && msg.includes('does not exist'))) {
                this.logger.warn('ChecksService.listByDevice: schema not ready; returning empty items.');
                return { items: [] };
            }
            this.logger.error('ChecksService.listByDevice failed', err?.stack || err);
            return { items: [] };
        }
    }

    /* ======================= Agent ingestion ====================== */

    /**
     * Ingest runs from an agent (TEXT deviceId).
     * - Upsert assignment per device using dedupeKey or (type|name) tuple
     * - Insert runs
     * Returns counts for observability.
     */
    async ingestAgentRuns(input: {
        agentId: string;
        deviceId: string; // TEXT (e.g., "win-...")
        runs: Array<{
            assignmentId?: string;
            dedupeKey?: string;
            checkType?: string;
            checkName?: string;
            status: string;
            severity?: 'WARN' | 'CRIT';
            metrics?: Record<string, any>;
            output?: string;
            startedAt?: string;
            finishedAt?: string;
        }>;
    }): Promise<{ inserted: number; assignmentsCreated: number }> {
        if (!input?.runs?.length) return { inserted: 0, assignmentsCreated: 0 };

        await this.ensureSchema();

        const MAX_OUTPUT = 64 * 1024; // 64 KiB

        // ---------- 1) Prepare src rows with a stable ordinal ----------
        const srcValues: string[] = [];
        const srcParams: any[] = [];
        let p = 1;

        for (let i = 0; i < input.runs.length; i++) {
            const r = input.runs[i];
            const dk = r.dedupeKey ?? null;
            const ct = (r.checkType || '').trim().toUpperCase() || null;
            const cn = (r.checkName || ct || 'Agent Check').trim().substring(0, 200) || 'Agent Check';

            // (ord, device_id, dedupe_key, check_type, check_name)
            srcValues.push(`($${p++}::int, $${p++}::text, $${p++}::text, $${p++}::text, $${p++}::text)`);
            srcParams.push(i + 1, input.deviceId, dk, ct, cn);
        }

        // ---------- 2) Insert missing assignments; count inserted via RETURNING ----------
        const insertSql = `
      WITH src(ord, device_id, dedupe_key, check_type, check_name) AS (
        VALUES ${srcValues.join(',')}
      )
      INSERT INTO public.check_assignments (device_id, dedupe_key, check_type, check_name)
      SELECT s.device_id, s.dedupe_key, s.check_type, s.check_name
      FROM src s
      ON CONFLICT (device_id,
        COALESCE(
          NULLIF(dedupe_key,''),
          LOWER(COALESCE(check_type,'')) || '|' || LOWER(COALESCE(check_name,''))
        ))
      DO NOTHING
      RETURNING id;
    `;
        const insertRes = await this.pg.query<{ id: string }>(insertSql, srcParams);
        const assignmentsCreated = (insertRes.rows || []).length;

        // ---------- 3) Resolve assignment ids for each src row in order ----------
        const mapSql = `
      WITH src(ord, device_id, dedupe_key, check_type, check_name) AS (
        VALUES ${srcValues.join(',')}
      )
      SELECT
        s.ord,
        ca.id::text AS assignment_id
      FROM src s
      JOIN public.check_assignments ca
        ON ca.device_id = s.device_id
       AND COALESCE(NULLIF(ca.dedupe_key,''),
            LOWER(COALESCE(ca.check_type,'')) || '|' || LOWER(COALESCE(ca.check_name,'')))
        = COALESCE(NULLIF(s.dedupe_key,''),
            LOWER(COALESCE(s.check_type,'')) || '|' || LOWER(COALESCE(s.check_name,'')))
      ORDER BY s.ord ASC;
    `;
        const mapRes = await this.pg.query<{ ord: number; assignment_id: string }>(mapSql, srcParams);
        const assignmentByOrd = new Map<number, string>();
        for (const r of mapRes.rows) assignmentByOrd.set(r.ord, r.assignment_id);

        // ---------- 4) Build runs aligned to the original order ----------
        const runValues: string[] = [];
        const runParams: any[] = [];
        p = 1;

        for (let i = 0; i < input.runs.length; i++) {
            const r = input.runs[i];
            const assignmentIdFromMap = assignmentByOrd.get(i + 1);

            const assignmentId =
                (r.assignmentId && /^[0-9a-fA-F-]{8}-[0-9a-fA-F-]{4}-[1-5][0-9a-fA-F-]{3}-[89abAB][0-9a-fA-F-]{3}-[0-9a-fA-F-]{12}$/.test(r.assignmentId))
                    ? r.assignmentId
                    : assignmentIdFromMap;

            if (!assignmentId) continue; // should not happen, but be defensive

            const status = normalizeStatus(r.status);
            const severity = r.severity === 'CRIT' ? 'CRIT' : r.severity === 'WARN' ? 'WARN' : null;
            const output = (r.output ?? '').slice(0, MAX_OUTPUT);
            const startedAt = r.startedAt ? new Date(r.startedAt) : new Date();
            const finishedAt = r.finishedAt ? new Date(r.finishedAt) : new Date();

            runValues.push(`(
        $${p++}::uuid,        -- assignment_id
        $${p++}::text,        -- device_id
        $${p++}::text,        -- status
        $${p++}::text,        -- severity
        $${p++}::jsonb,       -- metrics
        $${p++}::text,        -- output
        $${p++}::timestamptz, -- started_at
        $${p++}::timestamptz  -- finished_at
      )`);

            runParams.push(
                assignmentId,
                input.deviceId,
                status,
                severity,
                r.metrics ? JSON.stringify(r.metrics) : null,
                output,
                startedAt.toISOString(),
                finishedAt.toISOString(),
            );
        }

        let inserted = 0;
        if (runValues.length) {
            const insSql = `
        INSERT INTO public.check_runs
          (assignment_id, device_id, status, severity, metrics, output, started_at, finished_at)
        VALUES ${runValues.join(',')}
        RETURNING id;
      `;
            const ins = await this.pg.query<{ id: string }>(insSql, runParams);
            inserted = (ins.rows || []).length;
        }

        // Debounced UI broadcast per device
        if (inserted > 0) this.scheduleDeviceBroadcast(input.deviceId, inserted);

        this.logger.log(`ingested ${inserted} run(s) for device ${input.deviceId}; new assignments: ${assignmentsCreated}`);
        return { inserted, assignmentsCreated };
    }

    /** Debounce + emit device_checks_updated to subscribed UI sockets */
    private scheduleDeviceBroadcast(deviceId: string, changed: number) {
        const key = String(deviceId);
        const existing = this.deviceDebounce.get(key);
        if (existing) clearTimeout(existing as any);

        const handle = setTimeout(() => {
            try {
                const payload = {
                    t: 'device_checks_updated',
                    deviceId: key,
                    changed,
                    at: new Date().toISOString(),
                };
                const sent = this.uiSockets.broadcastToDevice(key, payload);
                this.logger.debug(`Broadcast device_checks_updated to ${sent} UI socket(s) for device ${key}`);
            } catch (e: any) {
                this.logger.warn(`Broadcast failed for device ${key}: ${e?.message ?? e}`);
            } finally {
                this.deviceDebounce.delete(key);
            }
        }, 750);

        this.deviceDebounce.set(key, handle);
    }

    /* ============== Server-driven assignments for agent (optional) ============ */

    async getAssignmentsForDevice(deviceId: string): Promise<{
        items: Array<{
            assignmentId: string;
            type: string | null;
            name: string | null;
            intervalSec: number; // static defaults for now
            timeoutSec: number;  // static defaults for now
            enabled: boolean;
            dedupeKey?: string | null;
            config?: any;
            thresholds?: any;
        }>;
    }> {
        await this.ensureSchema();

        // We don’t maintain a separate checks catalog here; return lightweight rows
        const { rows } = await this.pg.query(
            `
      SELECT
        a.id::text            AS assignment_id,
        a.check_type          AS check_type,
        a.check_name          AS check_name,
        a.dedupe_key          AS dedupe_key,
        a.created_at,
        a.updated_at
      FROM public.check_assignments a
      WHERE a.device_id = $1
      ORDER BY a.created_at DESC
      `,
            [deviceId]
        );

        return {
            items: rows.map((r: any) => ({
                assignmentId: r.assignment_id,
                type: r.check_type ?? null,
                name: r.check_name ?? null,
                // simple defaults (agents can override via config if/when you add it)
                intervalSec: 60,
                timeoutSec: 10,
                enabled: true,
                dedupeKey: r.dedupe_key,
                config: null,
                thresholds: null,
            })),
        };
    }

    /* ======================== Placeholders (unchanged) ======================== */

    async list(_params: {
        scope?: CheckScope;
        type?: CheckType;
        enabled?: boolean;
        clientId?: string;
        siteId?: string;
        deviceId?: string;
        limit?: number;
        cursor?: string;
    }): Promise<{ items: any[]; nextCursor?: string | null }> {
        throw new NotImplementedException('ChecksService.list not implemented yet');
    }

    async create(_payload: any): Promise<any> {
        throw new NotImplementedException('ChecksService.create not implemented yet');
    }

    async update(_id: string, _payload: any): Promise<any> {
        throw new NotImplementedException('ChecksService.update not implemented yet');
    }

    async remove(_id: string): Promise<{ id: string; deleted: boolean }> {
        throw new NotImplementedException('ChecksService.remove not implemented yet');
    }

    async rebuildAssignments(_id: string): Promise<{ checkId: string; assignmentsRebuilt: number }> {
        throw new NotImplementedException('ChecksService.rebuildAssignments not implemented yet');
    }

    async runOnDemand(_id: string, _params?: { deviceIds?: string[] | null }): Promise<{ enqueued: number }> {
        throw new NotImplementedException('ChecksService.runOnDemand not implemented yet');
    }
}

===== END FILE remoteiq-minimal-e2e\backend\src\checks\checks.service.ts =====

===== FILE: remoteiq-minimal-e2e\backend\src\devices\devices.service.ts (276 lines) =====
// backend/src/devices/devices.service.ts
import { Injectable, NotFoundException } from "@nestjs/common";
import { PgPoolService } from "../storage/pg-pool.service";

export type Device = {
  id: string;
  hostname: string;
  os: string;
  arch?: string | null;
  lastSeen: string | null;
  status: "online" | "offline";
  client?: string | null;
  site?: string | null;
  user?: string | null;
  version?: string | null;
  primaryIp?: string | null;
  agentUuid?: string | null; // <-- NEW
};

function decodeCursor(cur?: string | null) {
  if (!cur) return 0;
  try {
    const n = parseInt(Buffer.from(cur, "base64url").toString("utf8"), 10);
    return Number.isFinite(n) && n >= 0 ? n : 0;
  } catch {
    return 0;
  }
}
function encodeCursor(n: number) {
  return Buffer.from(String(n), "utf8").toString("base64url");
}

@Injectable()
export class DevicesService {
  constructor(private readonly pg: PgPoolService) { }

  async list(opts: {
    pageSize: number;
    cursor?: string | null;
    q?: string;
    status?: "online" | "offline";
    os?: string[];
  }): Promise<{ items: Device[]; nextCursor: string | null }> {
    const { pageSize, cursor, q, status, os } = opts;
    const offset = decodeCursor(cursor);

    const where: string[] = [];
    const params: any[] = [];
    let p = 1;

    if (q && q.trim()) {
      where.push(`hostname ILIKE $${p++}`);
      params.push(`%${q.trim()}%`);
    }
    if (status) {
      where.push(`status = $${p++}`);
      params.push(status);
    }
    if (os && os.length) {
      where.push(`lower(os) = ANY($${p++})`);
      params.push(os.map((o) => String(o).toLowerCase()));
    }

    const limit = pageSize + 1;
    const whereSql = where.length ? `WHERE ${where.join(" AND ")}` : "";

    const sql = `
      WITH agent_rows AS (
        SELECT
          a.id::text                                   AS id,
          COALESCE(a.hostname, a.device_id, 'unknown') AS hostname,
          COALESCE(NULLIF(a.os, ''), 'unknown')        AS os,
          a.arch                                       AS arch,
          a.last_seen_at                               AS last_seen,
          CASE
            WHEN a.last_seen_at IS NOT NULL
             AND a.last_seen_at > NOW() - INTERVAL '5 minutes'
            THEN 'online' ELSE 'offline'
          END                                          AS status,
          a.client                                     AS client,
          a.site                                       AS site,
          NULLIF(a.logged_in_user, '')                 AS "user",
          NULLIF(a.version, '')                        AS version,
          NULLIF(a.primary_ip, '')                     AS primary_ip,
          a.agent_uuid::text                           AS agent_uuid   -- <-- NEW
        FROM public.agents a
      ),
      device_rows AS (
        SELECT
          d.id::text            AS id,
          d.hostname            AS hostname,
          d.os                  AS os,
          d.arch                AS arch,
          d.last_seen           AS last_seen,
          d.status              AS status,
          d.client              AS client,
          d.site                AS site,
          NULLIF(d."user", '')  AS "user",
          NULL::text            AS version,
          NULL::text            AS primary_ip,
          NULL::text            AS agent_uuid                          -- <-- NEW
        FROM devices d
        WHERE NOT EXISTS (
          SELECT 1 FROM public.agents a
          WHERE COALESCE(a.hostname, a.device_id, 'unknown') = d.hostname
        )
      ),
      all_devs AS (
        SELECT * FROM agent_rows
        UNION ALL
        SELECT * FROM device_rows
      )
      SELECT id, hostname, os, arch, last_seen, status, client, site, "user", version, primary_ip, agent_uuid
      FROM all_devs
      ${whereSql}
      ORDER BY hostname ASC
      LIMIT ${limit} OFFSET ${offset};
    `;

    const { rows } = await this.pg.query(sql, params);
    const hasNext = rows.length > pageSize;

    const items = rows.slice(0, pageSize).map((r: any) => ({
      id: r.id,
      hostname: r.hostname,
      os: r.os,
      arch: r.arch ?? null,
      lastSeen: r.last_seen ? new Date(r.last_seen).toISOString() : null,
      status: r.status as "online" | "offline",
      client: r.client ?? null,
      site: r.site ?? null,
      user: r.user ?? null,
      version: r.version ?? null,
      primaryIp: r.primary_ip ?? null,
      agentUuid: r.agent_uuid ?? null, // <-- NEW
    })) as Device[];

    return { items, nextCursor: hasNext ? encodeCursor(offset + pageSize) : null };
  }

  async getOne(id: string): Promise<Device | null> {
    const sql = `
      WITH rows AS (
        SELECT
          0                                                AS pref,
          a.id::text                                      AS id,
          COALESCE(a.hostname, a.device_id, 'unknown')    AS hostname,
          COALESCE(NULLIF(a.os, ''), 'unknown')           AS os,
          a.arch                                          AS arch,
          a.last_seen_at                                  AS last_seen,
          CASE
            WHEN a.last_seen_at IS NOT NULL
             AND a.last_seen_at > NOW() - INTERVAL '5 minutes'
            THEN 'online' ELSE 'offline'
          END                                             AS status,
          a.client                                        AS client,
          a.site                                          AS site,
          NULLIF(a.logged_in_user, '')                    AS "user",
          NULLIF(a.version, '')                           AS version,
          NULLIF(a.primary_ip, '')                        AS primary_ip,
          a.agent_uuid::text                              AS agent_uuid  -- <-- NEW
        FROM public.agents a
        WHERE a.id::text = $1

        UNION ALL

        SELECT
          1                        AS pref,
          d.id::text               AS id,
          d.hostname               AS hostname,
          d.os                     AS os,
          d.arch                   AS arch,
          d.last_seen              AS last_seen,
          d.status                 AS status,
          d.client                 AS client,
          d.site                   AS site,
          NULLIF(d."user", '')     AS "user",
          NULL::text               AS version,
          NULL::text               AS primary_ip,
          NULL::text               AS agent_uuid                         -- <-- NEW
        FROM devices d
        WHERE d.id::text = $1
      )
      SELECT id, hostname, os, arch, last_seen, status, client, site, "user", version, primary_ip, agent_uuid
      FROM rows
      ORDER BY pref ASC
      LIMIT 1;
    `;
    const { rows } = await this.pg.query(sql, [id]);
    const r = rows[0];
    if (!r) return null;

    return {
      id: r.id,
      hostname: r.hostname,
      os: r.os,
      arch: r.arch ?? null,
      lastSeen: r.last_seen ? new Date(r.last_seen).toISOString() : null,
      status: r.status as "online" | "offline",
      client: r.client ?? null,
      site: r.site ?? null,
      user: r.user ?? null,
      version: r.version ?? null,
      primaryIp: r.primary_ip ?? null,
      agentUuid: r.agent_uuid ?? null, // <-- NEW
    };
  }

  async listSoftware(
    id: string
  ): Promise<
    Array<{
      id: string;
      name: string;
      version: string;
      publisher?: string | null;
      installDate?: string | null;
    }>
  > {
    const { rows } = await this.pg.query(
      `
      SELECT
        s.id::text            AS id,
        s.name,
        s.version,
        s.publisher,
        s.install_date        AS install_date
      FROM public.agent_software s
      JOIN public.agents a ON a.id = s.agent_id
      WHERE a.id::text = $1
      ORDER BY lower(s.name) ASC, COALESCE(s.version,'') ASC
      `,
      [id]
    );

    return rows.map((r: any) => ({
      id: r.id,
      name: r.name,
      version: r.version ?? "",
      publisher: r.publisher ?? null,
      installDate: r.install_date ?? null,
    }));
  }

  // NEW: create uninstall job in a simple job queue
  async requestUninstall(
    id: string,
    body: { name: string; version?: string | null }
  ): Promise<string> {
    // ensure agent exists
    const { rows: arows } = await this.pg.query(
      `SELECT id FROM public.agents WHERE id::text = $1`,
      [id]
    );
    const agentId: number | undefined = arows[0]?.id;
    if (!agentId) throw new NotFoundException("Agent not found");

    const payload = {
      action: "uninstall_software",
      name: body.name,
      version: body.version ?? null,
    };

    const { rows } = await this.pg.query(
      `
      INSERT INTO public.agent_jobs (agent_id, kind, payload)
      VALUES ($1, $2, $3::jsonb)
      RETURNING id::text AS id
      `,
      [agentId, "uninstall_software", JSON.stringify(payload)]
    );

    return rows[0].id as string;
  }
}

===== END FILE remoteiq-minimal-e2e\backend\src\devices\devices.service.ts =====

===== FILE: remoteiq-minimal-e2e\backend\src\agents\agents.module.ts (17 lines) =====
// remoteiq-minimal-e2e\backend\src\agents\agents.module.ts
import { Module } from '@nestjs/common';
import { AgentsController } from './agents.controller';
import { AgentsService } from './agents.service';
import { AuthModule } from '../auth/auth.module';
import { StorageModule } from '../storage/storage.module'; // provides PgPoolService
import { CommonModule } from '../common/common.module';    // provides AgentTokenGuard utilities
import { ChecksModule } from '../checks/checks.module';    // <-- provides ChecksService to controller

@Module({
  imports: [AuthModule, StorageModule, CommonModule, ChecksModule],
  controllers: [AgentsController],
  providers: [AgentsService],
  exports: [AgentsService],
})
export class AgentsModule { }

===== END FILE remoteiq-minimal-e2e\backend\src\agents\agents.module.ts =====

===== FILE: remoteiq-minimal-e2e\backend\src\agents\agents.controller.ts (223 lines) =====
// src/agents/agents.controller.ts
import {
  Body, Controller, Get, Post, Query, Req,
  UseGuards, UsePipes, ValidationPipe, BadRequestException, ForbiddenException,
} from '@nestjs/common';
import { AuthService } from '../auth/auth.service';
import { EnrollAgentDto } from './dto/enroll-agent.dto';
import { AgentsService } from './agents.service';
import { AgentTokenGuard, getAgentFromRequest } from '../common/agent-token.util';
import { UpdateAgentFactsDto } from './dto/update-agent-facts.dto';
import { SubmitSoftwareDto } from './dto/submit-software.dto';
import { ChecksService } from '../checks/checks.service';
import {
  IsArray, IsDateString, IsObject, IsOptional, IsString,
  MaxLength, ValidateNested, ArrayMinSize,
} from 'class-validator';
import { Type } from 'class-transformer';

/* ----------------------------- DTOs for runs ----------------------------- */

export enum AgentRunStatus {
  OK = 'OK',
  PASS = 'PASS',
  PASSING = 'PASSING',
  WARN = 'WARN',
  WARNING = 'WARNING',
  CRIT = 'CRIT',
  ERROR = 'ERROR',
  FAIL = 'FAIL',
  FAILING = 'FAILING',
  TIMEOUT = 'TIMEOUT',
  UNKNOWN = 'UNKNOWN',
}

export class SubmitCheckRunItemDto {
  @IsOptional()
  @IsString()
  @MaxLength(36)
  assignmentId?: string; // uuid string (not strictly validated to allow empty envs)

  @IsOptional()
  @IsString()
  @MaxLength(256)
  dedupeKey?: string;

  @IsOptional()
  @IsString()
  @MaxLength(64)
  checkType?: string;

  @IsOptional()
  @IsString()
  @MaxLength(200)
  checkName?: string;

  @IsString()
  status!: string;

  @IsOptional()
  @IsString()
  @MaxLength(8)
  severity?: 'WARN' | 'CRIT';

  @IsOptional()
  @IsObject()
  metrics?: Record<string, any>;

  @IsOptional()
  @IsString()
  @MaxLength(200000)
  output?: string;

  @IsOptional()
  @IsDateString()
  startedAt?: string;

  @IsOptional()
  @IsDateString()
  finishedAt?: string;
}

export class SubmitCheckRunsDto {
  @IsOptional()
  @IsString() // <— accepts "win-..." style ids
  deviceId?: string;

  @IsArray()
  @ArrayMinSize(1)
  @ValidateNested({ each: true })
  @Type(() => SubmitCheckRunItemDto)
  runs!: SubmitCheckRunItemDto[];
}

/* ----------------------------- Rate limiter ------------------------------ */
const rlWindowMs = 10_000; // 10s
const rlMaxRequests = 20;  // 20 per window
const rlState = new Map<string, number[]>();

function checkRate(agentIdStr: string) {
  const now = Date.now();
  const arr = rlState.get(agentIdStr) ?? [];
  const fresh = arr.filter(ts => now - ts < rlWindowMs);
  fresh.push(now);
  rlState.set(agentIdStr, fresh);
  if (fresh.length > rlMaxRequests) {
    throw new ForbiddenException('Agent is sending check data too fast; back off and retry later.');
  }
}

@Controller('/api/agent')
@UsePipes(new ValidationPipe({ whitelist: true, transform: true, forbidNonWhitelisted: true }))
export class AgentsController {
  constructor(
    private readonly auth: AuthService,
    private readonly agents: AgentsService,
    private readonly checks: ChecksService,
  ) { }

  @Post('/enroll')
  async enroll(
    @Body() body: EnrollAgentDto
  ): Promise<{ agentId: string; agentUuid: string | null; deviceId: string; agentToken: string }> {
    const res: any = await this.auth.enrollAgent(body);

    const agentId = String(res?.agentId ?? res?.agent?.id ?? '');
    const deviceId = String(res?.deviceId ?? res?.device?.id ?? body?.deviceId ?? '');
    const agentToken = String(res?.agentToken ?? res?.token ?? res?.accessToken ?? '');

    if (!agentToken || !agentId) {
      throw new Error('Enrollment succeeded but missing token or agentId in response.');
    }

    let agentUuid: string | null = null;
    try {
      agentUuid = await this.agents.getAgentUuidById(Number(agentId));
    } catch {
      agentUuid = null;
    }

    return { agentId, agentUuid, deviceId, agentToken };
  }

  @Post('/ping')
  @UseGuards(AgentTokenGuard)
  async ping(@Req() req: any, @Body() body: UpdateAgentFactsDto) {
    const agent = getAgentFromRequest(req);
    await this.agents.updateFacts(Number((agent as any).id), body ?? {});
    return { ok: true };
  }

  @Post('/software')
  @UseGuards(AgentTokenGuard)
  async submitSoftware(@Req() req: any, @Body() body: SubmitSoftwareDto) {
    const agent = getAgentFromRequest(req);
    await this.agents.upsertSoftware(Number((agent as any).id), body?.items ?? []);
    return { ok: true, count: body?.items?.length ?? 0 };
  }

  // ===================== Check runs ingestion ======================
  @Post('/check-runs')
  @UseGuards(AgentTokenGuard)
  async submitCheckRuns(@Req() req: any, @Body() body: SubmitCheckRunsDto) {
    const agent = getAgentFromRequest(req);

    checkRate(String((agent as any).id));

    const tokenDeviceRaw = (agent as any)?.deviceId ?? (agent as any)?.device_id;
    const deviceIdFromToken: string | undefined =
      tokenDeviceRaw != null ? String(tokenDeviceRaw) : undefined;

    const deviceIdFromBody: string | undefined =
      body?.deviceId ? String(body.deviceId) : undefined;

    const deviceId = deviceIdFromBody ?? deviceIdFromToken;

    if (!deviceId) {
      throw new BadRequestException('deviceId is required (bind agent to device first, or include in body).');
    }
    if (deviceIdFromBody && deviceIdFromToken && deviceIdFromBody !== deviceIdFromToken) {
      throw new ForbiddenException('deviceId in body does not match the agent binding.');
    }
    if (!Array.isArray(body?.runs) || body.runs.length === 0) {
      throw new BadRequestException('runs is required and must be a non-empty array');
    }

    const result = await this.checks.ingestAgentRuns({
      agentId: String((agent as any).id),
      deviceId, // TEXT id
      runs: body.runs.map(r => ({
        assignmentId: r.assignmentId,
        dedupeKey: r.dedupeKey,
        checkType: r.checkType,
        checkName: r.checkName,
        status: r.status,
        severity: r.severity,
        metrics: r.metrics,
        output: r.output,
        startedAt: r.startedAt,
        finishedAt: r.finishedAt,
      })),
    });

    return { ok: true, inserted: result.inserted, assignmentsCreated: result.assignmentsCreated };
  }

  @Get('/assignments')
  @UseGuards(AgentTokenGuard)
  async getAssignments(@Req() req: any, @Query('deviceId') deviceId?: string) {
    const agent = getAgentFromRequest(req);
    const tokenDeviceRaw = (agent as any)?.deviceId ?? (agent as any)?.device_id;
    const boundDevice: string | undefined =
      tokenDeviceRaw != null ? String(tokenDeviceRaw) : undefined;

    const effective = deviceId ?? boundDevice;
    if (!effective) {
      throw new BadRequestException('deviceId is required (either query param or bound to agent).');
    }

    const { items } = await this.checks.getAssignmentsForDevice(effective);
    return { items };
  }
}

===== END FILE remoteiq-minimal-e2e\backend\src\agents\agents.controller.ts =====

===== FILE: remoteiq-minimal-e2e\backend\src\agents\agents.service.ts (142 lines) =====
// backend/src/agents/agents.service.ts
import { Injectable } from "@nestjs/common";
import { PgPoolService } from "../storage/pg-pool.service";

// DTOs are validated in controllers; here we accept partials safely.
type UpdateAgentFacts = Partial<{
    hostname: string;
    os: string;
    arch: string | null;         // NOT NULL in DB → we will ignore null updates
    version: string | null;      // nullable
    primaryIp: string | null;    // nullable
    client: string | null;       // nullable
    site: string | null;         // nullable
    user: string | null;         // alias accepted from agent payloads
    loggedInUser: string | null; // alias (both map to logged_in_user)
}>;

type SoftwareItem = {
    name: string;
    version?: string | null;
    publisher?: string | null;
    installDate?: string | null;
};

@Injectable()
export class AgentsService {
    constructor(private readonly pg: PgPoolService) { }

    /** Return the stable UUID mirror for a numeric agent id (or null if absent). */
    async getAgentUuidById(agentId: number): Promise<string | null> {
        try {
            const { rows } = await this.pg.query<{ agent_uuid: string | null }>(
                `SELECT agent_uuid FROM public.agents WHERE id = $1 LIMIT 1`,
                [agentId]
            );
            return rows[0]?.agent_uuid ?? null;
        } catch {
            return null;
        }
    }

    /**
     * Update agent facts and bump last_seen_at.
     * - Only updates provided fields.
     * - Never sets NOT NULL columns to NULL.
     */
    async updateFacts(agentId: number, facts: UpdateAgentFacts): Promise<void> {
        const sets: string[] = [`last_seen_at = NOW()`];
        const params: any[] = [];
        let p = 1;

        // For columns that are NOT NULL in your schema, do not accept null writes.
        const setIfDefined = (col: string, val: any) => {
            if (val !== undefined) {
                sets.push(`${col} = $${p++}`);
                params.push(val);
            }
        };
        const setIfNullable = (col: string, val: any) => {
            if (val !== undefined) {
                sets.push(`${col} = $${p++}`);
                params.push(val); // can be null; that’s fine for nullable cols
            }
        };
        const setIfNotNull = (col: string, val: any) => {
            if (val !== undefined && val !== null) {
                sets.push(`${col} = $${p++}`);
                params.push(val);
            }
        };

        // Likely NOT NULL in table
        setIfDefined("hostname", facts.hostname);
        setIfDefined("os", facts.os);
        setIfNotNull("arch", facts.arch); // skip if null/undefined

        // Nullable fields
        setIfNullable("version", facts.version ?? undefined);
        setIfNullable("primary_ip", facts.primaryIp ?? undefined);
        setIfNullable("client", facts.client ?? undefined);
        setIfNullable("site", facts.site ?? undefined);

        // Accept both 'user' and 'loggedInUser' from payloads → store in logged_in_user
        const loginUser = facts.user ?? facts.loggedInUser;
        setIfNullable("logged_in_user", loginUser ?? undefined);

        const sql = `
      UPDATE public.agents
      SET ${sets.join(", ")}
      WHERE id = $${p}
    `;
        params.push(agentId);

        await this.pg.query(sql, params);
    }

    /** Upsert full software inventory for an agent. */
    async upsertSoftware(agentId: number, items: SoftwareItem[]): Promise<void> {
        if (!Array.isArray(items) || items.length === 0) return;

        const valuesSql: string[] = [];
        const params: any[] = [];
        let p = 1;

        for (const it of items) {
            const name = (it.name || "").trim();
            if (!name) continue;

            valuesSql.push(`(
        $${p++}::integer,
        $${p++}::text,
        $${p++}::text,
        $${p++}::text,
        $${p++}::timestamptz
      )`);

            params.push(
                agentId,
                name,
                it.version ?? null,
                it.publisher ?? null,
                it.installDate ? new Date(it.installDate) : null
            );
        }

        if (valuesSql.length === 0) return;

        // Requires a matching unique index/constraint in DB:
        // CREATE UNIQUE INDEX IF NOT EXISTS agent_software_uk ON public.agent_software (agent_id, lower(name), COALESCE(version,''));
        const sql = `
      INSERT INTO public.agent_software (agent_id, name, version, publisher, install_date)
      VALUES ${valuesSql.join(",")}
      ON CONFLICT (agent_id, lower(name), COALESCE(version,'')) DO UPDATE
      SET
        publisher = EXCLUDED.publisher,
        install_date = EXCLUDED.install_date
    `;
        await this.pg.query(sql, params);
    }
}


===== END FILE remoteiq-minimal-e2e\backend\src\agents\agents.service.ts =====

===== FILE: remoteiq-minimal-e2e\backend\src\agents\dto\enroll-agent.dto.ts (23 lines) =====
// src/agents/dto/enroll-agent.dto.ts
import { IsIn, IsString, IsNotEmpty, MaxLength } from 'class-validator';

export class EnrollAgentDto {
    @IsString() @IsNotEmpty() @MaxLength(200)
    enrollmentSecret!: string;

    @IsString() @IsNotEmpty() @MaxLength(200)
    deviceId!: string;

    @IsString() @IsNotEmpty() @MaxLength(200)
    hostname!: string;

    @IsIn(['windows', 'linux', 'macos'])
    os!: 'windows' | 'linux' | 'macos';

    @IsIn(['x64', 'arm64', 'x86'])
    arch!: 'x64' | 'arm64' | 'x86';

    @IsString() @IsNotEmpty() @MaxLength(50)
    version!: string;
}

===== END FILE remoteiq-minimal-e2e\backend\src\agents\dto\enroll-agent.dto.ts =====

===== FILE: remoteiq-minimal-e2e\backend\src\agents\dto\submit-software.dto.ts (31 lines) =====
import { Type } from 'class-transformer';
import { IsArray, IsOptional, IsString, Length, Matches, ValidateNested } from 'class-validator';

export class SubmitSoftwareItemDto {
    @IsString()
    @Length(1, 256)
    name!: string;

    @IsOptional()
    @IsString()
    @Length(1, 128)
    version?: string;

    @IsOptional()
    @IsString()
    @Length(1, 256)
    publisher?: string;

    // YYYY-MM-DD
    @IsOptional()
    @Matches(/^\d{4}-\d{2}-\d{2}$/, { message: 'installDate must be YYYY-MM-DD' })
    installDate?: string;
}

export class SubmitSoftwareDto {
    @IsArray()
    @ValidateNested({ each: true })
    @Type(() => SubmitSoftwareItemDto)
    items!: SubmitSoftwareItemDto[];
}

===== END FILE remoteiq-minimal-e2e\backend\src\agents\dto\submit-software.dto.ts =====

===== FILE: remoteiq-minimal-e2e\backend\src\agents\dto\update-agent-facts.dto.ts (35 lines) =====
// backend/src/agents/dto/update-agent-facts.dto.ts
import { IsIn, IsOptional, IsString, MaxLength } from 'class-validator';

export class UpdateAgentFactsDto {
    @IsOptional()
    @IsIn(['windows', 'linux', 'macos'])
    os?: 'windows' | 'linux' | 'macos';

    @IsOptional()
    @IsIn(['x64', 'arm64', 'x86'])
    arch?: 'x64' | 'arm64' | 'x86';

    @IsOptional()
    @IsString()
    @MaxLength(50)
    version?: string;

    @IsOptional()
    @IsString()
    @MaxLength(100)
    primaryIp?: string;

    // agent sends this today
    @IsOptional()
    @IsString()
    @MaxLength(200)
    user?: string;

    // optional alias: some agents might send this name
    @IsOptional()
    @IsString()
    @MaxLength(200)
    loggedInUser?: string;
}

===== END FILE remoteiq-minimal-e2e\backend\src\agents\dto\update-agent-facts.dto.ts =====

===== FILE: remoteiq-minimal-e2e\backend\src\common\common.module.ts (14 lines) =====
// backend/src/common/common.module.ts
import { Module } from '@nestjs/common';
import { SocketRegistry } from './socket-registry.service';
import { UiSocketRegistry } from './ui-socket-registry.service';
import { AgentTokenGuard } from './agent-token.util';
import { StorageModule } from '../storage/storage.module';

@Module({
    imports: [StorageModule],
    providers: [SocketRegistry, UiSocketRegistry, AgentTokenGuard],
    exports: [SocketRegistry, UiSocketRegistry, AgentTokenGuard],
})
export class CommonModule { }

===== END FILE remoteiq-minimal-e2e\backend\src\common\common.module.ts =====

===== FILE: remoteiq-minimal-e2e\backend\src\common\socket-registry.service.ts (61 lines) =====
//remoteiq-minimal-e2e\backend\src\common\socket-registry.service.ts

import { Injectable } from "@nestjs/common";
import type { WebSocket } from "ws";

export type AgentSocket = WebSocket & {
    agentId?: string;
    deviceId?: string;
};

@Injectable()
export class SocketRegistry {
    private socketsByAgent = new Map<string, AgentSocket>();
    private socketsByDevice = new Map<string, AgentSocket>();

    // --- Primary API ---
    getByAgent(agentId: string): AgentSocket | undefined {
        return this.socketsByAgent.get(agentId);
    }

    getByDevice(deviceId: string): AgentSocket | undefined {
        return this.socketsByDevice.get(deviceId);
    }

    set(agentId: string | undefined, deviceId: string | undefined, socket: AgentSocket) {
        if (agentId) {
            this.socketsByAgent.set(agentId, socket);
            socket.agentId = agentId;
        }
        if (deviceId) {
            this.socketsByDevice.set(deviceId, socket);
            socket.deviceId = deviceId;
        }
    }

    deleteByAgent(agentId: string) {
        const sock = this.socketsByAgent.get(agentId);
        if (sock?.deviceId) this.socketsByDevice.delete(sock.deviceId);
        this.socketsByAgent.delete(agentId);
    }

    deleteByDevice(deviceId: string) {
        const sock = this.socketsByDevice.get(deviceId);
        if (sock?.agentId) this.socketsByAgent.delete(sock.agentId);
        this.socketsByDevice.delete(deviceId);
    }

    // --- Back-compat aliases (so older callers like dispatcher.service can keep using .get) ---
    /** Alias for getByAgent */
    get(agentId: string): AgentSocket | undefined {
        return this.getByAgent(agentId);
    }
    /** Aliases in case other code uses these names */
    setByAgent(agentId: string, socket: AgentSocket) {
        this.set(agentId, /*deviceId*/ undefined, socket);
    }
    setByDevice(deviceId: string, socket: AgentSocket) {
        this.set(/*agentId*/ undefined, deviceId, socket);
    }
}

===== END FILE remoteiq-minimal-e2e\backend\src\common\socket-registry.service.ts =====

===== FILE: remoteiq-minimal-e2e\backend\src\common\ui-socket-registry.service.ts (200 lines) =====
// backend/src/common/ui-socket-registry.service.ts
import { Injectable, Logger } from "@nestjs/common";
import type { WebSocket } from "ws";

/**
 * UI (dashboard) socket with metadata.
 * - userId: authenticated user identifier (string)
 * - subscriptions: deviceIds this socket has subscribed to
 */
export type UiSocket = WebSocket & {
    userId?: string;
    subscriptions?: Set<string>;
};

function isOpen(ws: WebSocket): boolean {
    // 'OPEN' is a numeric const on ws WebSocket instances
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    return (ws as any).readyState === (ws as any).OPEN;
}

/**
 * Registry for **dashboard/user** WebSocket connections and their subscriptions.
 * Isolation from the Agent socket registry keeps privileges and broadcasting clean.
 *
 * Notes:
 * - In-memory only (per-process). For multi-node deployments, back this with Redis or a message bus.
 * - Broadcast methods return the number of sockets that were attempted (best-effort).
 */
@Injectable()
export class UiSocketRegistry {
    private readonly log = new Logger("UiSocketRegistry");

    /** All sockets for a given user */
    private socketsByUser = new Map<string, Set<UiSocket>>();

    /** Subscribers for a given deviceId */
    private socketsByDevice = new Map<string, Set<UiSocket>>();

    /** Track every active socket for cleanup/metrics */
    private allSockets = new Set<UiSocket>();

    /* ---------------------------- Socket lifecycle ---------------------------- */

    /** Register a new UI socket for a specific user (auth already verified). */
    add(userId: string, socket: UiSocket): void {
        socket.userId = String(userId);
        socket.subscriptions = socket.subscriptions ?? new Set<string>();

        // Per-user index
        if (!this.socketsByUser.has(userId)) this.socketsByUser.set(userId, new Set());
        this.socketsByUser.get(userId)!.add(socket);

        // Global index
        this.allSockets.add(socket);
    }

    /** Remove a UI socket from all indexes (called on close/error). */
    remove(socket: UiSocket): void {
        // Unsubscribe from all device topics first
        if (socket.subscriptions && socket.subscriptions.size) {
            for (const deviceId of socket.subscriptions) {
                this.unsubscribe(socket, deviceId);
            }
            socket.subscriptions.clear();
        }

        // Detach from per-user map
        const uid = socket.userId;
        if (uid && this.socketsByUser.has(uid)) {
            const set = this.socketsByUser.get(uid)!;
            set.delete(socket);
            if (set.size === 0) this.socketsByUser.delete(uid);
        }

        // Global index
        this.allSockets.delete(socket);
    }

    /** Remove all sockets for a given user (e.g., on logout/revoke). */
    removeAllForUser(userId: string): number {
        const set = this.socketsByUser.get(userId);
        if (!set || !set.size) return 0;
        let n = 0;
        for (const s of Array.from(set)) {
            try {
                // Close with policy code; UI can auto-reconnect if appropriate
                // eslint-disable-next-line @typescript-eslint/no-explicit-any
                (s as any).close?.(4401, "User sessions revoked");
            } catch {
                /* ignore */
            }
            this.remove(s);
            n++;
        }
        return n;
    }

    /* ----------------------------- Subscriptions ------------------------------ */

    /** Subscribe a socket to a device topic (idempotent). */
    subscribe(socket: UiSocket, deviceId: string): void {
        const id = String(deviceId);
        socket.subscriptions = socket.subscriptions ?? new Set<string>();
        if (socket.subscriptions.has(id)) return;

        socket.subscriptions.add(id);

        if (!this.socketsByDevice.has(id)) this.socketsByDevice.set(id, new Set());
        this.socketsByDevice.get(id)!.add(socket);
    }

    /** Unsubscribe a socket from a device topic (no-op if not subscribed). */
    unsubscribe(socket: UiSocket, deviceId: string): void {
        const id = String(deviceId);
        if (socket.subscriptions && socket.subscriptions.has(id)) {
            socket.subscriptions.delete(id);
        }
        const set = this.socketsByDevice.get(id);
        if (set) {
            set.delete(socket);
            if (set.size === 0) this.socketsByDevice.delete(id);
        }
    }

    /** Unsubscribe a socket from all topics. */
    unsubscribeAll(socket: UiSocket): void {
        if (!socket.subscriptions) return;
        for (const id of Array.from(socket.subscriptions)) {
            this.unsubscribe(socket, id);
        }
    }

    /* -------------------------------- Broadcasts ------------------------------ */

    /** Broadcast to all UI sockets (rare; prefer topic broadcasts). */
    broadcastAll(payload: unknown): number {
        const msg = JSON.stringify(payload);
        let sent = 0;
        for (const s of this.allSockets) {
            if (!isOpen(s)) continue;
            try {
                s.send(msg);
                sent++;
            } catch {
                /* ignore per-socket send errors */
            }
        }
        return sent;
    }

    /** Broadcast to all sockets subscribed to a specific deviceId. */
    broadcastToDevice(deviceId: string, payload: unknown): number {
        const set = this.socketsByDevice.get(String(deviceId));
        if (!set || set.size === 0) return 0;
        const msg = JSON.stringify(payload);
        let sent = 0;
        for (const s of set) {
            if (!isOpen(s)) continue;
            try {
                s.send(msg);
                sent++;
            } catch {
                /* ignore per-socket send errors */
            }
        }
        return sent;
    }

    /** Broadcast to all sockets for a given userId (e.g., personal notices). */
    broadcastToUser(userId: string, payload: unknown): number {
        const set = this.socketsByUser.get(String(userId));
        if (!set || set.size === 0) return 0;
        const msg = JSON.stringify(payload);
        let sent = 0;
        for (const s of set) {
            if (!isOpen(s)) continue;
            try {
                s.send(msg);
                sent++;
            } catch {
                /* ignore per-socket send errors */
            }
        }
        return sent;
    }

    /* --------------------------------- Metrics -------------------------------- */

    countAll(): number {
        return this.allSockets.size;
    }
    countUsers(): number {
        return this.socketsByUser.size;
    }
    countDeviceSubscribers(deviceId: string): number {
        const set = this.socketsByDevice.get(String(deviceId));
        return set ? set.size : 0;
    }
}

===== END FILE remoteiq-minimal-e2e\backend\src\common\ui-socket-registry.service.ts =====

===== FILE: remoteiq-minimal-e2e\backend\src\common\agent-token.util.ts (98 lines) =====
// remoteiq-minimal-e2e/backend/src/common/agent-token.util.ts
import { Injectable, CanActivate, ExecutionContext, UnauthorizedException } from '@nestjs/common';
import type { Request } from 'express';
import crypto from 'node:crypto';
import jwt from 'jsonwebtoken';
import { PgPoolService } from '../storage/pg-pool.service';

/** ───────────────────────────
 *  Crypto helpers
 *  ─────────────────────────── */
const algo = 'sha256';

export function hashToken(token: string): string {
  return crypto.createHash(algo).update(token, 'utf8').digest('hex');
}

export function newOpaqueToken(): string {
  return crypto.randomBytes(24).toString('base64url');
}

export function signAgentJwt(agentId: string): string {
  const secret = process.env.JWT_SECRET || 'dev';
  return jwt.sign({ sub: agentId, typ: 'agent' }, secret, { algorithm: 'HS256' });
}

export function verifyAgentJwt(token: string): string | null {
  try {
    const secret = process.env.JWT_SECRET || 'dev';
    const payload = jwt.verify(token, secret) as any;
    return payload?.sub as string;
  } catch {
    return null;
  }
}

/** ───────────────────────────
 *  Request augmentation helper
 *  ─────────────────────────── */
export type AgentAuthContext = {
  id: number;
  token?: string;
};

export function getAgentFromRequest(req: any): AgentAuthContext {
  return (req as any).agent as AgentAuthContext;
}

/** ───────────────────────────
 *  DB row shape(s)
 *  ─────────────────────────── */
type AgentRow = {
  id: number;
  token_hash: string | null;
};

/** ───────────────────────────
 *  Bearer token guard for agents
 *  ─────────────────────────── */
@Injectable()
export class AgentTokenGuard implements CanActivate {
  constructor(private readonly db: PgPoolService) { }

  async canActivate(context: ExecutionContext): Promise<boolean> {
    const req = context.switchToHttp().getRequest<Request>();

    const authHeader = req.headers['authorization'];
    if (!authHeader || Array.isArray(authHeader)) {
      throw new UnauthorizedException('Missing Authorization header');
    }

    const match = /^Bearer\s+(.+)$/.exec(authHeader);
    if (!match) {
      throw new UnauthorizedException('Invalid Authorization header format');
    }

    const token = match[1];
    const tokenHash = hashToken(token);

    // Use the typed query helper (no private pool access)
    const { rows } = await this.db.query<AgentRow>(
      `SELECT id, token_hash
         FROM public.agents
        WHERE token_hash = $1
        LIMIT 1`,
      [tokenHash],
    );

    if (rows.length === 0) {
      throw new UnauthorizedException('Invalid or unknown agent token');
    }

    // Stash minimal agent context on the request
    (req as any).agent = { id: rows[0].id, token } as AgentAuthContext;

    return true;
  }
}

===== END FILE remoteiq-minimal-e2e\backend\src\common\agent-token.util.ts =====

===== FILE: remoteiq-minimal-e2e\backend\src\ws\ws.module.ts (29 lines) =====
// backend/src/ws/ws.module.ts
import { Module, forwardRef } from "@nestjs/common";
import { JwtModule } from "@nestjs/jwt";

import { AgentGateway } from "./agent.gateway";
import { DashboardGateway } from "./dashboard.gateway";

import { JobsModule } from "../jobs/jobs.module";
import { CommonModule } from "../common/common.module";
import { StorageModule } from "../storage/storage.module";

@Module({
  imports: [
    CommonModule,                  // SocketRegistry + UiSocketRegistry
    StorageModule,                 // PgPoolService (Agent/Dashboard gateways)
    forwardRef(() => JobsModule),  // circular with jobs <-> ws is fine

    // Provide JwtService for DashboardGateway auth (typing-safe for ms StringValue)
    JwtModule.register({
      secret: process.env.JWT_SECRET ?? "dev-secret",
      // jsonwebtoken accepts number (seconds) or ms-format string; cast to satisfy strict types
      signOptions: { expiresIn: ((process.env.JWT_EXPIRES as any) ?? ("7d" as any)) },
    }),
  ],
  providers: [AgentGateway, DashboardGateway],
  exports: [AgentGateway, DashboardGateway],
})
export class WsModule { }

===== END FILE remoteiq-minimal-e2e\backend\src\ws\ws.module.ts =====

===== FILE: remoteiq-minimal-e2e\backend\src\ws\agent.gateway.ts (192 lines) =====
// backend/src/ws/agent.gateway.ts
import {
  Inject,
  Injectable,
  Logger,
  OnModuleDestroy,
  OnModuleInit,
  forwardRef,
} from "@nestjs/common";
import { WebSocketGateway, WebSocketServer } from "@nestjs/websockets";
import type { Server as WsServer, WebSocket, RawData } from "ws";

import { SocketRegistry, type AgentSocket } from "../common/socket-registry.service";
import { DispatcherService } from "../jobs/dispatcher.service";
import { JobsService } from "../jobs/jobs.service";

type JobResultMsg = {
  t: "job_result";
  jobId: string;
  exitCode?: number;
  stdout?: string;
  stderr?: string;
  durationMs?: number;
  status?: string; // agent may send custom text, we will map to our enum
};

type AgentHelloMsg = {
  t: "agent_hello";
  agentId?: string;
  deviceId?: string;
  hostname?: string;
  os?: string;
  arch?: string;
  version?: string;
};

function rawToString(data: RawData): string {
  if (typeof data === "string") return data;
  if (Buffer.isBuffer(data)) return data.toString("utf8");
  if (Array.isArray(data)) return Buffer.concat(data as Buffer[]).toString("utf8");
  if (data instanceof ArrayBuffer) return Buffer.from(data).toString("utf8");
  return "";
}

@WebSocketGateway({ path: "/ws" })
@Injectable()
export class AgentGateway implements OnModuleInit, OnModuleDestroy {
  private readonly log = new Logger("AgentGateway");

  @WebSocketServer()
  private ws!: WsServer;

  constructor(
    private readonly sockets: SocketRegistry,
    @Inject(forwardRef(() => DispatcherService))
    private readonly dispatcher: DispatcherService,
    @Inject(forwardRef(() => JobsService))
    private readonly jobs: JobsService,
  ) { }

  onModuleInit() {
    if (!this.ws) {
      this.log.warn("WS server not initialized by adapter; ensure a WS adapter is configured.");
      return;
    }

    this.ws.on("connection", (socket: WebSocket & Partial<AgentSocket>) => {
      this.log.debug("Agent WS connected (awaiting hello)");

      socket.on("message", async (data: RawData) => {
        const text = rawToString(data);
        if (!text) return;

        let msg: any;
        try {
          msg = JSON.parse(text);
        } catch {
          return;
        }
        const t = msg?.t as string | undefined;
        if (!t) return;

        if (t === "agent_hello") {
          const hello = msg as AgentHelloMsg;
          const agentId = String(hello.agentId ?? "").trim();
          const deviceId = String(hello.deviceId ?? "").trim();
          const hostname = String(hello.hostname ?? "").trim();

          if (!agentId) {
            this.log.warn("agent_hello missing agentId; closing socket.");
            socket.close(1008, "agentId required");
            return;
          }

          // Persist identifiers on the socket so cleanup works
          (socket as AgentSocket).agentId = agentId;
          (socket as AgentSocket).deviceId = deviceId || undefined;
          // AgentSocket doesn't declare hostname; store it loosely for logs/debug
          (socket as any).hostname = hostname || undefined;

          // Register into the registry
          this.sockets.set(agentId, deviceId || undefined, socket as AgentSocket);

          this.log.log(
            `Registered agent socket: agentId=${agentId}` +
            (deviceId ? ` deviceId=${deviceId}` : "") +
            (hostname ? ` host=${hostname}` : ""),
          );

          try {
            await this.dispatcher.dispatchQueuedForAgent(agentId);
          } catch (e: any) {
            this.log.warn(`dispatchQueuedForAgent failed: ${e?.message ?? e}`);
          }
          return;
        }

        if (t === "job_result") {
          const jr = msg as JobResultMsg;
          if (!jr.jobId) {
            this.log.warn("job_result missing jobId; ignoring");
            return;
          }

          const exitCode = Number.isFinite(jr.exitCode) ? Number(jr.exitCode) : -1;
          const stdout = typeof jr.stdout === "string" ? jr.stdout : "";
          const stderr = typeof jr.stderr === "string" ? jr.stderr : "";
          const durationMs = Number.isFinite(jr.durationMs) ? Number(jr.durationMs) : 0;

          // Map to our JobsService status enum: "succeeded" | "failed" | "timeout"
          let status: "succeeded" | "failed" | "timeout";
          const s = (jr.status ?? "").toLowerCase();
          if (s === "timeout") status = "timeout";
          else if (s === "succeeded" || (s === "finished" && exitCode === 0) || exitCode === 0) status = "succeeded";
          else status = "failed";

          try {
            await this.jobs.finishJob(
              jr.jobId,
              { exitCode, stdout, stderr, durationMs },
              status,
            );
          } catch (e: any) {
            this.log.warn(`finishJob failed for ${jr.jobId}: ${e?.message ?? e}`);
          }
          return;
        }
      });

      socket.on("close", () => {
        const s = socket as AgentSocket;
        if (s.agentId) this.sockets.deleteByAgent(s.agentId);
        if (s.deviceId) this.sockets.deleteByDevice(s.deviceId);
      });

      socket.on("error", () => {
        // close handler will clean up
      });
    });
  }

  onModuleDestroy() {
    try {
      this.ws?.close();
    } catch {
      /* ignore */
    }
  }

  /**
   * Broadcast a JSON message to all connected agent sockets.
   * automation.controller.ts expects this to exist.
   */
  public broadcast(payload: unknown, filter?: (s: AgentSocket) => boolean): number {
    if (!this.ws?.clients) return 0;
    let sent = 0;
    for (const client of this.ws.clients) {
      const sock = client as AgentSocket;
      // 'OPEN' is a numeric const on ws WebSocket instances
      if ((client as any).readyState !== (client as any).OPEN) continue;
      if (filter && !filter(sock)) continue;
      try {
        client.send(JSON.stringify(payload));
        sent++;
      } catch {
        // ignore per-socket send errors
      }
    }
    return sent;
  }
}

===== END FILE remoteiq-minimal-e2e\backend\src\ws\agent.gateway.ts =====

===== FILE: remoteiq-minimal-e2e\backend\src\ws\dashboard.gateway.ts (251 lines) =====
// backend/src/ws/dashboard.gateway.ts
import {
    Injectable,
    Logger,
    OnModuleDestroy,
    OnModuleInit,
} from "@nestjs/common";
import { WebSocketGateway, WebSocketServer } from "@nestjs/websockets";
import type { Server as WsServer, WebSocket, RawData } from "ws";
import type { IncomingMessage } from "http";
import { JwtService } from "@nestjs/jwt";

import {
    UiSocketRegistry,
    type UiSocket,
} from "../common/ui-socket-registry.service";

/**
 * Minimal cookie parser (avoids external deps).
 */
function parseCookieHeader(h?: string): Record<string, string> {
    const out: Record<string, string> = {};
    if (!h) return out;
    for (const p of h.split(";")) {
        const i = p.indexOf("=");
        if (i > -1) out[p.slice(0, i).trim()] = decodeURIComponent(p.slice(i + 1));
    }
    return out;
}

/**
 * Safely stringify payloads for WS.
 */
function safeJson(data: unknown): string {
    try {
        return JSON.stringify(data);
    } catch {
        return "{}";
    }
}

/**
 * UI (dashboard) WebSocket gateway.
 * - Authenticates users by JWT cookie (same cookie as HTTP)
 * - Registers sockets into UiSocketRegistry
 * - Supports per-device subscriptions: {t:"subscribe", deviceId}, {t:"unsubscribe", deviceId}
 * - Heartbeat: {t:"ping"} -> {t:"pong"}
 *
 * NOTE: Remember to add DashboardGateway to WsModule.providers.
 */
@WebSocketGateway({ path: "/ws-ui" })
@Injectable()
export class DashboardGateway implements OnModuleInit, OnModuleDestroy {
    private readonly log = new Logger("DashboardGateway");

    @WebSocketServer()
    private ws!: WsServer;

    private readonly cookieName =
        process.env.AUTH_COOKIE_NAME?.trim() || "auth_token";
    private readonly jwtSecret =
        process.env.JWT_SECRET?.trim() || "dev-secret"; // dev fallback

    constructor(
        private readonly uiSockets: UiSocketRegistry,
        private readonly jwt: JwtService
    ) { }

    onModuleInit() {
        if (!this.ws) {
            this.log.warn(
                "WS server not initialized by adapter; ensure a WS adapter is configured."
            );
            return;
        }

        this.ws.on(
            "connection",
            async (rawSocket: WebSocket, req: IncomingMessage) => {
                const socket = rawSocket as UiSocket;

                // ---- Authenticate user from cookie JWT ----
                const cookies = parseCookieHeader(
                    (req.headers && (req.headers as any).cookie) || ""
                );
                const token = cookies[this.cookieName];
                if (!token) {
                    this.closeWithPolicy(socket, 4401, "Missing auth cookie");
                    return;
                }

                let userId = "";
                try {
                    const payload: any = await this.jwt.verifyAsync(token, {
                        secret: this.jwtSecret,
                    });
                    // Expect standard fields from your login flow
                    userId = String(payload?.sub || payload?.id || "");
                    if (!userId) throw new Error("No sub in JWT");
                } catch (e: any) {
                    this.closeWithPolicy(
                        socket,
                        4401,
                        `Invalid auth token: ${e?.message || e}`
                    );
                    return;
                }

                // ---- Register socket ----
                try {
                    // Ensure subscriptions set exists for this socket
                    socket.subscriptions = socket.subscriptions ?? new Set<string>();
                    this.uiSockets.add(userId, socket);

                    // Ack the connection
                    socket.send(
                        safeJson({
                            t: "ack",
                            userId,
                            subscriptions: Array.from(socket.subscriptions),
                            totals: {
                                sockets: this.uiSockets.countAll(),
                                users: this.uiSockets.countUsers(),
                            },
                        })
                    );
                } catch (e: any) {
                    this.log.warn(
                        `Failed to register UI socket for user ${userId}: ${e?.message || e}`
                    );
                    this.closeWithPolicy(socket, 1011, "Registration failed");
                    return;
                }

                // ---- Message handling ----
                socket.on("message", (data: RawData) => {
                    const text = this.rawToString(data);
                    if (!text) return;

                    let msg: any;
                    try {
                        msg = JSON.parse(text);
                    } catch {
                        return;
                    }
                    const t: string = String(msg?.t || "");

                    // Ping/Pong
                    if (t === "ping") {
                        socket.send(safeJson({ t: "pong", at: new Date().toISOString() }));
                        return;
                    }

                    // Subscribe to a deviceId
                    if (t === "subscribe") {
                        const deviceId = String(msg?.deviceId || "").trim();
                        if (!deviceId) return;

                        try {
                            this.uiSockets.subscribe(socket, deviceId);
                            socket.send(
                                safeJson({
                                    t: "subscribed",
                                    deviceId,
                                    subscribers: this.uiSockets.countDeviceSubscribers(deviceId),
                                })
                            );
                        } catch (e: any) {
                            socket.send(
                                safeJson({
                                    t: "error",
                                    error: "subscribe_failed",
                                    message: e?.message || String(e),
                                })
                            );
                        }
                        return;
                    }

                    // Unsubscribe from a deviceId
                    if (t === "unsubscribe") {
                        const deviceId = String(msg?.deviceId || "").trim();
                        if (!deviceId) return;

                        try {
                            this.uiSockets.unsubscribe(socket, deviceId);
                            socket.send(
                                safeJson({
                                    t: "unsubscribed",
                                    deviceId,
                                    subscribers: this.uiSockets.countDeviceSubscribers(deviceId),
                                })
                            );
                        } catch (e: any) {
                            socket.send(
                                safeJson({
                                    t: "error",
                                    error: "unsubscribe_failed",
                                    message: e?.message || String(e),
                                })
                            );
                        }
                        return;
                    }

                    // Unknown message type — ignore silently or send error
                });

                // ---- Cleanup on close/error ----
                const cleanup = () => {
                    try {
                        this.uiSockets.remove(socket);
                    } catch {
                        /* ignore */
                    }
                };
                socket.on("close", cleanup);
                socket.on("error", cleanup);
            }
        );
    }

    onModuleDestroy() {
        try {
            this.ws?.close();
        } catch {
            /* ignore */
        }
    }

    /* ------------------------------- Helpers -------------------------------- */

    private rawToString(data: RawData): string {
        if (typeof data === "string") return data;
        if (Buffer.isBuffer(data)) return data.toString("utf8");
        if (Array.isArray(data))
            return Buffer.concat(data as Buffer[]).toString("utf8");
        if (data instanceof ArrayBuffer) return Buffer.from(data).toString("utf8");
        return "";
    }

    private closeWithPolicy(ws: WebSocket, code: number, reason: string) {
        try {
            // eslint-disable-next-line @typescript-eslint/no-explicit-any
            (ws as any).close?.(code, reason);
        } catch {
            /* ignore */
        }
    }
}

===== END FILE remoteiq-minimal-e2e\backend\src\ws\dashboard.gateway.ts =====

===== FILE: remoteiq-minimal-e2e\backend\src\app.module.ts (96 lines) =====
// remoteiq-minimal-e2e/backend/src/app.module.ts

import { Module, MiddlewareConsumer, NestModule } from "@nestjs/common";
import { ServeStaticModule } from "@nestjs/serve-static";
import { join } from "path";

import { CommonModule } from "./common/common.module";
import { AuthModule } from "./auth/auth.module";
import { WsModule } from "./ws/ws.module";
import { AgentsModule } from "./agents/agents.module";
import { JobsModule } from "./jobs/jobs.module";
import { DevicesModule } from "./devices/devices.module";
import { HealthModule } from "./health/health.module";
import { AdminModule } from "./admin/admin.module";
import { CompanyModule } from "./company/company.module";
import { BrandingModule } from "./branding/branding.module";
import { LocalizationModule } from "./localization/localization.module";
import { SupportModule } from "./support/support.module";
import { SupportLegalModule } from "./support-legal/support-legal.module";
import { UsersModule } from "./users/users.module";
import { RolesModule } from "./roles/roles.module";
import { SmtpModule } from "./smtp/smtp.module";
import { ScheduleModule } from "@nestjs/schedule";
import { ImapModule } from "./imap/imap.module";
import { SessionCleanerService } from "./maintenance/session-cleaner.service";

import { JwtModule } from "@nestjs/jwt";

// ✅ correct path: the middleware file is under /auth, not /common
import { AuthCookieMiddleware } from "./auth/auth-cookie.middleware";

// ✅ bring PgPoolService into the AppModule DI context
import { StorageModule } from "./storage/storage.module";

@Module({
    imports: [
        // Static files mounted at /static -> maps to /public
        ServeStaticModule.forRoot({
            rootPath: join(__dirname, "..", "public"),
            serveRoot: "/static",
        }),

        // JwtService for middleware
        JwtModule.register({
            secret: process.env.JWT_SECRET ?? "dev-secret",
        }),

        // Base/shared
        CommonModule,

        // ✅ Storage (PgPoolService) must be available for main.ts interceptor registration
        StorageModule,

        // Feature modules
        BrandingModule,
        AuthModule,
        WsModule,
        AgentsModule,
        JobsModule,
        DevicesModule,
        HealthModule,
        AdminModule,
        CompanyModule,
        LocalizationModule,
        SupportModule,
        SupportLegalModule,
        UsersModule,
        RolesModule,

        // SMTP + IMAP
        SmtpModule,
        ScheduleModule.forRoot(),
        ImapModule,
    ],
    providers: [
        // Daily cleanup of revoked sessions
        SessionCleanerService,
    ],
})
export class AppModule implements NestModule {
    configure(consumer: MiddlewareConsumer) {
        // Apply cookie->req.user middleware to everything except obvious public/static routes
        consumer
            .apply(AuthCookieMiddleware)
            .exclude(
                "healthz",
                "docs",
                "docs/(.*)",
                "static/(.*)",      // static files
                "api/auth/login",   // login doesn’t need req.user
                "api/auth/logout"   // logout doesn’t need req.user
            )
            .forRoutes("*");
    }
}

===== END FILE remoteiq-minimal-e2e\backend\src\app.module.ts =====

===== FILE: remoteiq-minimal-e2e\backend\src\main.ts (138 lines) =====
// backend/src/main.ts
import "reflect-metadata";
import "dotenv/config";
import { NestFactory } from "@nestjs/core";
import { AppModule } from "./app.module";
import cookieParser from "cookie-parser";
import { WsAdapter } from "@nestjs/platform-ws";
import { ValidationPipe, INestApplication } from "@nestjs/common";
import * as fs from "fs";
import * as path from "path";

// 👇 add this import to serve static files
import { NestExpressApplication } from "@nestjs/platform-express";

// Pg + interceptor
import { PgPoolService } from "./storage/pg-pool.service";
import { SessionHeartbeatInterceptor } from "./auth/session-heartbeat.interceptor";

/** Mount /docs only when allowed (and if @nestjs/swagger is present). */
async function maybeSetupSwagger(app: INestApplication) {
  const enableSwagger =
    (process.env.SWAGGER ?? "").toLowerCase() === "true" ||
    process.env.NODE_ENV !== "production";

  if (!enableSwagger) {
    console.log("Swagger disabled (set SWAGGER=true to enable).");
    return;
  }
  try {
    // eslint-disable-next-line @typescript-eslint/no-var-requires
    const { SwaggerModule, DocumentBuilder } = require("@nestjs/swagger");
    const config = new DocumentBuilder()
      .setTitle("RemoteIQ API")
      .setDescription("OpenAPI for RemoteIQ RMM")
      .setVersion("v1")
      .addBearerAuth({ type: "http", scheme: "bearer", bearerFormat: "JWT" }, "bearer")
      .build();
    const document = SwaggerModule.createDocument(app, config);
    SwaggerModule.setup("/docs", app, document);
    console.log("Swagger docs mounted at /docs");
  } catch {
    console.log("Swagger not installed. Skip docs (pnpm add -D @nestjs/swagger swagger-ui-express)");
  }
}

function configureCors(app: INestApplication) {
  const isProd = process.env.NODE_ENV === "production";

  const listFromFrontends =
    (process.env.FRONTEND_ORIGINS || "")
      .split(",")
      .map((s) => s.trim())
      .filter(Boolean);

  const listFromAllowed = (process.env.ALLOWED_ORIGIN || "")
    .split(",")
    .map((s) => s.trim())
    .filter(Boolean);

  const origins = listFromFrontends.length ? listFromFrontends : listFromAllowed;

  if (isProd && origins.length > 0) {
    app.enableCors({
      origin: origins,
      credentials: true,
      methods: ["GET", "POST", "PUT", "PATCH", "DELETE", "OPTIONS"],
      allowedHeaders: ["Content-Type", "Authorization", "x-admin-api-key"],
      exposedHeaders: ["Content-Length"],
    });
    console.log("CORS restricted to:", origins);
  } else {
    app.enableCors({
      origin: (_origin, cb) => cb(null, true),
      credentials: true,
      methods: ["GET", "POST", "PUT", "PATCH", "DELETE", "OPTIONS"],
      allowedHeaders: ["Content-Type", "Authorization", "x-admin-api-key"],
      exposedHeaders: ["Content-Length"],
    });
    console.log("CORS open (dev). Set FRONTEND_ORIGINS or ALLOWED_ORIGIN for prod.");
  }
}

async function bootstrap() {
  // Ensure uploads directory exists (multer doesn't create it)
  const uploadsDir = path.join(process.cwd(), "public", "uploads");
  if (!fs.existsSync(uploadsDir)) fs.mkdirSync(uploadsDir, { recursive: true });

  // 👇 tell Nest this is an Express app so we can useStaticAssets
  const app = await NestFactory.create<NestExpressApplication>(AppModule);

  // 👇 serve /static/* from ./public/*
  app.useStaticAssets(path.join(process.cwd(), "public"), {
    prefix: "/static/",
  });

  app.use(cookieParser());
  configureCors(app);

  app.useWebSocketAdapter(new WsAdapter(app));

  app.useGlobalPipes(
    new ValidationPipe({
      whitelist: true,
      forbidNonWhitelisted: true,
      transform: true,
    })
  );

  app.enableShutdownHooks();

  app.getHttpAdapter().getInstance().get("/healthz", (_req: any, res: any) => res.send("OK"));

  await maybeSetupSwagger(app);

  // ✅ Register SessionHeartbeatInterceptor only if PgPoolService is resolvable
  try {
    const pg = app.get(PgPoolService, { strict: false });
    if (pg) {
      app.useGlobalInterceptors(new SessionHeartbeatInterceptor(pg));
      console.log("SessionHeartbeatInterceptor enabled.");
    } else {
      console.warn(
        "PgPoolService not found in AppModule context; SessionHeartbeatInterceptor NOT enabled."
      );
    }
  } catch (err) {
    console.warn(
      "Could not enable SessionHeartbeatInterceptor (continuing without it):",
      (err as Error)?.message || err
    );
  }

  const port = Number(process.env.PORT || 3001);
  await app.listen(port);
  console.log(`API up on http://localhost:${port}`);
}
bootstrap();

===== END FILE remoteiq-minimal-e2e\backend\src\main.ts =====

===== FILE: remoteiq-frontend\lib\api.ts (934 lines) =====
// Centralized typed API client used by the frontend (Next.js / React).
// It reads NEXT_PUBLIC_API_BASE for the backend base URL.

// ---------------------------- ENV / BASE ------------------------------------
const API_BASE =
  (typeof process !== "undefined" && process.env.NEXT_PUBLIC_API_BASE) || "";

// Utility to join base + path safely
function url(path: string) {
  if (!API_BASE) return path;
  return `${API_BASE.replace(/\/+$/, "")}${path.startsWith("/") ? "" : "/"}${path}`;
}

type JsonInit = Omit<RequestInit, "body" | "method"> & {
  body?: any;
  method?: "GET" | "POST" | "PUT" | "PATCH" | "DELETE";
};

// unified fetch wrapper w/ JSON
export async function jfetch<T>(path: string, init: JsonInit = {}): Promise<T> {
  const { body, ...rest } = init;
  const res = await fetch(url(path), {
    method: init.method ?? (body != null ? "POST" : "GET"),
    credentials: "include",
    headers: {
      "Content-Type": "application/json",
      ...(init.headers ?? {}),
    },
    body: body != null ? JSON.stringify(body) : undefined,
    ...rest,
  });

  if (!res.ok) {
    // try to surface JSON message; fall back to text
    let msg = "";
    try {
      const data = await res.json();
      msg = typeof (data as any)?.message === "string" ? (data as any).message : JSON.stringify(data);
    } catch {
      try {
        msg = await res.text();
      } catch {
        // ignore
      }
    }
    const err = new Error(msg || `Request failed: ${res.status}`);
    (err as any).status = res.status; // preserve status for caller fallbacks
    throw err;
  }

  if (res.status === 204) return undefined as unknown as T;
  try {
    return (await res.json()) as T;
  } catch {
    // when backend returns 200 with empty body
    return undefined as unknown as T;
  }
}

// ---------------------------------------------------------------------------
// Devices (grid + details)
// ---------------------------------------------------------------------------
// lib/api.ts  (only showing the Device type block; keep the rest as-is)
export type Device = {
  id: string;
  hostname: string;
  os: string;
  arch?: string | null;
  lastSeen?: string | null;
  status: "online" | "offline";
  client?: string | null;
  site?: string | null;
  user?: string | string[] | null;
  version?: string | null;      // <-- add
  primaryIp?: string | null;    // <-- add
  /** Optional UUID for the underlying agent (if backend provides it). */
  agentUuid?: string | null;    // <-- NEW (harmless if absent)
};

export type DevicesResponse = {
  items: Device[];
  nextCursor: string | null;
};

export type DeviceFilters = {
  q?: string;
  status?: "online" | "offline";
  os?: string[];
};

export async function fetchDevices(
  pageSize = 25,
  cursor: string | null = null,
  filters?: DeviceFilters
): Promise<DevicesResponse> {
  const sp = new URLSearchParams();
  sp.set("pageSize", String(pageSize));
  if (cursor) sp.set("cursor", cursor);
  if (filters?.q) sp.set("q", filters.q);
  if (filters?.status) sp.set("status", filters.status);
  (filters?.os ?? []).forEach((o) => sp.append("os", o));
  return await jfetch<DevicesResponse>(`/api/devices?${sp.toString()}`);
}

export async function fetchDevice(id: string): Promise<Device> {
  return await jfetch<Device>(`/api/devices/${encodeURIComponent(id)}`);
}

// ---------------------------------------------------------------------------
// Device insights (checks / software)
// ---------------------------------------------------------------------------
export type DeviceCheck = {
  id: string;
  name: string;
  status: "Passing" | "Warning" | "Failing";
  lastRun: string;
  output: string;

  // ----- Optional advanced fields (rendered when present) -----
  /** e.g., "PING","CPU","MEMORY","DISK","SERVICE","PROCESS","PORT","WINEVENT","SOFTWARE","SECURITY","SCRIPT","PATCH","CERT","SMART","RDP","SMB","FIREWALL" */
  type?: string;
  /** severity classification applied to alerting paths */
  severity?: "WARN" | "CRIT";
  /** optional grouping like "Performance", "Security", "Compliance" */
  category?: string;
  /** arbitrary labels */
  tags?: string[];
  /** thresholds used to evaluate this check (key/value) */
  thresholds?: Record<string, any>;
  /** metrics captured by the last run (key/value) */
  metrics?: Record<string, number | string | boolean>;
  /** true if within an active maintenance window */
  maintenance?: boolean;
  /** deduplication key for alert correlation */
  dedupeKey?: string;
};

/** Fetch device-scoped checks; limit is optional and passed to the backend if provided. */
export async function fetchDeviceChecks(
  deviceId: string,
  limit?: number
): Promise<{ items: DeviceCheck[] }> {
  const base = `/api/devices/${encodeURIComponent(deviceId)}/checks`;
  const path = typeof limit === "number" ? `${base}?limit=${encodeURIComponent(String(limit))}` : base;
  return await jfetch(path);
}

export type DeviceSoftware = {
  id: string;
  name: string;
  version: string;
  publisher?: string | null;
  installDate?: string | null;
};

export async function fetchDeviceSoftware(deviceId: string): Promise<{ items: DeviceSoftware[] }> {
  return await jfetch(`/api/devices/${encodeURIComponent(deviceId)}/software`);
}

// ---------------------------------------------------------------------------
// Device actions
// ---------------------------------------------------------------------------
export async function rebootDevice(id: string): Promise<{ accepted: true; jobId: string }> {
  return await jfetch(`/api/devices/${encodeURIComponent(id)}/actions/reboot`, { method: "POST" });
}
export async function patchDevice(id: string): Promise<{ accepted: true; jobId: string }> {
  return await jfetch(`/api/devices/${encodeURIComponent(id)}/actions/patch`, { method: "POST" });
}

// ---------------------------------------------------------------------------
// Automation / Runs
// ---------------------------------------------------------------------------
export type RunScriptRequest = {
  deviceId: string;
  script: string;
  shell?: "powershell" | "bash" | "cmd";
  timeoutSec?: number;
};

export async function postRunScript(req: RunScriptRequest): Promise<{ jobId: string }> {
  return await jfetch(`/api/automation/runs`, { method: "POST", body: req });
}

export type JobSnapshot = {
  jobId: string;
  deviceId: string;
  status: "queued" | "running" | "succeeded" | "failed" | "canceled";
  log: string;
  exitCode?: number | null;
  startedAt: number;
  finishedAt?: number | null;
};

export async function fetchJob(jobId: string): Promise<JobSnapshot> {
  return await jfetch(`/api/automation/runs/${encodeURIComponent(jobId)}`);
}
export async function fetchJobLog(jobId: string): Promise<{ jobId: string; log: string }> {
  return await jfetch(`/api/automation/runs/${encodeURIComponent(jobId)}/log`);
}

// ---------------------------------------------------------------------------
// Admin → Database configuration
// ---------------------------------------------------------------------------
export type DbEngine = "postgresql" | "mysql" | "mssql" | "sqlite" | "mongodb";
export type DbAuthMode = "fields" | "url";
export type StorageDomain =
  | "users" | "roles" | "sessions" | "audit_logs" | "devices" | "policies" | "email_queue";

export type DatabaseMappings = Record<StorageDomain, string>;

export type DatabaseConfig = {
  enabled: boolean;
  engine: DbEngine;
  authMode: DbAuthMode;
  url?: string;
  host?: string;
  port?: number;
  dbName?: string;
  username?: string;
  password?: string;
  ssl: boolean;
  poolMin: number;
  poolMax: number;
  readReplicas?: string;
  mappings: DatabaseMappings;
};

export type DbTestResult = {
  ok: boolean;
  engine: DbEngine;
  primary: { ok: boolean; message?: string };
  replicas?: Array<{ url: string; ok: boolean; message?: string }>;
  note?: string;
};

export async function getDatabaseConfig(): Promise<DatabaseConfig | { enabled: false }> {
  return await jfetch(`/api/admin/database`);
}

export async function testDatabaseConfig(cfg: DatabaseConfig): Promise<DbTestResult> {
  return await jfetch(`/api/admin/database/test`, { method: "POST", body: cfg });
}

export async function saveDatabaseConfig(cfg: DatabaseConfig): Promise<void> {
  await jfetch<void>(`/api/admin/database/save`, { method: "POST", body: cfg });
}

export async function dryRunDatabaseMigration(): Promise<{ ok: true; destructive: false; steps: string[] }> {
  return await jfetch(`/api/admin/database/migrate/dry-run`, { method: "POST" });
}

// --- Company profile (admin) ---
export type CompanyProfile = {
  name: string;
  legalName?: string;
  email?: string;
  phone?: string;
  fax?: string;
  website?: string;
  vatTin?: string;
  address1?: string;
  address2?: string;
  city?: string;
  state?: string;
  postal?: string;
  country?: string;
};

export async function getCompanyProfile(): Promise<CompanyProfile> {
  return await jfetch(`/api/admin/company`);
}

export async function saveCompanyProfile(p: CompanyProfile): Promise<void> {
  await jfetch(`/api/admin/company/save`, { method: "POST", body: p });
}

// --- Localization (admin) ---
export type LocalizationSettings = {
  language: string;                // "en-US"
  dateFormat: string;              // "MM/DD/YYYY"
  timeFormat: "12h" | "24h";       // strictly 12h/24h for UI consistency
  numberFormat: string;            // "1,234.56"
  timeZone: string;                // "America/New_York"
  firstDayOfWeek: "sunday" | "monday";
  currency?: string;               // "USD"
};

export async function getLocalizationSettings(): Promise<LocalizationSettings> {
  const res = await jfetch<LocalizationSettings | { exists: false }>(`/api/admin/localization`);
  if ((res as any)?.exists === false) {
    return {
      language: "en-US",
      dateFormat: "MM/DD/YYYY",
      timeFormat: "12h",
      numberFormat: "1,234.56",
      timeZone: "America/New_York",
      firstDayOfWeek: "sunday",
      currency: "USD",
    };
  }
  // Back-compat: normalize any legacy strings to the union
  const tfRaw = (res as any).timeFormat as string | undefined;
  const timeFormat: "12h" | "24h" = tfRaw === "24h" || tfRaw === "HH:mm" ? "24h" : "12h";
  return { ...(res as LocalizationSettings), timeFormat };
}

export async function saveLocalizationSettings(p: LocalizationSettings): Promise<void> {
  await jfetch(`/api/admin/localization/save`, { method: "POST", body: p });
}

// --- Support & Legal (admin) ---
export type SupportLegalSettings = {
  id?: number;                 // present on GET only
  supportEmail?: string;
  supportPhone?: string;
  knowledgeBaseUrl?: string;
  statusPageUrl?: string;
  privacyPolicyUrl?: string;
  termsUrl?: string;
  gdprContactEmail?: string;
  legalAddress?: string;
  ticketPortalUrl?: string;
  phoneHours?: string;
  notesHtml?: string;
};

export async function getSupportLegalSettings(): Promise<SupportLegalSettings> {
  return await jfetch(`/api/admin/support-legal`);
}

export async function saveSupportLegalSettings(
  p: Omit<SupportLegalSettings, "id">
): Promise<void> {
  await jfetch(`/api/admin/support-legal/save`, { method: "POST", body: p });
}

// ======================= Users & Roles (Admin) =======================
export type RoleDTO = { id: string; name: string };
export type UserDTO = {
  id: string;
  name: string;
  email: string;
  role: string;
  twoFactorEnabled: boolean;
  suspended: boolean;
  lastSeen: string | null;
  status: "active" | "invited" | "suspended";
  createdAt?: string;
  updatedAt?: string;

  // Optional profile fields (present if your DB exposes them)
  phone?: string | null;
  address1?: string | null;
  address2?: string | null;
  city?: string | null;
  state?: string | null;
  postal?: string | null;
  country?: string | null;
};

export async function getAdminRoles(): Promise<{ items: RoleDTO[] }> {
  // Wrap server response (array) into {items} for consistency
  const arr = await jfetch<RoleDTO[]>(`/api/admin/users/roles`);
  return { items: arr };
}

export async function getAdminUsers(): Promise<{ items: UserDTO[]; total?: number }> {
  // backend returns {items, total}
  return await jfetch(`/api/admin/users`);
}

export type InvitePayload = { name?: string; email: string; role?: string; message?: string };

/** Invite one-by-one under the hood to keep types simple */
export async function inviteUsers(invites: InvitePayload[]): Promise<{ created: UserDTO[] }> {
  const created: UserDTO[] = [];
  for (const i of invites) {
    const resp = await jfetch<{ id: string }>(`/api/admin/users/invite`, {
      method: "POST",
      body: i,
    });
    created.push({
      id: resp.id,
      name: i.name ?? i.email.split("@")[0],
      email: i.email,
      role: i.role ?? "User",
      status: "invited",
      twoFactorEnabled: false,
      suspended: false,
      lastSeen: null,
    });
  }
  return { created };
}

/** Change a user's role */
export async function updateUserRole(userId: string, role: string): Promise<void> {
  await jfetch<void>(`/api/admin/users/${encodeURIComponent(userId)}/role`, {
    method: "PATCH",
    body: { role },
  });
}

/** Trigger a 2FA reset */
export async function resetUser2FA(userId: string): Promise<void> {
  await jfetch<void>(`/api/admin/users/${encodeURIComponent(userId)}/reset-2fa`, {
    method: "POST",
  });
}

/** Remove (delete) a user */
export async function removeUser(userId: string): Promise<void> {
  await jfetch<void>(`/api/admin/users/${encodeURIComponent(userId)}`, {
    method: "DELETE",
  });
}

/** Suspend / Unsuspend user */
export async function setUserSuspended(userId: string, suspended: boolean): Promise<void> {
  await jfetch<void>(`/api/admin/users/${encodeURIComponent(userId)}/suspend`, {
    method: "POST",
    body: { suspended },
  });
}

/* -------- Admin create + reset password -------- */
export type CreateUserPayload = {
  name: string;
  email: string;
  role?: string;
  password: string;
  status?: "active" | "invited" | "suspended";
};

export async function createAdminUser(p: CreateUserPayload): Promise<{ id: string }> {
  return await jfetch(`/api/admin/users/create`, { method: "POST", body: p });
}

export async function setUserPassword(userId: string, password: string): Promise<void> {
  await jfetch(`/api/admin/users/${encodeURIComponent(userId)}/password`, {
    method: "POST",
    body: { password },
  });
}

/* -------- NEW: Update user details (partial) -------- */
export type UpdateUserPayload = Partial<{
  name: string;
  email: string;
  role: string;
  phone: string;
  address1: string;
  address2: string;
  city: string;
  state: string;
  postal: string;
  country: string;
}>;

export async function updateUser(userId: string, p: UpdateUserPayload): Promise<void> {
  await jfetch<void>(`/api/admin/users/${encodeURIComponent(userId)}`, {
    method: "PATCH",
    body: p,
  });
}

// ---------------------------------------------------------------------------
// Account (current user) - Profile
// ---------------------------------------------------------------------------
export type MeProfile = {
  id: string;
  name: string;
  email: string;
  username?: string;
  phone?: string | null;
  address1?: string | null;
  address2?: string | null;
  city?: string | null;
  state?: string | null;
  postal?: string | null;
  country?: string | null;
  timezone?: string | null;
  locale?: string | null;
  avatarUrl?: string | null; // backend may store as avatar_url; mapped server-side
  createdAt?: string;
  updatedAt?: string;
};

export type UpdateMePayload = Partial<{
  name: string;
  email: string;
  username: string;
  phone: string | null;
  address1: string | null;
  address2: string | null;
  city: string | null;
  state: string | null;
  postal: string | null;
  country: string | null;
  timezone: string | null;
  locale: string | null;
  avatarUrl: string | null;
}>;

/** Load the signed-in user's profile */
export async function getMyProfile(): Promise<MeProfile> {
  return await jfetch<MeProfile>(`/api/users/me`);
}

/** Patch the signed-in user's profile (only sends provided keys) */
export async function updateMyProfile(patch: UpdateMePayload): Promise<MeProfile> {
  const body = Object.fromEntries(Object.entries(patch).filter(([, v]) => v !== undefined));
  return await jfetch<MeProfile>(`/api/users/me`, { method: "PATCH", body });
}

// ---------------------------------------------------------------------------
// Account (current user) - Security & Sessions (legacy helpers kept)
// ---------------------------------------------------------------------------
export type SecuritySettings = {
  twoFaEnabled: boolean;
  autoRevokeSessions?: boolean;
};

export async function getSecuritySettings(): Promise<SecuritySettings> {
  return await jfetch(`/api/users/security`);
}
export async function saveSecuritySettings(p: Partial<SecuritySettings>): Promise<void> {
  await jfetch(`/api/users/security`, { method: "PATCH", body: p });
}

export type SessionDTO = {
  id: string;
  device: string;
  ip: string;
  lastActive: string;
  current: boolean;
  city?: string;
  isp?: string;
  trusted?: boolean;
};

export async function listSessions(): Promise<{ items: SessionDTO[] }> {
  return await jfetch(`/api/users/sessions`);
}
export async function toggleTrustSession(sessionId: string, trusted: boolean): Promise<void> {
  await jfetch(`/api/users/sessions/${encodeURIComponent(sessionId)}/trust`, {
    method: "POST",
    body: { trusted },
  });
}
export async function revokeSession(sessionId: string): Promise<void> {
  await jfetch(`/api/users/sessions/${encodeURIComponent(sessionId)}`, { method: "DELETE" });
}
export async function revokeAllSessions(): Promise<void> {
  await jfetch(`/api/users/sessions`, { method: "DELETE" });
}

// ---------------------------------------------------------------------------
// Account (current user) - Notifications
// ---------------------------------------------------------------------------
export type NotificationSettings = {
  email: boolean;
  push: boolean;
  product: boolean;
  digest: "off" | "daily" | "weekly";
  quiet?: { enabled: boolean; start?: string; end?: string };
  products?: string[];
};

export async function getNotificationSettings(): Promise<NotificationSettings> {
  return await jfetch(`/api/users/notifications`);
}
export async function saveNotificationSettings(p: Partial<NotificationSettings>): Promise<void> {
  await jfetch(`/api/users/notifications`, { method: "PATCH", body: p });
}

// ---------------------------------------------------------------------------
// Account (current user) - Integrations (Slack + generic webhook)
// ---------------------------------------------------------------------------
export type IntegrationsSettings = {
  slackWebhook?: string;
  webhookUrl?: string;
  webhookSigningSecret?: string;
  events?: string[];
};

export async function getIntegrationsSettings(): Promise<IntegrationsSettings> {
  return await jfetch(`/api/users/integrations`);
}
export async function saveIntegrationsSettings(p: Partial<IntegrationsSettings>): Promise<void> {
  await jfetch(`/api/users/integrations`, { method: "PATCH", body: p });
}

export async function testSlackWebhook(urlStr: string): Promise<{ ok: boolean; status: number; ms?: number }> {
  return await jfetch(`/api/users/integrations/test/slack`, { method: "POST", body: { url: urlStr } });
}
export async function testGenericWebhook(urlStr: string): Promise<{ ok: boolean; status: number; ms?: number }> {
  return await jfetch(`/api/users/integrations/test/webhook`, { method: "POST", body: { url: urlStr } });
}
export async function rotateSigningSecret(): Promise<{ secret: string }> {
  return await jfetch(`/api/users/integrations/rotate-signing-secret`, { method: "POST" });
}

// ---------------------------------------------------------------------------
// Account (current user) - API Keys
// ---------------------------------------------------------------------------
export type ApiKeyDTO = {
  id: string;          // token id (e.g., "rk_live_xxx")
  label: string;
  lastUsed?: string;
  scopes?: string[];
  expiresAt?: string;  // iso or empty string if never
};

export async function listApiKeys(): Promise<{ items: ApiKeyDTO[] }> {
  const arr = await jfetch<ApiKeyDTO[]>(`/api/users/api-keys`);
  return { items: arr };
}

export async function createApiKey(
  label: string,
  scopes: string[],
  expiresIn: "never" | "30d" | "90d",
  ipAllowlist?: string
): Promise<ApiKeyDTO> {
  return await jfetch(`/api/users/api-keys`, {
    method: "POST",
    body: { label, scopes, expiresIn, ipAllowlist },
  });
}

export async function revokeApiKey(id: string): Promise<void> {
  await jfetch(`/api/users/api-keys/${encodeURIComponent(id)}`, { method: "DELETE" });
}

export async function regenerateApiKey(id: string): Promise<{ oldId: string; newKey: string }> {
  return await jfetch(`/api/users/api-keys/${encodeURIComponent(id)}/regenerate`, { method: "POST" });
}

// Upload avatar to the dedicated endpoint
export async function uploadMyAvatar(file: File): Promise<{ url: string }> {
  const form = new FormData();
  form.append("file", file, file.name || "avatar.png");

  const base = (typeof process !== "undefined" && process.env.NEXT_PUBLIC_API_BASE) || "";
  const res = await fetch(`${base.replace(/\/+$/, "")}/api/users/me/avatar`, {
    method: "POST",
    credentials: "include",
    body: form,
  });
  if (!res.ok) {
    let msg = "";
    try { msg = (await res.json())?.message || ""; } catch { }
    if (!msg) try { msg = await res.text(); } catch { }
    throw new Error(msg || `Upload failed (${res.status})`);
  }
  return (await res.json()) as { url: string };
}

export async function removeMyAvatar(): Promise<void> {
  await jfetch<void>(`/api/users/me/avatar`, { method: "DELETE" });
}

/* ============================================================================
   NEW: Security Overview + TOTP + Sessions (ME scope) + PAT + WebAuthn stubs
   ==========================================================================*/

// ---- Types used by the Security tab ----
export type SecurityEvent = {
  id: string;
  type:
  | "signed_in"
  | "password_changed"
  | "2fa_enabled"
  | "2fa_disabled"
  | "recovery_codes_regenerated"
  | "session_revoked";
  at: string;
  ip?: string;
  userAgent?: string;
};

export type WebAuthnCredential = {
  id: string;
  label: string;
  createdAt: string;
  lastUsedAt?: string;
};

export type RecoveryCodes = string[];

// ---- Sessions (ME) ----
export type Session = {
  id: string;
  createdAt: string;
  lastSeenAt: string | null;
  ip: string | null;
  userAgent: string | null;
  current: boolean;
  trusted?: boolean;
  label?: string | null;
  revokedAt?: string | null; // <-- include so we can filter locally
};

export type SecurityOverview = {
  twoFactorEnabled: boolean;
  sessions: Session[];
  events: SecurityEvent[];
  webAuthn?: WebAuthnCredential[];
};

export type TOTPInit = { secret: string; otpauthUrl: string; qrPngDataUrl: string };

// ---- Overview ----
export async function getSecurityOverview(): Promise<SecurityOverview> {
  return await jfetch<SecurityOverview>(`/api/users/me/security`);
}

// ---- Change Password ----
export async function changePasswordSelf(current: string, next: string): Promise<void> {
  await jfetch(`/api/users/me/password`, { method: "POST", body: { current, next } });
}

// ---- TOTP 2FA ----
export async function start2FA(): Promise<TOTPInit> {
  return await jfetch<TOTPInit>(`/api/users/me/2fa/start`, { method: "POST" });
}

export async function confirm2FA(p: { code: string }): Promise<void> {
  await jfetch(`/api/users/me/2fa/confirm`, { method: "POST", body: p });
}

export async function disable2FA(p?: { code?: string; recoveryCode?: string }): Promise<void> {
  await jfetch(`/api/users/me/2fa/disable`, { method: "POST", body: p ?? {} });
}

export async function regenerateRecoveryCodes(): Promise<RecoveryCodes> {
  const res = await jfetch<{ recoveryCodes: string[] }>(`/api/users/me/2fa/recovery/regen`, {
    method: "POST",
  });
  return res.recoveryCodes;
}

// ---- Sessions (ME) ----
// NOTE: some servers include revoked sessions in the list; we filter them out.
export async function listMySessions(): Promise<{ items: Session[]; currentJti?: string }> {
  const res = await jfetch<{ items: Session[]; currentJti?: string }>(`/api/users/me/sessions/`);
  const items = (res.items ?? []).filter((s) => !s.revokedAt); // <-- hide revoked
  return { items, currentJti: res.currentJti };
}

export async function revokeAllOtherSessions(): Promise<void> {
  await jfetch(`/api/users/me/sessions/revoke-all`, { method: "POST" });
}

/**
 * Revoke a single session (ME).
 * Tries a sequence of plausible endpoints so we work with whatever the backend exposes.
 */
export async function revokeMySession(sessionId: string): Promise<void> {
  const enc = encodeURIComponent(sessionId);
  const base = `/api/users/me/sessions/${enc}`;

  // 1) Preferred: DELETE /me/sessions/:id
  try {
    await jfetch(base, { method: "DELETE" });
    return;
  } catch (e: any) {
    const msg = String(e?.message || "").toLowerCase();
    const status = e?.status ?? e?.code;
    if (!(status === 404 || status === 405 || msg.includes("cannot delete"))) throw e;
  }

  // 2) Alt: POST /me/sessions/:id/revoke
  try {
    await jfetch(`${base}/revoke`, { method: "POST" });
    return;
  } catch (e: any) {
    const status = e?.status ?? e?.code;
    if (!(status === 404 || status === 405)) throw e;
  }

  // 3) Alt: POST /me/sessions/revoke  { sessionId }
  try {
    await jfetch(`/api/users/me/sessions/revoke`, { method: "POST", body: { sessionId } });
    return;
  } catch (e: any) {
    const status = e?.status ?? e?.code;
    if (!(status === 404 || status === 405)) throw e;
  }

  // 4) Alt: POST /me/sessions/revoke/:id
  try {
    await jfetch(`/api/users/me/sessions/revoke/${enc}`, { method: "POST" });
    return;
  } catch (e: any) {
    const status = e?.status ?? e?.code;
    if (!(status === 404 || status === 405)) throw e;
  }

  // 5) Last-resort: PATCH /me/sessions/:id { action: "revoke" }
  await jfetch(base, { method: "PATCH", body: { action: "revoke" } });
}

/** Trust / untrust a session (ME) with fallbacks similar to revoke */
export async function trustMySession(
  sessionId: string,
  trusted: boolean
): Promise<{ trusted: boolean }> {
  const enc = encodeURIComponent(sessionId);
  const base = `/api/users/me/sessions/${enc}`;

  // 1) Preferred: POST /me/sessions/:id/trust { trusted }
  try {
    return await jfetch(`${base}/trust`, { method: "POST", body: { trusted } });
  } catch (e: any) {
    const status = e?.status ?? e?.code;
    if (!(status === 404 || status === 405)) throw e;
  }

  // 2) Alt: POST /me/sessions/trust { sessionId, trusted }
  try {
    return await jfetch(`/api/users/me/sessions/trust`, {
      method: "POST",
      body: { sessionId, trusted },
    });
  } catch (e: any) {
    const status = e?.status ?? e?.code;
    if (!(status === 404 || status === 405)) throw e;
  }

  // 3) Last-resort: PATCH /me/sessions/:id { trusted }
  return await jfetch(base, { method: "PATCH", body: { trusted } });
}

/** Optional: label a session (ME) */
export async function labelMySession(sessionId: string, label: string): Promise<void> {
  await jfetch(`/api/users/me/sessions/${encodeURIComponent(sessionId)}/label`, {
    method: "POST",
    body: { label },
  });
}

// lib/api.ts → mapMeSessionToDTO
export function mapMeSessionToDTO(s: Session): SessionDTO {
  return {
    id: s.id,
    device: s.label || s.userAgent || "Unknown device",
    ip: s.ip ?? "",                 // string (never undefined)
    lastActive: s.lastSeenAt ?? "", // string (never undefined)
    current: !!s.current,           // boolean
    city: undefined,
    isp: undefined,
    trusted: s.trusted ?? false,
  };
}


// ---- Personal Tokens (ME) ----
export type PersonalToken = {
  id: string;
  name: string;
  createdAt: string;
  lastUsedAt?: string;
  revokedAt?: string;
};

export async function listMyTokens(): Promise<{ items: PersonalToken[] }> {
  return await jfetch(`/api/users/me/tokens`);
}

export async function createMyToken(name: string): Promise<{ token: string; id: string }> {
  return await jfetch(`/api/users/me/tokens`, { method: "POST", body: { name } });
}

export async function revokeMyToken(id: string): Promise<void> {
  await jfetch(`/api/users/me/tokens/revoke`, { method: "POST", body: { id } });
}

// ---- WebAuthn (optional / stubbed) ----
export async function webauthnCreateOptions(): Promise<PublicKeyCredentialCreationOptions> {
  return await jfetch(`/api/users/me/webauthn/create-options`);
}

export async function webauthnFinishRegistration(attestationResponse: any): Promise<WebAuthnCredential> {
  return await jfetch(`/api/users/me/webauthn/finish`, { method: "POST", body: attestationResponse });
}

export async function deleteWebAuthnCredential(id: string): Promise<void> {
  return await jfetch(`/api/users/me/webauthn/${encodeURIComponent(id)}`, { method: "DELETE" });
}

// --- Device software: request uninstall --------------------------------
export async function requestUninstallSoftware(
  deviceId: string,
  body: { name: string; version?: string }
): Promise<{ accepted: true; jobId?: string }> {
  const res = await fetch(
    `${((typeof process !== "undefined" && process.env.NEXT_PUBLIC_API_BASE) || "").replace(/\/+$/, "")}/api/devices/${encodeURIComponent(deviceId)}/actions/uninstall`,
    {
      method: "POST",
      credentials: "include",
      headers: { "Content-Type": "application/json" },
      body: JSON.stringify(body),
    }
  );

  if (!res.ok) {
    // surface error text
    let msg = "";
    try { msg = (await res.clone().json())?.message || ""; } catch { }
    if (!msg) try { msg = await res.text(); } catch { }
    throw new Error(msg || `Request failed: ${res.status}`);
  }

  // Try JSON first
  let jobId: string | undefined;
  try {
    const json = await res.clone().json();
    jobId = json?.jobId;
  } catch {
    /* no json body */
  }

  // Fallback: parse Location header (e.g. /api/automation/runs/<uuid>)
  if (!jobId) {
    const loc = res.headers.get("Location") || res.headers.get("location");
    const m = loc?.match(/([0-9a-fA-F-]{8}-[0-9a-fA-F-]{4}-[1-5][0-9a-fA-F-]{3}-[89abAB][0-9a-fA-F-]{3}-[0-9a-fA-F-]{12})$/);
    if (m) jobId = m[1];
  }

  return { accepted: true, jobId };
}

===== END FILE remoteiq-frontend\lib\api.ts =====

===== FILE: remoteiq-frontend\lib\ws.ts (28 lines) =====
// lib/ws.ts
type Listener = (msg: any) => void;

let socket: WebSocket | null = null;
const listeners = new Set<Listener>();

export function ensureSocket(): WebSocket {
  const base = process.env.NEXT_PUBLIC_WS_BASE || "ws://localhost:3001/ws";
  if (socket && (socket.readyState === WebSocket.OPEN || socket.readyState === WebSocket.CONNECTING)) {
    return socket;
  }
  socket = new WebSocket(base);
  socket.onmessage = (ev) => {
    try {
      const data = JSON.parse(ev.data);
      for (const cb of Array.from(listeners)) cb(data);
    } catch {
      // ignore malformed frames
    }
  };
  return socket;
}

export function onWsMessage(cb: Listener) {
  listeners.add(cb);
  return () => listeners.delete(cb);
}

===== END FILE remoteiq-frontend\lib\ws.ts =====

===== FILE: remoteiq-frontend\components\checks-and-alerts-tab.tsx (986 lines) =====
// components/checks-and-alerts-tab.tsx
"use client";

import * as React from "react";
import { useParams } from "next/navigation";
import {
    Card, CardHeader, CardTitle, CardDescription, CardContent,
} from "@/components/ui/card";
import {
    Table, TableHeader, TableRow, TableHead, TableBody, TableCell,
} from "@/components/ui/table";
import { AlertTriangle, CheckCircle2, OctagonX, Info, Search, Filter, Ban, Download, Play } from "lucide-react";
import { fetchDeviceChecks, type DeviceCheck } from "@/lib/api";
import { Input } from "@/components/ui/input";
import { Button } from "@/components/ui/button";
import { Badge } from "@/components/ui/badge";
import { Tooltip, TooltipContent, TooltipProvider, TooltipTrigger } from "@/components/ui/tooltip";
import { Separator } from "@/components/ui/separator";
import { Sheet, SheetContent, SheetDescription, SheetHeader, SheetTitle } from "@/components/ui/sheet";
import { Popover, PopoverContent, PopoverTrigger } from "@/components/ui/popover";
import { Checkbox } from "@/components/ui/checkbox";
import { Tabs, TabsContent, TabsList, TabsTrigger } from "@/components/ui/tabs";

/* --------------------------- palette + glyphs --------------------------- */
type CheckStatus = "Passing" | "Failing" | "Warning";
const STATUS_META: Record<
    CheckStatus,
    {
        icon: React.ComponentType<React.SVGProps<SVGSVGElement>>;
        text: string;
        chipBg: string;
        ring: string;
        badgeBg: string;
        badgeText: string;
    }
> = {
    Passing: {
        icon: CheckCircle2,
        text: "text-emerald-500",
        chipBg: "bg-emerald-500/15",
        ring: "ring-emerald-500/25",
        badgeBg: "bg-emerald-500",
        badgeText: "text-white",
    },
    Warning: {
        icon: AlertTriangle,
        text: "text-amber-500",
        chipBg: "bg-amber-500/15",
        ring: "ring-amber-500/25",
        badgeBg: "bg-amber-500",
        badgeText: "text-black",
    },
    Failing: {
        icon: OctagonX,
        text: "text-red-500",
        chipBg: "bg-red-500/15",
        ring: "ring-red-500/25",
        badgeBg: "bg-red-500",
        badgeText: "text-white",
    },
};

function StatusGlyph({
    status,
    size = 18,
    className = "",
}: {
    status: CheckStatus;
    size?: number;
    className?: string;
}) {
    const s = STATUS_META[status];
    const Icon = s.icon;
    return (
        <span
            className={[
                "inline-flex items-center justify-center rounded-md p-1 ring-1",
                s.chipBg,
                s.ring,
                className,
            ].join(" ")}
            aria-hidden="true"
        >
            <Icon width={size} height={size} className={s.text} />
        </span>
    );
}

function StatusCountBadge({
    status,
    children,
    title,
    size = "md",
}: {
    status: CheckStatus;
    children: React.ReactNode;
    title?: string;
    size?: "sm" | "md" | "lg";
}) {
    const s = STATUS_META[status];
    const sizeClasses =
        size === "lg"
            ? "h-8 min-w-[2.25rem] px-2.5 text-sm font-semibold"
            : size === "sm"
                ? "h-5 min-w-[1.25rem] px-1.5 text-[11px]"
                : "h-6 min-w-[1.5rem] px-2 text-xs font-medium";
    return (
        <span
            title={title}
            className={[
                "inline-flex items-center justify-center rounded-full",
                sizeClasses,
                s.badgeBg,
                s.badgeText,
                "shadow-sm ring-1 ring-black/5 dark:ring-white/5",
            ].join(" ")}
        >
            {children}
        </span>
    );
}

/* ------------------------------- types (UI) ------------------------------- */
type Severity = "WARN" | "CRIT";
type CheckType =
    | "PING" | "CPU" | "MEMORY" | "DISK" | "SERVICE" | "PROCESS" | "PORT" | "WINEVENT"
    | "SOFTWARE" | "SECURITY" | "SCRIPT" | "PATCH" | "CERT" | "SMART" | "RDP" | "SMB" | "FIREWALL";

type AugmentedDeviceCheck = DeviceCheck & {
    type?: CheckType;
    severity?: Severity;
    category?: string;
    tags?: string[];
    thresholds?: Record<string, any>;
    metrics?: Record<string, number | string | boolean>;
    maintenance?: boolean;
    dedupeKey?: string;
};

/* ------------------------------- utilities ------------------------------- */

function formatWhen(iso?: string) {
    if (!iso) return "";
    const d = new Date(iso);
    if (Number.isNaN(+d)) return iso;
    return d.toLocaleString();
}

function truncate(str: string, max = 160) {
    if (!str) return "";
    return str.length > max ? `${str.slice(0, max)}…` : str;
}

function toCSV(items: AugmentedDeviceCheck[]) {
    const cols = [
        "id", "name", "status", "type", "severity",
        "category", "lastRun", "maintenance", "dedupeKey", "output",
    ];
    const esc = (v: any) => {
        if (v == null) return "";
        const s = String(v);
        if (s.includes(",") || s.includes("\"") || s.includes("\n")) {
            return `"${s.replace(/"/g, '""')}"`;
        }
        return s;
    };
    const header = cols.join(",");
    const lines = items.map((it) =>
        [
            it.id, it.name, it.status, (it as any).type ?? "", (it as any).severity ?? "",
            (it as any).category ?? "", it.lastRun ?? "", (it as any).maintenance ?? "",
            (it as any).dedupeKey ?? "", it.output ?? "",
        ].map(esc).join(",")
    );
    return [header, ...lines].join("\n");
}

/* ------------------------------ WS utilities ------------------------------ */

type UiWsIncoming =
    | { t: "welcome" }
    | { t: "device_checks_updated"; deviceId: string; changed?: number; at?: string }
    | { t: "error"; message: string }
    | { t: "pong" };

function makeWsUrl(path = "/ws") {
    const proto = typeof window !== "undefined" && window.location.protocol === "https:" ? "wss" : "ws";
    const host = typeof window !== "undefined" ? window.location.host : "";
    return `${proto}://${host}${path}`;
}

/* -------------------------------- component ------------------------------- */

export default function ChecksAndAlertsTab() {
    const params = useParams<{ deviceId: string }>();
    const deviceId = params?.deviceId;

    const [items, setItems] = React.useState<AugmentedDeviceCheck[]>([]);
    const [loading, setLoading] = React.useState(false);
    const [error, setError] = React.useState<string | null>(null);

    // client-side UI aids
    const [q, setQ] = React.useState("");
    const [statusFilter, setStatusFilter] = React.useState<"all" | CheckStatus>("all");
    const [severityFilter, setSeverityFilter] = React.useState<"all" | Severity>("all");
    const [typeFilter, setTypeFilter] = React.useState<"all" | CheckType>("all");
    const [selected, setSelected] = React.useState<AugmentedDeviceCheck | null>(null);
    const [selectedIds, setSelectedIds] = React.useState<Set<string>>(new Set());

    // WS refs
    const wsRef = React.useRef<WebSocket | null>(null);
    const retryRef = React.useRef<number>(1000); // backoff ms
    const pingTimerRef = React.useRef<number | null>(null);
    const reconnectTimerRef = React.useRef<number | null>(null);
    const debounceFetchTimerRef = React.useRef<number | null>(null);
    const subscribedDeviceRef = React.useRef<string | null>(null);
    const connectWsRef = React.useRef<null | (() => void)>(null);

    const isVisible = () =>
        typeof document !== "undefined" ? document.visibilityState !== "hidden" : true;

    const clearTimer = (ref: React.MutableRefObject<number | null>) => {
        if (ref.current) {
            window.clearTimeout(ref.current);
            ref.current = null;
        }
    };

    // ✅ Memoized stop/start heartbeat
    const stopHeartbeat = React.useCallback(() => {
        clearTimer(pingTimerRef);
    }, []);

    const startHeartbeat = React.useCallback(() => {
        stopHeartbeat();
        // Send ping every 25s to keep idle proxies happy
        pingTimerRef.current = window.setTimeout(function tick() {
            try {
                wsRef.current?.send(JSON.stringify({ t: "ping", at: new Date().toISOString() }));
            } catch { /* ignore */ }
            pingTimerRef.current = window.setTimeout(tick, 25_000) as unknown as number;
        }, 25_000) as unknown as number;
    }, [stopHeartbeat]);

    // ✅ Memoized reconnect scheduler using a ref to avoid circular deps
    const scheduleReconnect = React.useCallback(() => {
        clearTimer(reconnectTimerRef);
        const delay = Math.min(retryRef.current, 25_000);
        reconnectTimerRef.current = window.setTimeout(() => {
            connectWsRef.current?.(); // call latest connectWs
            retryRef.current = Math.min(retryRef.current * 2, 25_000);
        }, delay) as unknown as number;
    }, []);

    // Stable, memoized safe close
    const safeCloseWs = React.useCallback(() => {
        try { wsRef.current?.close(); } catch { /* ignore */ }
        wsRef.current = null;
        stopHeartbeat();
    }, [stopHeartbeat]);

    // Subscribe helper (no need to memoize)
    const subscribeDevice = (id: string | null | undefined) => {
        const target = id ? String(id) : null;
        if (!wsRef.current || wsRef.current.readyState !== WebSocket.OPEN) return;
        if (!target) return;
        if (subscribedDeviceRef.current === target) return;
        subscribedDeviceRef.current = target;
        try {
            wsRef.current.send(JSON.stringify({ t: "subscribe_device", deviceId: target }));
        } catch { /* ignore */ }
    };

    // ✅ Memoized incoming handler
    const refetchChecks = React.useCallback(async () => {
        if (!deviceId) return;
        try {
            setLoading(true);
            setError(null);
            const { items } = await fetchDeviceChecks(deviceId);
            setItems((items ?? []) as AugmentedDeviceCheck[]);
        } catch (e: any) {
            setError(e?.message ?? "Failed to load checks");
        } finally {
            setLoading(false);
        }
    }, [deviceId]);

    const handleIncoming = React.useCallback((raw: MessageEvent<string>) => {
        let msg: UiWsIncoming | null = null;
        try {
            msg = JSON.parse(raw.data) as UiWsIncoming;
        } catch {
            return;
        }
        if (!msg || typeof (msg as any).t !== "string") return;

        switch (msg.t) {
            case "welcome": {
                subscribeDevice(deviceId);
                break;
            }
            case "device_checks_updated": {
                if (!deviceId || msg.deviceId !== String(deviceId)) return;
                if (debounceFetchTimerRef.current) window.clearTimeout(debounceFetchTimerRef.current);
                debounceFetchTimerRef.current = window.setTimeout(async () => {
                    await refetchChecks();
                }, 500) as unknown as number;
                break;
            }
            case "pong": {
                break;
            }
            case "error": {
                // eslint-disable-next-line no-console
                console.warn("[UI WS] error:", (msg as any).message);
                break;
            }
            default:
                break;
        }
    }, [deviceId, refetchChecks]);

    // ✅ Memoized connect using memoized deps; store to ref for scheduler
    const connectWs = React.useCallback(() => {
        if (!isVisible()) return; // don't connect while tab hidden
        try {
            safeCloseWs();
            const url = makeWsUrl("/ws");
            const ws = new WebSocket(url);
            wsRef.current = ws;

            ws.addEventListener("open", () => {
                retryRef.current = 1000; // reset backoff
                startHeartbeat();
                try {
                    ws.send(JSON.stringify({ t: "ui_hello" }));
                } catch { /* ignore */ }
                subscribeDevice(deviceId);
            });

            ws.addEventListener("message", handleIncoming);
            ws.addEventListener("close", () => {
                stopHeartbeat();
                scheduleReconnect();
            });
            ws.addEventListener("error", () => {
                try { ws.close(); } catch { /* ignore */ }
            });
        } catch {
            scheduleReconnect();
        }
    }, [deviceId, handleIncoming, safeCloseWs, scheduleReconnect, startHeartbeat, stopHeartbeat]);

    // Keep the latest connectWs in a ref (used by scheduleReconnect)
    React.useEffect(() => {
        connectWsRef.current = connectWs;
    }, [connectWs]);

    /* ----------------------------- initial data load ----------------------------- */

    React.useEffect(() => {
        let alive = true;
        (async () => {
            if (!deviceId) return;
            setLoading(true); setError(null);
            try {
                const { items } = await fetchDeviceChecks(deviceId);
                if (!alive) return;
                setItems((items ?? []) as AugmentedDeviceCheck[]);
            } catch (e: any) {
                if (!alive) return;
                setError(e?.message ?? "Failed to load checks");
            } finally {
                if (alive) setLoading(false);
            }
        })();
        return () => { alive = false; };
    }, [deviceId]);

    /* ----------------------------- ws lifecycle & vis ---------------------------- */

    React.useEffect(() => {
        // Initial connect
        connectWs();

        // Re-subscribe when deviceId changes
        if (deviceId) subscribeDevice(deviceId);

        // Visibility handling (pause connections while hidden)
        const onVis = () => {
            if (isVisible()) {
                connectWsRef.current?.();
            } else {
                // optional: could safeCloseWs() to save resources
            }
        };
        document.addEventListener("visibilitychange", onVis);

        return () => {
            document.removeEventListener("visibilitychange", onVis);
            clearTimer(reconnectTimerRef);
            clearTimer(pingTimerRef);
            clearTimer(debounceFetchTimerRef);
            safeCloseWs();
        };
    }, [deviceId, connectWs, safeCloseWs]);

    // counts
    const failingChecks = items.filter((c) => c.status === "Failing").length;
    const warningChecks = items.filter((c) => c.status === "Warning").length;

    // derive type list for filter menu
    const allTypes = React.useMemo(() => {
        const t = new Set<string>();
        for (const it of items) if ((it as any).type) t.add((it as any).type as string);
        return Array.from(t).sort();
    }, [items]);

    // filtered view
    const filtered = items
        .filter((c) => (statusFilter === "all" ? true : c.status === statusFilter))
        .filter((c) => (severityFilter === "all" ? true : (c as any).severity === severityFilter))
        .filter((c) => (typeFilter === "all" ? true : (c as any).type === typeFilter))
        .filter((c) => {
            if (!q.trim()) return true;
            const hay = [
                c.name, c.output ?? "", (c as any).type ?? "", (c as any).category ?? "",
                Object.entries((c as any).metrics ?? {}).map(([k, v]) => `${k}:${v}`).join(" "),
                Object.entries((c as any).thresholds ?? {}).map(([k, v]) => `${k}:${v}`).join(" "),
                ((c as any).tags ?? []).join(" "),
            ].join(" ").toLowerCase();
            return hay.includes(q.toLowerCase());
        })
        .sort((a, b) => {
            const da = (a.lastRun ? +new Date(a.lastRun) : 0);
            const db = (b.lastRun ? +new Date(b.lastRun) : 0);
            return db - da;
        });

    const allSelected = filtered.length > 0 && filtered.every((r) => selectedIds.has(r.id));
    const toggleSelectAll = (checked: boolean) => {
        const next = new Set(selectedIds);
        if (checked) filtered.forEach((r) => next.add(r.id));
        else filtered.forEach((r) => next.delete(r.id));
        setSelectedIds(next);
    };
    const toggleRow = (id: string, on: boolean) => {
        const next = new Set(selectedIds);
        if (on) next.add(id); else next.delete(id);
        setSelectedIds(next);
    };

    // CSV export
    const exportCSV = () => {
        const csv = toCSV(filtered);
        const blob = new Blob([csv], { type: "text/csv;charset=utf-8" });
        const url = URL.createObjectURL(blob);
        const a = document.createElement("a");
        a.href = url;
        a.download = `device-checks-${deviceId ?? "unknown"}.csv`;
        a.click();
        URL.revokeObjectURL(url);
    };

    // NOTE: Bulk actions are UI-only for now (backend endpoints pending)
    const bulkAck = () => { /* wire to /api/alerts/bulk when ready */ };
    const bulkSilence = () => { /* wire to /api/alerts/bulk when ready */ };
    const bulkResolve = () => { /* wire to /api/alerts/bulk when ready */ };
    const runNow = (id: string) => { /* wire to /api/check-assignments/:id/run or /api/checks/:id/run */ };

    return (
        <TooltipProvider>
            <div className="grid gap-6">
                <div className="grid md:grid-cols-2 gap-6">
                    {/* Active Alerts */}
                    <Card>
                        <CardHeader>
                            <CardTitle>Active Alerts</CardTitle>
                            <CardDescription>A summary of checks that require attention.</CardDescription>
                        </CardHeader>
                        <CardContent className="grid gap-4">
                            {/* Failing */}
                            <div className="flex items-center justify-between p-4 rounded-lg ring-1 ring-red-500/25 bg-red-500/10">
                                <div className="flex items-center gap-4">
                                    <StatusGlyph status="Failing" className="scale-110" />
                                    <div>
                                        <p className="font-semibold">
                                            {failingChecks} Failing Check{failingChecks !== 1 && "s"}
                                        </p>
                                        <p className="text-sm text-muted-foreground">Immediate attention required.</p>
                                    </div>
                                </div>
                                <StatusCountBadge status="Failing" size="lg" title="Failing count">
                                    {failingChecks}
                                </StatusCountBadge>
                            </div>

                            {/* Warning */}
                            <div className="flex items-center justify-between p-4 rounded-lg ring-1 ring-amber-500/25 bg-amber-500/10">
                                <div className="flex items-center gap-4">
                                    <StatusGlyph status="Warning" className="scale-110" />
                                    <div>
                                        <p className="font-semibold">
                                            {warningChecks} Warning Check{warningChecks !== 1 && "s"}
                                        </p>
                                        <p className="text-sm text-muted-foreground">Potential issues detected.</p>
                                    </div>
                                </div>
                                <StatusCountBadge status="Warning" size="lg" title="Warning count">
                                    {warningChecks}
                                </StatusCountBadge>
                            </div>
                        </CardContent>
                    </Card>

                    {/* Summary / Filters */}
                    <Card>
                        <CardHeader>
                            <CardTitle>Checks Summary</CardTitle>
                            <CardDescription>Overview of all monitored checks on this device.</CardDescription>
                        </CardHeader>
                        <CardContent className="grid gap-3">
                            {loading && <div className="text-sm text-muted-foreground">Loading…</div>}
                            {error && <div className="text-sm text-red-600">{error}</div>}
                            {!loading && !error && items.length === 0 && (
                                <div className="text-sm text-muted-foreground">No checks found.</div>
                            )}

                            {/* Quick filters */}
                            <div className="flex flex-wrap items-center gap-2">
                                <Button
                                    variant={statusFilter === "all" ? "default" : "secondary"}
                                    size="sm"
                                    onClick={() => setStatusFilter("all")}
                                >
                                    All
                                </Button>
                                <Button
                                    variant={statusFilter === "Failing" ? "destructive" : "secondary"}
                                    size="sm"
                                    onClick={() => setStatusFilter("Failing")}
                                >
                                    <StatusGlyph status="Failing" className="mr-2" /> Failing
                                </Button>
                                <Button
                                    variant={statusFilter === "Warning" ? "default" : "secondary"}
                                    size="sm"
                                    onClick={() => setStatusFilter("Warning")}
                                >
                                    <StatusGlyph status="Warning" className="mr-2" /> Warning
                                </Button>
                                <Button
                                    variant={statusFilter === "Passing" ? "default" : "secondary"}
                                    size="sm"
                                    onClick={() => setStatusFilter("Passing")}
                                >
                                    <StatusGlyph status="Passing" className="mr-2" /> Passing
                                </Button>

                                <Separator orientation="vertical" className="mx-1 h-6" />

                                <div className="relative w/full sm:w-64">
                                    <Search className="absolute left-2 top-2.5 h-4 w-4 text-muted-foreground" />
                                    <Input
                                        className="pl-8"
                                        placeholder="Search checks, type, tags, output…"
                                        value={q}
                                        onChange={(e) => setQ(e.target.value)}
                                    />
                                </div>

                                <Popover>
                                    <PopoverTrigger asChild>
                                        <Button variant="outline" size="sm" className="ml-auto">
                                            <Filter className="mr-2 h-4 w-4" />
                                            More Filters
                                        </Button>
                                    </PopoverTrigger>
                                    <PopoverContent className="w-80">
                                        <div className="grid gap-3">
                                            <div className="text-sm font-medium">Severity</div>
                                            <div className="flex gap-2">
                                                <Button
                                                    size="sm"
                                                    variant={severityFilter === "all" ? "default" : "secondary"}
                                                    onClick={() => setSeverityFilter("all")}
                                                >All</Button>
                                                <Button
                                                    size="sm"
                                                    variant={severityFilter === "WARN" ? "default" : "secondary"}
                                                    onClick={() => setSeverityFilter("WARN")}
                                                >WARN</Button>
                                                <Button
                                                    size="sm"
                                                    variant={severityFilter === "CRIT" ? "destructive" : "secondary"}
                                                    onClick={() => setSeverityFilter("CRIT")}
                                                >CRIT</Button>
                                            </div>

                                            <Separator />

                                            <div className="text-sm font-medium">Type</div>
                                            <div className="flex flex-wrap gap-2">
                                                <Button
                                                    size="sm"
                                                    variant={typeFilter === "all" ? "default" : "secondary"}
                                                    onClick={() => setTypeFilter("all")}
                                                >All</Button>
                                                {allTypes.map((t) => (
                                                    <Button
                                                        key={t}
                                                        size="sm"
                                                        variant={typeFilter === (t as CheckType) ? "default" : "secondary"}
                                                        onClick={() => setTypeFilter(t as CheckType)}
                                                    >
                                                        {t}
                                                    </Button>
                                                ))}
                                            </div>
                                        </div>
                                    </PopoverContent>
                                </Popover>

                                <div className="flex items-center gap-2 ml-auto">
                                    <Button variant="outline" size="sm" onClick={exportCSV}>
                                        <Download className="mr-2 h-4 w-4" /> Export CSV
                                    </Button>
                                </div>
                            </div>

                            {/* Legend */}
                            <div className="flex flex-wrap items-center gap-2 text-xs text-muted-foreground">
                                <Info className="h-4 w-4" />
                                <span>Type/Severity/Thresholds/Metrics columns show when provided by backend.</span>
                            </div>
                        </CardContent>
                    </Card>
                </div>

                {/* History / Results */}
                <Card>
                    <CardHeader>
                        <CardTitle>Check History</CardTitle>
                        <CardDescription>A log of the most recent check results.</CardDescription>
                    </CardHeader>

                    <CardContent className="overflow-x-auto">
                        {/* Bulk bar */}
                        <div className="flex items-center justify-between pb-2">
                            <div className="flex items-center gap-3">
                                <Checkbox
                                    checked={filtered.length > 0 && filtered.every((r) => selectedIds.has(r.id))}
                                    onCheckedChange={(v) => toggleSelectAll(Boolean(v))}
                                    aria-label="Select all"
                                />
                                <span className="text-sm text-muted-foreground">
                                    {selectedIds.size} selected
                                </span>
                            </div>
                            <div className="flex items-center gap-2">
                                {/* Disabled until backend routes are wired */}
                                <Tooltip>
                                    <TooltipTrigger asChild>
                                        <span>
                                            <Button variant="secondary" size="sm" disabled onClick={bulkAck}>
                                                Ack
                                            </Button>
                                        </span>
                                    </TooltipTrigger>
                                    <TooltipContent>Bulk acknowledge (backend route pending)</TooltipContent>
                                </Tooltip>
                                <Tooltip>
                                    <TooltipTrigger asChild>
                                        <span>
                                            <Button variant="outline" size="sm" disabled onClick={bulkSilence}>
                                                Silence
                                            </Button>
                                        </span>
                                    </TooltipTrigger>
                                    <TooltipContent>Bulk silence (backend route pending)</TooltipContent>
                                </Tooltip>
                                <Tooltip>
                                    <TooltipTrigger asChild>
                                        <span>
                                            <Button variant="ghost" size="sm" disabled onClick={bulkResolve}>
                                                Resolve
                                            </Button>
                                        </span>
                                    </TooltipTrigger>
                                    <TooltipContent>Bulk resolve (backend route pending)</TooltipContent>
                                </Tooltip>
                            </div>
                        </div>

                        <Table>
                            <TableHeader>
                                <TableRow>
                                    <TableHead className="w-[44px]">
                                        <Checkbox
                                            checked={filtered.length > 0 && filtered.every((r) => selectedIds.has(r.id))}
                                            onCheckedChange={(v) => toggleSelectAll(Boolean(v))}
                                            aria-label="Select all"
                                        />
                                    </TableHead>
                                    <TableHead className="w/[44px]"></TableHead>
                                    <TableHead>Check Name</TableHead>
                                    <TableHead className="hidden xl:table-cell">Type</TableHead>
                                    <TableHead className="hidden lg:table-cell">Severity</TableHead>
                                    <TableHead className="hidden 2xl:table-cell">Metrics</TableHead>
                                    <TableHead className="hidden 2xl:table-cell">Thresholds</TableHead>
                                    <TableHead>Last Run</TableHead>
                                    <TableHead>Output</TableHead>
                                    <TableHead className="hidden md:table-cell">Actions</TableHead>
                                </TableRow>
                            </TableHeader>
                            <TableBody>
                                {filtered.map((check) => {
                                    const type = (check as any).type as string | undefined;
                                    const severity = (check as any).severity as Severity | undefined;
                                    const metrics = (check as any).metrics as Record<string, any> | undefined;
                                    const thresholds = (check as any).thresholds as Record<string, any> | undefined;
                                    const tags = (check as any).tags as string[] | undefined;
                                    const output = check.output || "";
                                    const long = output.length > 160;

                                    return (
                                        <TableRow
                                            key={check.id}
                                            className="hover:bg-accent/40"
                                        >
                                            <TableCell>
                                                <Checkbox
                                                    checked={selectedIds.has(check.id)}
                                                    onCheckedChange={(v) => toggleRow(check.id, Boolean(v))}
                                                    aria-label={`Select ${check.name}`}
                                                />
                                            </TableCell>

                                            <TableCell>
                                                <Tooltip>
                                                    <TooltipTrigger asChild>
                                                        <span>
                                                            <StatusGlyph status={check.status as CheckStatus} />
                                                        </span>
                                                    </TooltipTrigger>
                                                    <TooltipContent>{check.status}</TooltipContent>
                                                </Tooltip>
                                            </TableCell>

                                            <TableCell className="font-medium">
                                                <button
                                                    type="button"
                                                    className="text-left hover:underline decoration-dotted"
                                                    onClick={() => setSelected(check)}
                                                    title="View details"
                                                >
                                                    {check.name}
                                                </button>
                                                {!!tags?.length && (
                                                    <div className="mt-1 flex flex-wrap gap-1">
                                                        {tags.slice(0, 4).map((t) => (
                                                            <Badge key={t} variant="secondary" className="text-[10px]">{t}</Badge>
                                                        ))}
                                                        {tags.length > 4 && (
                                                            <Badge variant="outline" className="text-[10px]">
                                                                +{tags.length - 4}
                                                            </Badge>
                                                        )}
                                                    </div>
                                                )}
                                            </TableCell>

                                            <TableCell className="hidden xl:table-cell">
                                                {type ? <Badge variant="secondary">{type}</Badge> : <span className="text-muted-foreground">—</span>}
                                            </TableCell>

                                            <TableCell className="hidden lg:table-cell">
                                                {severity ? (
                                                    <Badge variant={severity === "CRIT" ? "destructive" : "secondary"}>
                                                        {severity}
                                                    </Badge>
                                                ) : (
                                                    <span className="text-muted-foreground">—</span>
                                                )}
                                            </TableCell>

                                            <TableCell className="hidden 2xl:table-cell">
                                                {metrics && Object.keys(metrics).length ? (
                                                    <div className="flex flex-wrap gap-1">
                                                        {Object.entries(metrics).slice(0, 5).map(([k, v]) => (
                                                            <Badge key={k} variant="outline" className="text-[10px]">
                                                                {k}:{String(v)}
                                                            </Badge>
                                                        ))}
                                                        {Object.keys(metrics).length > 5 && (
                                                            <Badge variant="outline" className="text-[10px]">+{Object.keys(metrics).length - 5}</Badge>
                                                        )}
                                                    </div>
                                                ) : <span className="text-muted-foreground">—</span>}
                                            </TableCell>

                                            <TableCell className="hidden 2xl:table-cell">
                                                {thresholds && Object.keys(thresholds).length ? (
                                                    <div className="flex flex-wrap gap-1">
                                                        {Object.entries(thresholds).slice(0, 5).map(([k, v]) => (
                                                            <Badge key={k} variant="outline" className="text-[10px]">
                                                                {k}:{String(v)}
                                                            </Badge>
                                                        ))}
                                                        {Object.keys(thresholds).length > 5 && (
                                                            <Badge variant="outline" className="text-[10px]">+{Object.keys(thresholds).length - 5}</Badge>
                                                        )}
                                                    </div>
                                                ) : <span className="text-muted-foreground">—</span>}
                                            </TableCell>

                                            <TableCell className="text-muted-foreground">{formatWhen(check.lastRun)}</TableCell>

                                            <TableCell className="text-muted-foreground">
                                                {long ? (
                                                    <Popover>
                                                        <PopoverTrigger asChild>
                                                            <Button variant="ghost" size="sm" className="px-0 h-auto text-left font-normal">
                                                                {truncate(output)}
                                                            </Button>
                                                        </PopoverTrigger>
                                                        <PopoverContent className="max-w-[80vw] md:max-w-[50vw] whitespace-pre-wrap">
                                                            {output}
                                                        </PopoverContent>
                                                    </Popover>
                                                ) : (
                                                    <span className="whitespace-pre-wrap">
                                                        {output || <span className="text-muted-foreground">—</span>}
                                                    </span>
                                                )}
                                            </TableCell>

                                            <TableCell className="hidden md:table-cell">
                                                <div className="flex items-center gap-2">
                                                    <Tooltip>
                                                        <TooltipTrigger asChild>
                                                            <span>
                                                                <Button size="sm" variant="outline" disabled onClick={() => runNow(check.id)}>
                                                                    <Play className="h-3.5 w-3.5 mr-1" /> Run now
                                                                </Button>
                                                            </span>
                                                        </TooltipTrigger>
                                                        <TooltipContent>Dispatch on-demand run (backend pending)</TooltipContent>
                                                    </Tooltip>

                                                    <Tooltip>
                                                        <TooltipTrigger asChild>
                                                            <span>
                                                                <Button size="sm" variant="ghost" disabled>
                                                                    <Ban className="h-3.5 w-3.5 mr-1" /> Silence
                                                                </Button>
                                                            </span>
                                                        </TooltipTrigger>
                                                        <TooltipContent>Silence alert (backend pending)</TooltipContent>
                                                    </Tooltip>
                                                </div>
                                            </TableCell>
                                        </TableRow>
                                    );
                                })}

                                {!loading && filtered.length === 0 && (
                                    <TableRow>
                                        <TableCell colSpan={10} className="text-sm text-muted-foreground">
                                            {items.length ? "No checks match the current filters." : "No checks found."}
                                        </TableCell>
                                    </TableRow>
                                )}
                            </TableBody>
                        </Table>
                    </CardContent>
                </Card>

                {/* Detail drawer */}
                <Sheet open={!!selected} onOpenChange={(open) => !open && setSelected(null)}>
                    <SheetContent side="right" className="w-full sm:max-w-xl">
                        <SheetHeader>
                            <SheetTitle className="flex items-center gap-2">
                                {selected && <StatusGlyph status={selected.status as CheckStatus} />}
                                <span>{selected?.name ?? "Check"}</span>
                            </SheetTitle>
                            <SheetDescription>
                                {selected ? (
                                    <div className="grid gap-3 text-sm">
                                        <div className="flex flex-wrap items-center gap-2">
                                            {(selected as any).type && (
                                                <Badge variant="secondary">{(selected as any).type}</Badge>
                                            )}
                                            {(selected as any).severity && (
                                                <Badge variant={(selected as any).severity === "CRIT" ? "destructive" : "secondary"}>
                                                    {(selected as any).severity}
                                                </Badge>
                                            )}
                                            {(selected as any).category && (
                                                <Badge variant="outline">{(selected as any).category}</Badge>
                                            )}
                                            {(selected as any).maintenance && (
                                                <Badge variant="outline">Maintenance</Badge>
                                            )}
                                        </div>

                                        <div className="flex items-center gap-2">
                                            <span className="text-muted-foreground">Last run:</span>
                                            <span>{formatWhen(selected.lastRun) || "—"}</span>
                                        </div>

                                        {(selected as any).dedupeKey && (
                                            <div className="flex items-center gap-2">
                                                <span className="text-muted-foreground">Key:</span>
                                                <code className="text-xs">{(selected as any).dedupeKey}</code>
                                            </div>
                                        )}

                                        {(selected as any).tags?.length ? (
                                            <div className="flex items-center gap-2">
                                                <span className="text-muted-foreground">Tags:</span>
                                                <div className="flex flex-wrap gap-1">
                                                    {(selected as any).tags.map((t: string) => (
                                                        <Badge key={t} variant="secondary" className="text-[10px]">{t}</Badge>
                                                    ))}
                                                </div>
                                            </div>
                                        ) : null}

                                        <Separator />

                                        <Tabs defaultValue="output">
                                            <TabsList className="grid grid-cols-3 w-full">
                                                <TabsTrigger value="output">Output</TabsTrigger>
                                                <TabsTrigger value="metrics">Metrics</TabsTrigger>
                                                <TabsTrigger value="thresholds">Thresholds</TabsTrigger>
                                            </TabsList>

                                            <TabsContent value="output" className="pt-2">
                                                <div className="rounded-md border p-3 bg-muted/30 whitespace-pre-wrap">
                                                    {selected.output || <span className="text-muted-foreground">No output</span>}
                                                </div>
                                            </TabsContent>

                                            <TabsContent value="metrics" className="pt-2">
                                                {Object.keys((selected as any).metrics ?? {}).length ? (
                                                    <div className="grid grid-cols-2 gap-2">
                                                        {Object.entries((selected as any).metrics).map(([k, v]) => (
                                                            <div key={k} className="flex items-center justify-between rounded border bg-muted/20 px-2 py-1">
                                                                <span className="text-muted-foreground">{k}</span>
                                                                <span className="font-medium">{String(v)}</span>
                                                            </div>
                                                        ))}
                                                    </div>
                                                ) : (
                                                    <div className="text-muted-foreground">No metrics</div>
                                                )}
                                            </TabsContent>

                                            <TabsContent value="thresholds" className="pt-2">
                                                {Object.keys((selected as any).thresholds ?? {}).length ? (
                                                    <div className="grid grid-cols-2 gap-2">
                                                        {Object.entries((selected as any).thresholds).map(([k, v]) => (
                                                            <div key={k} className="flex items-center justify-between rounded border bg-muted/20 px-2 py-1">
                                                                <span className="text-muted-foreground">{k}</span>
                                                                <span className="font-medium">{String(v)}</span>
                                                            </div>
                                                        ))}
                                                    </div>
                                                ) : (
                                                    <div className="text-muted-foreground">No thresholds</div>
                                                )}
                                            </TabsContent>
                                        </Tabs>
                                    </div>
                                ) : null}
                            </SheetDescription>
                        </SheetHeader>
                    </SheetContent>
                </Sheet>
            </div>
        </TooltipProvider>
    );
}

===== END FILE remoteiq-frontend\components\checks-and-alerts-tab.tsx =====

===== FILE: remoteiq-frontend\app\(dashboard)\devices\[deviceId]\page.tsx (334 lines) =====
// app/(dashboard)/devices/[deviceId]/page.tsx
"use client";

import * as React from "react";
import Link from "next/link";
import { useRouter, useSearchParams, usePathname } from "next/navigation";
import { Power, Play, ShieldCheck, Tag, Move, Copy } from "lucide-react";

import {
    Breadcrumb,
    BreadcrumbItem,
    BreadcrumbLink,
    BreadcrumbList,
    BreadcrumbPage,
    BreadcrumbSeparator,
} from "@/components/ui/breadcrumb";
import { Button } from "@/components/ui/button";
import { Card, CardContent, CardDescription, CardHeader, CardTitle } from "@/components/ui/card";
import { Separator } from "@/components/ui/separator";
import { Tabs, TabsContent, TabsList, TabsTrigger } from "@/components/ui/tabs";

import { useDashboard, type Device as UiDevice } from "@/app/(dashboard)/dashboard-context";
import { StatusBadge } from "@/components/status-badge";
import SoftwareTab from "@/components/software-tab";
import ChecksAndAlertsTab from "@/components/checks-and-alerts-tab";
import PatchTab from "@/components/patch-tab";
import RemoteTab from "@/components/remote-tab";

import { useDevice } from "@/lib/use-device";

// US-style "MM/DD/YYYY - H:MM AM/PM"
const dtFmt = new Intl.DateTimeFormat("en-US", {
    month: "2-digit",
    day: "2-digit",
    year: "numeric",
    hour: "numeric",
    minute: "2-digit",
    hour12: true,
});

type BadgeStatus = "healthy" | "warning" | "critical" | "offline";
function normalizeStatus(s?: string): BadgeStatus {
    switch ((s || "").toLowerCase()) {
        case "healthy":
            return "healthy";
        case "warning":
            return "warning";
        case "critical":
            return "critical";
        case "online":
            return "healthy";
        default:
            return "offline";
    }
}

export default function DeviceDetailPage({ params }: { params: { deviceId: string } }) {
    const { masterDevices, filteredDevices } = useDashboard();
    const devices = masterDevices?.length ? masterDevices : filteredDevices;

    // Local (dashboard) device if present
    const localDevice: UiDevice | undefined = React.useMemo(
        () => devices.find((d) => d.id === params.deviceId),
        [devices, params.deviceId]
    );

    // Backend device (authoritative)
    const { device: apiDevice, loading, error, refresh } = useDevice(params.deviceId);

    // Merge API device into the UI shape your page expects.
    const device: UiDevice | undefined = React.useMemo(() => {
        if (!apiDevice && !localDevice) return undefined;

        const status = normalizeStatus(apiDevice?.status ?? (localDevice as any)?.status);
        const merged: Partial<UiDevice> = {
            id: apiDevice?.id ?? localDevice?.id ?? params.deviceId,
            hostname: apiDevice?.hostname ?? localDevice?.hostname ?? "",
            alias: localDevice?.alias ?? apiDevice?.hostname ?? "",
            client: (localDevice as any)?.client ?? "—",
            site: (localDevice as any)?.site ?? "—",
            os: apiDevice?.os ?? (localDevice as any)?.os ?? "Unknown",
            status,
            // carry lastSeen through as lastResponse for display
            lastResponse: apiDevice?.lastSeen ?? (localDevice as any)?.lastResponse ?? null,
            // extra fields from backend we’ll show directly below
            ...(apiDevice
                ? {
                    arch: apiDevice.arch,
                    primaryIp: apiDevice.primaryIp,
                    version: apiDevice.version,
                    user: apiDevice.user,
                    agentUuid: (apiDevice as any)?.agentUuid ?? (localDevice as any)?.agentUuid ?? null,
                }
                : {
                    agentUuid: (localDevice as any)?.agentUuid ?? null,
                }),
        };

        return merged as unknown as UiDevice;
    }, [apiDevice, localDevice, params.deviceId]);

    const router = useRouter();
    const pathname = usePathname();
    const search = useSearchParams();

    const openRunScript = React.useCallback(() => {
        const current = new URLSearchParams(search?.toString() ?? "");
        current.set("device", params.deviceId);
        router.push(`${pathname}?${current.toString()}`);
    }, [params.deviceId, pathname, router, search]);

    const onReboot = React.useCallback(async () => {
        // TODO: wire your reboot call if available
    }, []);
    const onPatchNow = React.useCallback(async () => {
        // TODO: wire your patch call if available
    }, []);

    // ✅ HOOK DECLARED BEFORE ANY CONDITIONAL RETURNS
    const copy = React.useCallback(async (text: string) => {
        try {
            await navigator.clipboard.writeText(text);
            // optional: toast here
        } catch {
            // ignore
        }
    }, []);

    // ----- Conditional returns (no hooks below this line) -----
    if (loading && !device) {
        return (
            <div className="flex flex-col items-center justify-center h-full gap-3 text-center p-6">
                <div className="text-sm text-muted-foreground">Loading device…</div>
            </div>
        );
    }
    if (error && !device) {
        return (
            <div className="flex flex-col items-center justify-center h-full gap-4 text-center p-6">
                <h2 className="text-2xl font-semibold">Error loading device</h2>
                <p className="text-muted-foreground">{String(error)}</p>
                <div className="flex gap-2">
                    <Button variant="outline" onClick={refresh}>
                        Retry
                    </Button>
                    <Button asChild>
                        <Link href="/">Return to Dashboard</Link>
                    </Button>
                </div>
            </div>
        );
    }
    if (!device) {
        return (
            <div className="flex flex-col items-center justify-center h-full gap-4 text-center p-6">
                <h2 className="text-2xl font-semibold">Device Not Found</h2>
                <p className="text-muted-foreground">
                    The device with ID &apos;{params.deviceId}&apos; could not be found.
                </p>
                <Button asChild>
                    <Link href="/">Return to Dashboard</Link>
                </Button>
            </div>
        );
    }

    const badgeStatus: BadgeStatus = normalizeStatus(device.status as unknown as string);

    const lastSeenIso = (device as any).lastResponse as string | null;
    const lastSeenStr = lastSeenIso ? dtFmt.format(new Date(lastSeenIso)).replace(",", " -") : "—";

    const os = (device as any).os ?? "Unknown";
    const arch = (device as any).arch ?? "—";
    const primaryIp = (device as any).primaryIp ?? "—";
    const version = (device as any).version ?? "—";
    const currentUser = (device as any).user ?? "—";
    const agentUuid = (device as any)?.agentUuid as string | undefined | null;

    return (
        <main className="grid flex-1 items-start gap-4 p-4 sm:px-6 sm:py-0 md:gap-8">
            <div className="mx-auto grid w-full flex-1 auto-rows-max gap-4">
                <div className="flex items-center justify-between gap-4">
                    <Breadcrumb className="hidden md:flex">
                        <BreadcrumbList>
                            <BreadcrumbItem>
                                <BreadcrumbLink asChild>
                                    <Link href="/">Dashboard</Link>
                                </BreadcrumbLink>
                            </BreadcrumbItem>
                            <BreadcrumbSeparator />
                            <BreadcrumbItem>
                                <BreadcrumbLink asChild>
                                    <Link href="/customers">Devices</Link>
                                </BreadcrumbLink>
                            </BreadcrumbItem>
                            <BreadcrumbSeparator />
                            <BreadcrumbItem>
                                <BreadcrumbPage>{(device as any).alias || (device as any).hostname}</BreadcrumbPage>
                            </BreadcrumbItem>
                        </BreadcrumbList>
                    </Breadcrumb>

                    <div className="flex items-center gap-2">
                        <Button
                            variant="default"
                            size="sm"
                            onClick={openRunScript}
                            className="gap-2"
                            title="Open Run Script"
                        >
                            <Play className="h-4 w-4" /> Run Script
                        </Button>
                        <Button variant="outline" size="sm" title="Trigger a patch cycle" onClick={onPatchNow}>
                            <ShieldCheck className="h-4 w-4" /> Patch Now
                        </Button>
                        <Button variant="destructive" size="sm" title="Reboot this device" onClick={onReboot}>
                            <Power className="h-4 w-4" /> Reboot
                        </Button>
                    </div>
                </div>

                <Tabs defaultValue="overview">
                    <div className="flex items-center">
                        <TabsList>
                            <TabsTrigger value="overview">Overview</TabsTrigger>
                            <TabsTrigger value="remote">Remote</TabsTrigger>
                            <TabsTrigger value="checks">Checks &amp; Alerts</TabsTrigger>
                            <TabsTrigger value="patch">Patch</TabsTrigger>
                            <TabsTrigger value="software">Software</TabsTrigger>
                        </TabsList>
                        <div className="ml-auto flex items-center gap-2">
                            <Button variant="outline" size="sm" onClick={refresh} title="Refresh device data">
                                Refresh
                            </Button>
                        </div>
                    </div>

                    <TabsContent value="overview">
                        <Card>
                            <CardHeader>
                                <div className="flex justify-between items-start gap-4">
                                    <div className="min-w-0">
                                        <CardTitle className="truncate">
                                            {(device as any).alias || (device as any).hostname}
                                        </CardTitle>
                                        <CardDescription className="truncate">
                                            {(device as any).client} / {(device as any).site}
                                        </CardDescription>
                                    </div>
                                    <div className="flex items-center gap-2 shrink-0">
                                        <Button variant="outline" size="icon" title="Edit alias" aria-label="Edit alias">
                                            <Tag className="h-4 w-4" />
                                        </Button>
                                        <Button variant="outline" size="icon" title="Move device" aria-label="Move device">
                                            <Move className="h-4 w-4" />
                                        </Button>
                                    </div>
                                </div>
                            </CardHeader>
                            <CardContent>
                                <Separator className="my-4" />
                                <div className="grid grid-cols-1 md:grid-cols-3 gap-6 text-sm">
                                    <div className="space-y-1">
                                        <h3 className="font-medium text-muted-foreground">Status</h3>
                                        <StatusBadge status={badgeStatus} />
                                    </div>
                                    <div className="space-y-1">
                                        <h3 className="font-medium text-muted-foreground">Operating System</h3>
                                        <p>{os}</p>
                                    </div>
                                    <div className="space-y-1">
                                        <h3 className="font-medium text-muted-foreground">Architecture</h3>
                                        <p>{arch}</p>
                                    </div>
                                    <div className="space-y-1">
                                        <h3 className="font-medium text-muted-foreground">IP Address</h3>
                                        <p>{primaryIp}</p>
                                    </div>
                                    <div className="space-y-1">
                                        <h3 className="font-medium text-muted-foreground">Agent Version</h3>
                                        <p>{version}</p>
                                    </div>
                                    <div className="space-y-1">
                                        <h3 className="font-medium text-muted-foreground">Last Response</h3>
                                        <p>{lastSeenStr}</p>
                                    </div>

                                    {/* Agent UUID (optional) */}
                                    {agentUuid ? (
                                        <div className="space-y-1 md:col-span-3">
                                            <h3 className="font-medium text-muted-foreground">Agent UUID</h3>
                                            <div className="flex items-center gap-2">
                                                <code className="text-xs break-all">{agentUuid}</code>
                                                <Button
                                                    size="sm"
                                                    variant="outline"
                                                    title="Copy agent UUID"
                                                    onClick={() => copy(agentUuid)}
                                                    className="gap-2"
                                                >
                                                    <Copy className="h-3.5 w-3.5" />
                                                    Copy
                                                </Button>
                                            </div>
                                        </div>
                                    ) : null}

                                    <div className="space-y-1 md:col-span-3">
                                        <h3 className="font-medium text-muted-foreground">Logged-in User</h3>
                                        <p>{currentUser}</p>
                                    </div>
                                </div>
                            </CardContent>
                        </Card>
                    </TabsContent>

                    <TabsContent value="remote">
                        <RemoteTab />
                    </TabsContent>
                    <TabsContent value="checks">
                        <ChecksAndAlertsTab />
                    </TabsContent>
                    <TabsContent value="patch">
                        <PatchTab />
                    </TabsContent>
                    <TabsContent value="software">
                        <SoftwareTab />
                    </TabsContent>
                </Tabs>
            </div>
        </main>
    );
}

===== END FILE remoteiq-frontend\app\(dashboard)\devices\[deviceId]\page.tsx =====

===== FILE: remoteiq-minimal-e2e\agent-windows\RemoteIQ.Agent\Services\Http\ApiClient.cs (119 lines) =====
// remoteiq-minimal-e2e/agent-windows/RemoteIQ.Agent/Services/Http/ApiClient.cs
using System;
using System.Linq;
using System.Net.Http;
using System.Net.Http.Headers;
using System.Text;
using System.Text.Json;
using System.Threading;
using System.Threading.Tasks;
using RemoteIQ.Agent.Models;

namespace RemoteIQ.Agent.Services.Http
{
    public sealed class ApiClient
    {
        private readonly HttpClient _http;
        private readonly JsonSerializerOptions _json;

        public readonly struct VoidType { }

        public ApiClient(HttpClient http)
        {
            _http = http;
            _json = new JsonSerializerOptions
            {
                PropertyNamingPolicy = JsonNamingPolicy.CamelCase,
                PropertyNameCaseInsensitive = true,
                WriteIndented = false
            };

            _http.DefaultRequestHeaders.Accept.Clear();
            _http.DefaultRequestHeaders.Accept.Add(new MediaTypeWithQualityHeaderValue("application/json"));
        }

        public void SetBearer(string? token)
        {
            _http.DefaultRequestHeaders.Authorization =
                string.IsNullOrWhiteSpace(token) ? null : new AuthenticationHeaderValue("Bearer", token);
        }

        // ---------- Health & Enrollment ----------
        public async Task<bool> HealthAsync(CancellationToken ct = default)
        {
            using var res = await _http.GetAsync("/healthz", ct).ConfigureAwait(false);
            return res.IsSuccessStatusCode;
        }

        public async Task<EnrollResponse> EnrollAsync(EnrollRequest body, CancellationToken ct = default)
            => await PostJsonAsync<EnrollRequest, EnrollResponse>("/api/agent/enroll", body, ct).ConfigureAwait(false);

        // ---------- Ping with facts ----------
        public async Task<VoidType> PingAsync(PingRequest body, CancellationToken ct = default)
            => await PostJsonAsync<PingRequest, VoidType>("/api/agent/ping", body, ct).ConfigureAwait(false);

        // ---------- Software inventory ----------
        public async Task<VoidType> SubmitSoftwareAsync(System.Collections.Generic.IEnumerable<InstalledApp> items, CancellationToken ct = default)
        {
            var payload = new
            {
                items = items?.Select(s => new
                {
                    name = s.DisplayName,
                    version = s.Version,
                    publisher = s.Publisher,
                    installDate = s.InstallDate
                }).ToArray() ?? Array.Empty<object>()
            };

            return await PostJsonAsync<object, VoidType>("/api/agent/software", payload, ct).ConfigureAwait(false);
        }

        // ---------- Generic helpers ----------
        public async Task<T> GetJsonAsync<T>(string path, CancellationToken ct = default)
        {
            using var res = await _http.GetAsync(path, ct).ConfigureAwait(false);
            await EnsureOk(res, ct).ConfigureAwait(false);
            if (typeof(T) == typeof(VoidType)) return default!;
            await using var s = await res.Content.ReadAsStreamAsync(ct).ConfigureAwait(false);
            return (await JsonSerializer.DeserializeAsync<T>(s, _json, ct).ConfigureAwait(false))!;
        }

        public async Task<TResponse> PostJsonAsync<TRequest, TResponse>(string path, TRequest body, CancellationToken ct = default)
        {
            var content = new StringContent(JsonSerializer.Serialize(body, _json), Encoding.UTF8, "application/json");
            using var res = await _http.PostAsync(path, content, ct).ConfigureAwait(false);
            await EnsureOk(res, ct).ConfigureAwait(false);
            if (typeof(TResponse) == typeof(VoidType)) return default!;
            await using var s = await res.Content.ReadAsStreamAsync(ct).ConfigureAwait(false);
            return (await JsonSerializer.DeserializeAsync<TResponse>(s, _json, ct).ConfigureAwait(false))!;
        }

        public async Task<TResponse> PostNoBodyAsync<TResponse>(string path, CancellationToken ct = default)
        {
            using var res = await _http.PostAsync(path, content: null, ct).ConfigureAwait(false);
            await EnsureOk(res, ct).ConfigureAwait(false);
            if (typeof(TResponse) == typeof(VoidType)) return default!;
            await using var s = await res.Content.ReadAsStreamAsync(ct).ConfigureAwait(false);
            return (await JsonSerializer.DeserializeAsync<TResponse>(s, _json, ct).ConfigureAwait(false))!;
        }

        public async Task DeleteAsync(string path, CancellationToken ct = default)
        {
            using var res = await _http.DeleteAsync(path, ct).ConfigureAwait(false);
            await EnsureOk(res, ct).ConfigureAwait(false);
        }

        internal static async Task EnsureOk(HttpResponseMessage res, CancellationToken ct)
        {
            if (res.IsSuccessStatusCode) return;
            string body;
            try { body = await res.Content.ReadAsStringAsync(ct).ConfigureAwait(false); }
            catch { body = "<no body>"; }
            var status = (int)res.StatusCode;
            var reason = res.ReasonPhrase ?? "Unknown";
            throw new HttpRequestException($"HTTP {status} {reason}: {body}");
        }
    }
}

===== END FILE remoteiq-minimal-e2e\agent-windows\RemoteIQ.Agent\Services\Http\ApiClient.cs =====

===== FILE: remoteiq-minimal-e2e\agent-windows\RemoteIQ.Agent\Services\Collectors\MetricsCollector.cs (87 lines) =====
using System.Diagnostics;
using RemoteIQ.Agent.Models;
using System.Management; // <-- ADDED THIS
using System.Linq; // <-- ADDED THIS

namespace RemoteIQ.Agent.Services.Collectors;

public class MetricsCollector
{
    public (double cpuPct, double memPct, Dictionary<string, double> diskPct, List<TopProcess> tops) Sample(int topN = 5)
    {
        double cpu = GetCpuUsagePct();
        double mem = GetMemPct();
        var disk = GetDiskPct();
        var tops = GetTopProcesses(topN);
        return (cpu, mem, disk, tops);
    }

    static double GetCpuUsagePct()
    {
        try
        {
            using var cpu = new PerformanceCounter("Processor", "% Processor Time", "_Total");
            _ = cpu.NextValue();
            Thread.Sleep(500);
            return Math.Round(cpu.NextValue(), 1);
        }
        catch { return 0; }
    }

    // --- THIS METHOD IS UPDATED ---
    static double GetMemPct()
    {
        try
        {
            // Use WMI (System.Management) instead of VisualBasic
            using var searcher = new ManagementObjectSearcher("SELECT TotalVisibleMemorySize, FreePhysicalMemory FROM Win32_OperatingSystem");
            using var collection = searcher.Get();
            using var mem = collection.Cast<ManagementObject>().First();

            var totalMemKb = (ulong)mem["TotalVisibleMemorySize"];
            var freeMemKb = (ulong)mem["FreePhysicalMemory"];
            var usedMemKb = totalMemKb - freeMemKb;

            if (totalMemKb == 0) return 0; // Avoid divide by zero

            return Math.Round(100.0 * usedMemKb / totalMemKb, 1);
        }
        catch { return 0; }
    }

    static Dictionary<string, double> GetDiskPct()
    {
        var dict = new Dictionary<string, double>();
        try
        {
            foreach (var di in DriveInfo.GetDrives().Where(d => d.IsReady && d.DriveType == DriveType.Fixed))
            {
                var used = di.TotalSize - di.AvailableFreeSpace;
                var pct = 100.0 * used / Math.Max(1, (double)di.TotalSize);
                dict[di.Name.TrimEnd('\\')] = Math.Round(pct, 1);
            }
        }
        catch { }
        return dict;
    }

    static List<TopProcess> GetTopProcesses(int topN)
    {
        try
        {
            var list = Process.GetProcesses()
                .Select(p =>
                {
                    long mem = 0;
                    try { mem = p.WorkingSet64; } catch { }
                    return new { p.Id, p.ProcessName, Mem = mem };
                })
                .OrderByDescending(x => x.Mem)
                .Take(topN)
                .Select(x => new TopProcess(x.Id, x.ProcessName + ".exe", 0, x.Mem))
                .ToList();
            return list;
        }
        catch { return new List<TopProcess>(); }
    }
}
===== END FILE remoteiq-minimal-e2e\agent-windows\RemoteIQ.Agent\Services\Collectors\MetricsCollector.cs =====

===== FILE: remoteiq-minimal-e2e\agent-windows\RemoteIQ.Agent\Services\Collectors\InventoryCollector.cs (221 lines) =====
// remoteiq-minimal-e2e/agent-windows/RemoteIQ.Agent/Services/Collectors/InventoryCollector.cs
using System;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using System.Management;
using RemoteIQ.Agent.Models;

namespace RemoteIQ.Agent.Services.Collectors
{
    public class InventoryCollector
    {
        public (Hardware hw, Network net, List<SoftwareItem> sw, List<ServiceItem> svcs, List<ProcessItem> procs) Collect(int topN = 5)
        {
            var hw = GetHardware();
            var net = GetNetwork();
            var sw = GetSoftware();
            var svcs = GetServices();
            var procs = GetProcesses(topN);
            return (hw, net, sw, svcs, procs);
        }

        static Hardware GetHardware()
        {
            var cpu = new Cpu(GetCpuName(), GetCoreCount(), Environment.ProcessorCount);
            long ram = GetTotalRam();
            var disks = GetDisks();
            var gpus = GetGpus();
            var mobo = GetMotherboard();
            var bios = GetBios();
            return new Hardware(cpu, ram, disks, gpus, mobo, bios);
        }

        static string GetCpuName()
        {
            try
            {
                using var mos = new ManagementObjectSearcher("select Name from Win32_Processor");
                foreach (ManagementObject mo in mos.Get()) return mo["Name"]?.ToString() ?? "";
            }
            catch { }
            return "";
        }

        static int GetCoreCount()
        {
            try
            {
                using var mos = new ManagementObjectSearcher("select NumberOfCores from Win32_Processor");
                foreach (ManagementObject mo in mos.Get()) return Convert.ToInt32(mo["NumberOfCores"] ?? 0);
            }
            catch { }
            return Environment.ProcessorCount;
        }

        static long GetTotalRam()
        {
            try
            {
                using var mos = new ManagementObjectSearcher("select TotalVisibleMemorySize from Win32_OperatingSystem");
                foreach (ManagementObject mo in mos.Get())
                {
                    var kb = Convert.ToInt64(mo["TotalVisibleMemorySize"] ?? 0);
                    return kb * 1024;
                }
            }
            catch { }
            return 0;
        }

        static List<Disk> GetDisks()
        {
            var list = new List<Disk>();
            try
            {
                using var mos = new ManagementObjectSearcher("select Name,Size,MediaType from Win32_DiskDrive");
                foreach (ManagementObject mo in mos.Get())
                {
                    var name = mo["Name"]?.ToString() ?? "";
                    var size = Convert.ToInt64(mo["Size"] ?? 0);
                    var type = mo["MediaType"]?.ToString() ?? "";
                    list.Add(new Disk(name, size, type));
                }
            }
            catch { }
            return list;
        }

        static List<Gpu> GetGpus()
        {
            var list = new List<Gpu>();
            try
            {
                using var mos = new ManagementObjectSearcher("select Name,DriverVersion from Win32_VideoController");
                foreach (ManagementObject mo in mos.Get())
                    list.Add(new Gpu(mo["Name"]?.ToString() ?? "", mo["DriverVersion"]?.ToString()));
            }
            catch { }
            return list;
        }

        static Motherboard GetMotherboard()
        {
            try
            {
                using var mos = new ManagementObjectSearcher("select Manufacturer,Product from Win32_BaseBoard");
                foreach (ManagementObject mo in mos.Get())
                    return new Motherboard(mo["Manufacturer"]?.ToString() ?? "", mo["Product"]?.ToString() ?? "");
            }
            catch { }
            return new Motherboard("", "");
        }

        static Bios GetBios()
        {
            try
            {
                using var mos = new ManagementObjectSearcher("select Manufacturer,SMBIOSBIOSVersion,ReleaseDate from Win32_BIOS");
                foreach (ManagementObject mo in mos.Get())
                    return new Bios(mo["Manufacturer"]?.ToString() ?? "", mo["SMBIOSBIOSVersion"]?.ToString() ?? "", mo["ReleaseDate"]?.ToString());
            }
            catch { }
            return new Bios("", "", null);
        }

        static Network GetNetwork()
        {
            var list = new List<NetIf>();
            try
            {
                using var mos = new ManagementObjectSearcher(
                    "select Description,MACAddress,IPEnabled,IPAddress,DefaultIPGateway,DNSServerSearchOrder from Win32_NetworkAdapterConfiguration where IPEnabled = true");
                foreach (ManagementObject mo in mos.Get())
                {
                    var name = mo["Description"]?.ToString() ?? "Adapter";
                    var mac = mo["MACAddress"]?.ToString() ?? "";

                    var ips = mo["IPAddress"] as string[] ?? Array.Empty<string>();
                    var ipv4 = ips.Where(ip => ip != null && ip.Contains('.')).ToList();
                    var ipv6 = ips.Where(ip => ip != null && ip.Contains(':')).ToList();

                    var gw = (mo["DefaultIPGateway"] as string[] ?? Array.Empty<string>()).FirstOrDefault();
                    var dns = (mo["DNSServerSearchOrder"] as string[] ?? Array.Empty<string>()).ToList();

                    list.Add(new NetIf(name, mac, ipv4, ipv6, gw, dns));
                }
            }
            catch { }
            return new Network(list);
        }

        static List<SoftwareItem> GetSoftware()
        {
            var list = new List<SoftwareItem>();
            try
            {
                var roots = new[] {
                    Microsoft.Win32.Registry.LocalMachine.OpenSubKey(@"SOFTWARE\Microsoft\Windows\CurrentVersion\Uninstall"),
                    Microsoft.Win32.Registry.LocalMachine.OpenSubKey(@"SOFTWARE\WOW6432Node\Microsoft\Windows\CurrentVersion\Uninstall")
                };
                foreach (var root in roots.Where(r => r != null)!)
                {
                    foreach (var keyName in root!.GetSubKeyNames())
                    {
                        using var k = root.OpenSubKey(keyName);
                        var name = k?.GetValue("DisplayName")?.ToString();
                        if (string.IsNullOrWhiteSpace(name)) continue;
                        var ver = k?.GetValue("DisplayVersion")?.ToString();
                        var pub = k?.GetValue("Publisher")?.ToString();
                        var dt = k?.GetValue("InstallDate")?.ToString();
                        list.Add(new SoftwareItem(name!, ver, pub, dt));
                    }
                }
            }
            catch { }
            return list;
        }

        static List<ServiceItem> GetServices()
        {
            var list = new List<ServiceItem>();
            try
            {
                foreach (var sc in System.ServiceProcess.ServiceController.GetServices())
                {
                    string startType = "Unknown";
                    try
                    {
                        using var mos = new ManagementObjectSearcher(
                            $"select StartMode,DisplayName,Name from Win32_Service where Name='{sc.ServiceName.Replace("'", "''")}'");
                        foreach (ManagementObject mo in mos.Get())
                            startType = mo["StartMode"]?.ToString() ?? "Unknown";
                    }
                    catch { }
                    list.Add(new ServiceItem(sc.ServiceName, sc.DisplayName, sc.Status.ToString(), startType));
                }
            }
            catch { }
            return list;
        }

        static List<ProcessItem> GetProcesses(int topN)
        {
            var list = new List<ProcessItem>();
            try
            {
                foreach (var p in System.Diagnostics.Process.GetProcesses())
                {
                    long mem = 0;
                    try { mem = p.WorkingSet64; } catch { }
                    list.Add(new ProcessItem(p.Id, p.ProcessName + ".exe", 0, mem));
                }
                // Keep more than topN so server can choose what to display
                list = list.OrderByDescending(x => x.MemBytes).Take(Math.Max(10, topN * 3)).ToList();
            }
            catch { }
            return list;
        }
    }
}

===== END FILE remoteiq-minimal-e2e\agent-windows\RemoteIQ.Agent\Services\Collectors\InventoryCollector.cs =====

===== FILE: remoteiq-minimal-e2e\agent-windows\RemoteIQ.Agent\Services\Collectors\SoftwareCollector.cs (76 lines) =====
//remoteiq-minimal-e2e\agent-windows\RemoteIQ.Agent\Services\Collectors\SoftwareCollector.cs

using Microsoft.Win32;
using RemoteIQ.Agent.Models;
using System;
using System.Collections.Generic;

namespace RemoteIQ.Agent.Services.Collectors
{
    public static class SoftwareCollector
    {
        public static List<InstalledApp> Collect()
        {
            var list = new List<InstalledApp>();
            try
            {
                ReadUninstall(RegistryHive.LocalMachine, RegistryView.Registry64, list);
                ReadUninstall(RegistryHive.LocalMachine, RegistryView.Registry32, list);
            }
            catch { /* ignore */ }

            var seen = new HashSet<string>(StringComparer.OrdinalIgnoreCase);
            var dedup = new List<InstalledApp>();
            foreach (var s in list)
            {
                if (string.IsNullOrWhiteSpace(s.DisplayName)) continue;
                var key = $"{s.DisplayName}|{s.Version}";
                if (seen.Add(key)) dedup.Add(s);
            }
            return dedup;
        }

        private static void ReadUninstall(RegistryHive hive, RegistryView view, List<InstalledApp> output)
        {
            using var baseKey = RegistryKey.OpenBaseKey(hive, view);
            using var uninstall = baseKey.OpenSubKey(@"SOFTWARE\Microsoft\Windows\CurrentVersion\Uninstall");
            if (uninstall == null) return;

            foreach (var sub in uninstall.GetSubKeyNames())
            {
                using var k = uninstall.OpenSubKey(sub);
                if (k == null) continue;

                var name = (k.GetValue("DisplayName") as string)?.Trim();
                if (string.IsNullOrWhiteSpace(name)) continue;

                var version = (k.GetValue("DisplayVersion") as string)?.Trim();
                var publisher = (k.GetValue("Publisher") as string)?.Trim();

                string? installDate = (k.GetValue("InstallDate") as string)?.Trim();
                installDate = NormalizeInstallDate(installDate);

                output.Add(new InstalledApp(
                    DisplayName: name,
                    Version: string.IsNullOrWhiteSpace(version) ? null : version,
                    Publisher: string.IsNullOrWhiteSpace(publisher) ? null : publisher,
                    InstallDate: string.IsNullOrWhiteSpace(installDate) ? null : installDate
                ));
            }
        }

        private static string? NormalizeInstallDate(string? raw)
        {
            if (string.IsNullOrWhiteSpace(raw)) return null;

            if (raw.Length == 8 && int.TryParse(raw, out _))
                return $"{raw[..4]}-{raw.Substring(4, 2)}-{raw.Substring(6, 2)}";

            if (DateTime.TryParse(raw, out var dt))
                return dt.ToString("yyyy-MM-dd");

            return null;
        }
    }
}

===== END FILE remoteiq-minimal-e2e\agent-windows\RemoteIQ.Agent\Services\Collectors\SoftwareCollector.cs =====

===== FILE: remoteiq-minimal-e2e\agent-windows\RemoteIQ.Agent\Services\AgentService.cs (319 lines) =====
// remoteiq-minimal-e2e/agent-windows/RemoteIQ.Agent/Services/AgentService.cs
using Microsoft.Extensions.Hosting;
using Microsoft.Extensions.Logging;
using Microsoft.Extensions.Options;
using RemoteIQ.Agent.Models;
using RemoteIQ.Agent.Options;
using RemoteIQ.Agent.Services.Http;
using RemoteIQ.Agent.Services.Security;
using System.Net;
using System.Net.NetworkInformation;
using System.Net.Sockets;
using System.Runtime.InteropServices;
using System.Security.Principal;
using System.Threading;
using System.Threading.Tasks;
using System.Management;
using RemoteIQ.Agent.Services.Collectors;
using System;
using System.Linq;

namespace RemoteIQ.Agent.Services;

public class AgentService : BackgroundService
{
    private readonly ILogger<AgentService> _log;
    private readonly ApiClient _api;
    private readonly TokenStore _tokenStore;
    private readonly EnrollmentClient _enrollment;
    private readonly WebSocketClient _ws;
    private readonly AgentOptions _options;

    public AgentService(
        ILogger<AgentService> log,
        ApiClient api,
        TokenStore tokenStore,
        EnrollmentClient enrollment,
        WebSocketClient ws,
        IOptions<AgentOptions> options)
    {
        _log = log;
        _api = api;
        _tokenStore = tokenStore;
        _enrollment = enrollment;
        _ws = ws;
        _options = options.Value;
    }

    protected override async Task ExecuteAsync(CancellationToken stoppingToken)
    {
        _log.LogInformation("Agent starting…");

        // ✅ Enroll with required parameters: os, arch, version, hostname, ct
        var os = GetOsName();
        var arch = GetArch();
        var version = GetAgentVersion();
        var hostname = Environment.MachineName;
        await _enrollment.EnrollAsync(os, arch, version, hostname, stoppingToken);

        var tokenData = _tokenStore.Load();
        if (tokenData is null || string.IsNullOrWhiteSpace(tokenData.AgentToken) || tokenData.AgentId is null || tokenData.DeviceId is null)
        {
            _log.LogError("Enrollment/token missing after EnrollAsync. Agent cannot continue.");
            return;
        }

        _api.SetBearer(tokenData.AgentToken);

        try { await _ws.StartAsync(stoppingToken); } catch { /* non-fatal */ }

        var seconds = _options.PollIntervalSeconds > 0 ? _options.PollIntervalSeconds : 60;
        var period = TimeSpan.FromSeconds(seconds);
        using var timer = new PeriodicTimer(period);
        _log.LogInformation("Heartbeat every {Seconds}s", seconds);

        await SendPingOnce(stoppingToken);

        // One-shot software upload after first ping (best-effort)
        _ = Task.Run(() => SendSoftwareOnce(stoppingToken), stoppingToken);

        while (await timer.WaitForNextTickAsync(stoppingToken))
        {
            await SendPingOnce(stoppingToken);

            // Roughly hourly software refresh
            if (DateTimeOffset.UtcNow.Minute == 0)
                _ = Task.Run(() => SendSoftwareOnce(stoppingToken), stoppingToken);
        }
    }

    private async Task SendPingOnce(CancellationToken ct)
    {
        try
        {
            var os = GetOsName();
            var arch = GetArch();
            var version = GetAgentVersion();
            var primaryIp = GetPrimaryIPv4();
            var user = GetInteractiveUserViaWmi()
                       ?? GetLoggedInUserInteractive()
                       ?? GetLoggedInUserServiceContext();

            await _api.PingAsync(new PingRequest(
                Os: os,
                Arch: arch,
                Version: version,
                PrimaryIp: primaryIp,
                User: user
            ), ct);

            _log.LogDebug("Ping OK (os={Os} arch={Arch} ver={Ver} ip={Ip} user={User})",
                os, arch, version, primaryIp, user);
        }
        catch (OperationCanceledException) { }
        catch (HttpRequestException ex)
        {
            _log.LogWarning(ex, "Ping HTTP error.");
        }
        catch (Exception ex)
        {
            _log.LogError(ex, "Ping failed.");
        }
    }

    private async Task SendSoftwareOnce(CancellationToken ct)
    {
        try
        {
            var items = SoftwareCollector.Collect();
            if (items.Count == 0) return;

            await _api.SubmitSoftwareAsync(items, ct);
            _log.LogInformation("Uploaded {Count} software rows.", items.Count);
        }
        catch (OperationCanceledException) { }
        catch (HttpRequestException ex)
        {
            _log.LogWarning(ex, "Software upload HTTP error.");
        }
        catch (Exception ex)
        {
            _log.LogError(ex, "Software upload failed.");
        }
    }

    private static string GetOsName()
        => RuntimeInformation.IsOSPlatform(OSPlatform.Windows) ? "windows"
         : RuntimeInformation.IsOSPlatform(OSPlatform.Linux) ? "linux"
         : RuntimeInformation.IsOSPlatform(OSPlatform.OSX) ? "macos"
         : "unknown";

    private static string GetArch()
        => RuntimeInformation.OSArchitecture switch
        {
            Architecture.X64 => "x64",
            Architecture.X86 => "x86",
            Architecture.Arm64 => "arm64",
            _ => RuntimeInformation.OSArchitecture.ToString().ToLowerInvariant()
        };

    private static string GetAgentVersion()
    {
        try
        {
            return System.Reflection.Assembly.GetExecutingAssembly().GetName().Version?.ToString() ?? "1.0.0";
        }
        catch { return "1.0.0"; }
    }

    private static string? GetPrimaryIPv4()
    {
        try
        {
            foreach (var ni in NetworkInterface.GetAllNetworkInterfaces())
            {
                if (ni.OperationalStatus != OperationalStatus.Up) continue;
                var ipProps = ni.GetIPProperties();
                foreach (var ua in ipProps.UnicastAddresses)
                {
                    if (ua.Address.AddressFamily != AddressFamily.InterNetwork) continue;
                    var s = ua.Address.ToString();
                    if (IsPrivateIPv4(s)) return s;
                }
            }

            foreach (var addr in Dns.GetHostAddresses(Dns.GetHostName()))
            {
                if (addr.AddressFamily == AddressFamily.InterNetwork) return addr.ToString();
            }
        }
        catch { }
        return null;

        static bool IsPrivateIPv4(string ip)
        {
            if (IPAddress.TryParse(ip, out var addr))
            {
                var b = addr.GetAddressBytes();
                if (b[0] == 10) return true;
                if (b[0] == 172 && b[1] >= 16 && b[1] <= 31) return true;
                if (b[0] == 192 && b[1] == 168) return true;
            }
            return false;
        }
    }

    private static string? GetInteractiveUserViaWmi()
    {
        if (!RuntimeInformation.IsOSPlatform(OSPlatform.Windows))
            return null;

        try
        {
            using var cls = new ManagementClass("Win32_ComputerSystem");
            using var instances = cls.GetInstances();
            foreach (ManagementObject mo in instances)
            {
                var user = (mo["UserName"] as string)?.Trim();
                if (!string.IsNullOrWhiteSpace(user))
                    return user;
            }
        }
        catch { }
        return null;
    }

    private static string? GetLoggedInUserInteractive()
    {
        if (!RuntimeInformation.IsOSPlatform(OSPlatform.Windows))
            return null;

        try
        {
            uint sessionId = WTSGetActiveConsoleSessionId();
            if (sessionId == 0xFFFFFFFF) return null;

            if (!WTSQuerySessionInformation(IntPtr.Zero, sessionId, WTS_INFO_CLASS.WTSUserName, out var userPtr, out _)
                || userPtr == IntPtr.Zero) return null;

            try
            {
                var user = Marshal.PtrToStringUni(userPtr)?.Trim();
                if (string.IsNullOrWhiteSpace(user)) return null;

                string? domain = null;
                if (WTSQuerySessionInformation(IntPtr.Zero, sessionId, WTS_INFO_CLASS.WTSDomainName, out var domPtr, out _)
                    && domPtr != IntPtr.Zero)
                {
                    try { domain = Marshal.PtrToStringUni(domPtr)?.Trim(); }
                    finally { WTSFreeMemory(domPtr); }
                }

                return string.IsNullOrWhiteSpace(domain) ? user : $"{domain}\\{user}";
            }
            finally
            {
                WTSFreeMemory(userPtr);
            }
        }
        catch
        {
            return null;
        }
    }

    private static string GetLoggedInUserServiceContext()
    {
        try
        {
            using var wi = WindowsIdentity.GetCurrent();
            return wi?.Name ?? Environment.UserName;
        }
        catch
        {
            return Environment.UserName;
        }
    }

    public override async Task StopAsync(CancellationToken cancellationToken)
    {
        try { await _ws.DisposeAsync(); } catch { }
        await base.StopAsync(cancellationToken);
    }

    private enum WTS_INFO_CLASS
    {
        WTSInitialProgram = 0,
        WTSApplicationName = 1,
        WTSWorkingDirectory = 2,
        WTSOEMId = 3,
        WTSSessionId = 4,
        WTSUserName = 5,
        WTSWinStationName = 6,
        WTSDomainName = 7,
        WTSConnectState = 8,
        WTSClientBuildNumber = 9,
        WTSClientName = 10,
        WTSClientDirectory = 11,
        WTSClientProductId = 12,
        WTSClientHardwareId = 13,
        WTSClientAddress = 14,
        WTSClientDisplay = 15,
        WTSClientProtocolType = 16
    }

    [DllImport("wtsapi32.dll", CharSet = CharSet.Unicode, SetLastError = true)]
    private static extern bool WTSQuerySessionInformation(
        IntPtr hServer,
        uint sessionId,
        WTS_INFO_CLASS wtsInfoClass,
        out IntPtr ppBuffer,
        out int pBytesReturned);

    [DllImport("wtsapi32.dll")]
    private static extern void WTSFreeMemory(IntPtr pMemory);

    [DllImport("kernel32.dll")]
    private static extern uint WTSGetActiveConsoleSessionId();
}

===== END FILE remoteiq-minimal-e2e\agent-windows\RemoteIQ.Agent\Services\AgentService.cs =====

===== FILE: remoteiq-minimal-e2e\agent-windows\RemoteIQ.Agent\Services\EnrollmentClient.cs (183 lines) =====
using System.Net.Http.Json;
using System.Text.Json;
using Microsoft.Extensions.Configuration;
using Microsoft.Extensions.Logging;
using Microsoft.Win32;
using RemoteIQ.Agent.Models;             // AgentConfig.From(...)
using RemoteIQ.Agent.Services.Security;  // TokenStore
using System.Runtime.InteropServices;

namespace RemoteIQ.Agent.Services;

public class EnrollmentClient
{
    private readonly ILogger<EnrollmentClient> _log;
    private readonly IConfiguration _cfg;
    private readonly TokenStore _tokenStore;

    public EnrollmentClient(ILogger<EnrollmentClient> log, IConfiguration cfg, TokenStore tokenStore)
    {
        _log = log;
        _cfg = cfg;
        _tokenStore = tokenStore;
    }

    public async Task EnrollAsync(
        string os,
        string arch,
        string version,
        string hostname,
        CancellationToken ct)
    {
        var baseUrl = AgentConfig.From(_cfg).ApiBase.TrimEnd('/');

        var enrollmentSecret = _cfg["Agent:EnrollmentSecret"] ?? _cfg["EnrollmentSecret"] ?? "";
        if (string.IsNullOrWhiteSpace(enrollmentSecret))
            throw new InvalidOperationException("Missing Agent:EnrollmentSecret in configuration.");

        var deviceId = _cfg["Agent:DeviceId"] ?? DeriveDeviceId(hostname);
        if (string.IsNullOrWhiteSpace(deviceId))
            throw new InvalidOperationException("Unable to resolve a deviceId.");

        if (deviceId.Length > 200) deviceId = deviceId[..200];
        if (enrollmentSecret.Length > 200) enrollmentSecret = enrollmentSecret[..200];

        var candidates = new[]
        {
            $"{baseUrl}/api/agents/enroll",
            $"{baseUrl}/api/agent/enroll",
            $"{baseUrl}/api/auth/agents/enroll",
        };

        var payload = new
        {
            deviceId,
            enrollmentSecret,
            hostname,
            os,
            arch,
            version
        };

        Exception? lastErr = null;
        using var http = new HttpClient() { Timeout = TimeSpan.FromSeconds(20) };

        foreach (var url in candidates)
        {
            try
            {
                _log.LogInformation(
                    "Enrolling device {Host} (os={Os} arch={Arch} ver={Ver}) via {Url}",
                    hostname, os, arch, version, url);

                using var res = await http.PostAsJsonAsync(url, payload, ct);

                if ((int)res.StatusCode == 404)
                {
                    _log.LogDebug("Enroll endpoint {Url} returned 404; trying next candidate.", url);
                    continue;
                }

                var text = await res.Content.ReadAsStringAsync(ct);
                if (!res.IsSuccessStatusCode)
                    throw new InvalidOperationException($"Enrollment failed ( {(int)res.StatusCode} ): {text}");

                var (token, agentIdStr, deviceIdStr) = ParseEnrollResponse(text);
                if (string.IsNullOrWhiteSpace(token))
                    throw new InvalidOperationException("Enrollment succeeded but no agent token was returned.");

                _tokenStore.Save(new TokenStore.TokenData
                {
                    AgentToken = token,
                    AgentId = agentIdStr,
                    DeviceId = deviceIdStr ?? deviceId, // fall back to our request deviceId
                    RotateAfter = DateTime.UtcNow.AddDays(7)
                });

                _log.LogInformation("Enrolled as agentId={AgentId} deviceId={DeviceId}", agentIdStr, deviceIdStr);
                return;
            }
            catch (Exception ex)
            {
                lastErr = ex;
                _log.LogDebug(ex, "Enroll attempt failed.");
            }
        }

        throw new InvalidOperationException(
            $"Enrollment failed: {lastErr?.Message ?? "no enroll endpoint responded successfully"}",
            lastErr
        );
    }

    private static (string token, string? agentIdStr, string? deviceIdStr) ParseEnrollResponse(string json)
    {
        using var doc = JsonDocument.Parse(json);
        var root = doc.RootElement;

        string? token = TryString(root, "agentToken")
                        ?? TryString(root, "token")
                        ?? TryString(root, "accessToken");

        string? agentIdStr = TryString(root, "agentId")
                             ?? TryNumberAsString(root, "agentId")
                             ?? TryNestedNumberAsString(root, "agent", "id")
                             ?? TryNestedString(root, "agent", "id");

        string? deviceIdStr = TryString(root, "deviceId")
                              ?? TryNumberAsString(root, "deviceId")
                              ?? TryNestedNumberAsString(root, "device", "id")
                              ?? TryNestedString(root, "device", "id");

        return (token ?? "", agentIdStr, deviceIdStr);

        static string? TryString(JsonElement el, string key)
            => el.TryGetProperty(key, out var p) && p.ValueKind == JsonValueKind.String ? p.GetString() : null;

        static string? TryNumberAsString(JsonElement el, string key)
        {
            if (el.TryGetProperty(key, out var p) && p.ValueKind == JsonValueKind.Number && p.TryGetInt64(out var n))
                return n.ToString();
            return null;
        }

        static string? TryNestedNumberAsString(JsonElement el, string objKey, string innerKey)
        {
            if (el.TryGetProperty(objKey, out var obj) && obj.ValueKind == JsonValueKind.Object)
            {
                if (obj.TryGetProperty(innerKey, out var p))
                {
                    if (p.ValueKind == JsonValueKind.Number && p.TryGetInt64(out var n)) return n.ToString();
                    if (p.ValueKind == JsonValueKind.String) return p.GetString();
                }
            }
            return null;
        }

        static string? TryNestedString(JsonElement el, string objKey, string innerKey)
        {
            if (el.TryGetProperty(objKey, out var obj) && obj.ValueKind == JsonValueKind.Object)
            {
                if (obj.TryGetProperty(innerKey, out var p) && p.ValueKind == JsonValueKind.String)
                    return p.GetString();
            }
            return null;
        }
    }

    private static string DeriveDeviceId(string hostname)
    {
        if (RuntimeInformation.IsOSPlatform(OSPlatform.Windows))
        {
            try
            {
                using var key = Registry.LocalMachine.OpenSubKey(@"SOFTWARE\Microsoft\Cryptography");
                var mg = key?.GetValue("MachineGuid") as string;
                if (!string.IsNullOrWhiteSpace(mg)) return $"win-{mg}";
            }
            catch { /* ignore */ }
        }
        return hostname;
    }
}

===== END FILE remoteiq-minimal-e2e\agent-windows\RemoteIQ.Agent\Services\EnrollmentClient.cs =====

===== FILE: remoteiq-minimal-e2e\agent-windows\RemoteIQ.Agent\Services\WebSocketClient.cs (392 lines) =====
// remoteiq-minimal-e2e/agent-windows/RemoteIQ.Agent/Services/WebSocketClient.cs
using System.Diagnostics;
using System.Net.WebSockets;
using System.Runtime.InteropServices;
using System.Text;
using System.Text.Json;
using Microsoft.Extensions.Configuration;
using Microsoft.Extensions.Logging;
using RemoteIQ.Agent.Models;            // AgentConfig.From(...)
using RemoteIQ.Agent.Services.Security; // TokenStore

namespace RemoteIQ.Agent.Services;

/// <summary>
/// Optional WebSocket client. Connects to ws(s)://{ApiBaseHost}/ws,
/// sends an agent_hello right after connect, then listens for messages.
/// Supports "job_run_script" and replies with "job_result".
/// </summary>
public class WebSocketClient : IAsyncDisposable
{
    private readonly ILogger<WebSocketClient> _log;
    private readonly IConfiguration _configuration;
    private readonly TokenStore _tokenStore;

    private ClientWebSocket? _ws;
    private Uri? _endpoint;

    private const string AgentVersion = "1.0.0.0";

    public WebSocketClient(
        ILogger<WebSocketClient> log,
        IConfiguration configuration,
        TokenStore tokenStore)
    {
        _log = log;
        _configuration = configuration;
        _tokenStore = tokenStore;
    }

    public async Task StartAsync(CancellationToken ct)
    {
        var cfg = AgentConfig.From(_configuration);

        if (!Uri.TryCreate(cfg.ApiBase, UriKind.Absolute, out var apiBase))
        {
            _log.LogDebug("WebSocketClient: ApiBase not a valid URI; skipping WS.");
            return;
        }

        var wsScheme =
            apiBase.Scheme.Equals("https", StringComparison.OrdinalIgnoreCase) ? "wss" :
            apiBase.Scheme.Equals("http", StringComparison.OrdinalIgnoreCase) ? "ws" : null;

        if (wsScheme is null)
        {
            _log.LogDebug("WebSocketClient: ApiBase scheme not http/https; skipping WS.");
            return;
        }

        _endpoint = new UriBuilder(apiBase)
        {
            Scheme = wsScheme,
            Path = "/ws",
            Query = ""
        }.Uri;

        var tokenData = _tokenStore.Load();
        var token = tokenData?.AgentToken;
        if (string.IsNullOrWhiteSpace(token))
        {
            _log.LogDebug("WebSocketClient: no token yet; skipping WS connect.");
            return;
        }

        _ws = new ClientWebSocket();
        _ws.Options.SetRequestHeader("Authorization", $"Bearer {token}");

        try
        {
            _log.LogInformation("WebSocketClient: connecting to {Endpoint}", _endpoint);
            await _ws.ConnectAsync(_endpoint, ct);

            // Send hello immediately after connecting
            await SendHelloAsync(tokenData, token, ct);

            // Start the receive loop (fire-and-forget)
            _ = Task.Run(() => ReceiveLoopAsync(ct), ct);
        }
        catch (Exception ex)
        {
            _log.LogDebug(ex, "WebSocketClient: connect failed; continuing without WS.");
            await DisposeAsync();
        }
    }

    private async Task SendHelloAsync(TokenStore.TokenData? tokenData, string jwt, CancellationToken ct)
    {
        if (_ws is not { State: WebSocketState.Open }) return;

        var agentId = !string.IsNullOrWhiteSpace(tokenData?.AgentId)
            ? tokenData!.AgentId!
            : (TryGetClaimFromJwt(jwt, "agentId", "agent_id", "aid", "agent") ?? "unknown");

        var deviceId = !string.IsNullOrWhiteSpace(tokenData?.DeviceId)
            ? tokenData!.DeviceId!
            : (TryGetClaimFromJwt(jwt, "deviceId", "device_id", "did", "device") ?? "unknown");

        var hello = new
        {
            t = "agent_hello",
            agentId,
            deviceId,
            hostname = Environment.MachineName,
            os = "windows",
            arch = RuntimeInformation.OSArchitecture.ToString().ToLowerInvariant(),
            version = AgentVersion
        };

        await SendJsonAsync(hello, ct);
        _log.LogInformation("WebSocketClient: sent agent_hello (agentId={AgentId}, deviceId={DeviceId})", agentId, deviceId);
    }

    private static string? TryGetClaimFromJwt(string jwt, params string[] keys)
    {
        try
        {
            var parts = jwt.Split('.');
            if (parts.Length < 2) return null;

            static string Pad(string s) => s + new string('=', (4 - s.Length % 4) % 4);
            var payloadJson = Encoding.UTF8.GetString(
                Convert.FromBase64String(Pad(parts[1].Replace('-', '+').Replace('_', '/')))
            );

            using var doc = JsonDocument.Parse(payloadJson);
            var root = doc.RootElement;

            foreach (var key in keys)
            {
                if (root.TryGetProperty(key, out var el))
                {
                    return el.ValueKind switch
                    {
                        JsonValueKind.String => el.GetString(),
                        JsonValueKind.Number => el.TryGetInt64(out var n) ? n.ToString() : el.ToString(),
                        _ => el.ToString()
                    };
                }
            }

            if (root.TryGetProperty("claims", out var claims) && claims.ValueKind == JsonValueKind.Object)
            {
                foreach (var key in keys)
                {
                    if (claims.TryGetProperty(key, out var el2))
                    {
                        return el2.ValueKind == JsonValueKind.String ? el2.GetString() : el2.ToString();
                    }
                }
            }
        }
        catch { }
        return null;
    }

    private async Task ReceiveLoopAsync(CancellationToken ct)
    {
        if (_ws is null) return;

        var buffer = new byte[256 * 1024];
        var sb = new StringBuilder();

        while (!ct.IsCancellationRequested && _ws.State == WebSocketState.Open)
        {
            try
            {
                sb.Clear();
                WebSocketReceiveResult? result;
                do
                {
                    result = await _ws.ReceiveAsync(new ArraySegment<byte>(buffer), ct);
                    if (result.MessageType == WebSocketMessageType.Close)
                    {
                        _log.LogInformation("WebSocketClient: server closed connection.");
                        await DisposeAsync();
                        return;
                    }
                    sb.Append(Encoding.UTF8.GetString(buffer, 0, result.Count));
                } while (!result.EndOfMessage);

                var text = sb.ToString();
                if (string.IsNullOrWhiteSpace(text)) continue;

                HandleInbound(text, ct);
            }
            catch (OperationCanceledException) { }
            catch (Exception ex)
            {
                _log.LogDebug(ex, "WebSocketClient: receive error; closing.");
                break;
            }
        }

        await DisposeAsync();
    }

    private void HandleInbound(string json, CancellationToken ct)
    {
        try
        {
            using var doc = JsonDocument.Parse(json);
            var root = doc.RootElement;
            var t = root.TryGetProperty("t", out var tEl) && tEl.ValueKind == JsonValueKind.String ? tEl.GetString() : null;
            if (string.IsNullOrEmpty(t)) return;

            if (t == "job_run_script")
            {
                // Expected payload:
                // { t, jobId, language: "powershell" | "bash", scriptText, args?, env?, timeoutSec? }
                var jobId = root.GetProperty("jobId").GetString() ?? "";
                var language = root.GetProperty("language").GetString() ?? "powershell";
                var scriptText = root.GetProperty("scriptText").GetString() ?? "";
                var args = root.TryGetProperty("args", out var aEl) && aEl.ValueKind == JsonValueKind.Array
                    ? aEl.EnumerateArray().Select(x => x.GetString() ?? "").ToArray()
                    : Array.Empty<string>();
                var env = root.TryGetProperty("env", out var eEl) && eEl.ValueKind == JsonValueKind.Object
                    ? eEl.EnumerateObject().ToDictionary(p => p.Name, p => p.Value.GetString() ?? "")
                    : new Dictionary<string, string>();
                var timeoutSec = root.TryGetProperty("timeoutSec", out var toEl) && toEl.TryGetInt32(out var to)
                    ? to
                    : 120;

                _ = Task.Run(async () =>
                {
                    var sw = Stopwatch.StartNew();
                    int exitCode;
                    string stdout, stderr;
                    try
                    {
                        if (RuntimeInformation.IsOSPlatform(OSPlatform.Windows) && language.Equals("powershell", StringComparison.OrdinalIgnoreCase))
                        {
                            (exitCode, stdout, stderr) = await RunPowerShellAsync(scriptText, args, env, TimeSpan.FromSeconds(timeoutSec), ct);
                        }
                        else
                        {
                            (exitCode, stdout, stderr) = await RunShellAsync(scriptText, args, env, TimeSpan.FromSeconds(timeoutSec), ct);
                        }
                    }
                    catch (Exception ex)
                    {
                        exitCode = -1;
                        stdout = "";
                        stderr = $"Agent exception: {ex.Message}";
                    }
                    sw.Stop();

                    var result = new
                    {
                        t = "job_result",
                        jobId,
                        exitCode,
                        stdout,
                        stderr,
                        durationMs = (long)sw.ElapsedMilliseconds,
                        status = exitCode == 0 ? "succeeded" : "failed"
                    };
                    await SendJsonAsync(result, CancellationToken.None);
                }, ct);
            }
        }
        catch (Exception ex)
        {
            _log.LogDebug(ex, "WebSocketClient: failed to handle inbound message");
        }
    }

    private async Task SendJsonAsync(object payload, CancellationToken ct)
    {
        if (_ws is not { State: WebSocketState.Open }) return;
        var json = JsonSerializer.Serialize(payload);
        var bytes = Encoding.UTF8.GetBytes(json);
        await _ws.SendAsync(new ArraySegment<byte>(bytes), WebSocketMessageType.Text, true, ct);
    }

    private static async Task<(int exitCode, string stdout, string stderr)> RunPowerShellAsync(
        string scriptText,
        string[] args,
        Dictionary<string, string> env,
        TimeSpan timeout,
        CancellationToken ct)
    {
        // Use -NoProfile -NonInteractive for reliability; pass the script via -Command
        var psi = new ProcessStartInfo
        {
            FileName = "powershell.exe",
            Arguments = "-NoProfile -NonInteractive -ExecutionPolicy Bypass -Command -",
            RedirectStandardInput = true,
            RedirectStandardOutput = true,
            RedirectStandardError = true,
            UseShellExecute = false,
            CreateNoWindow = true,
        };

        foreach (var kv in env) psi.Environment[kv.Key] = kv.Value;

        using var proc = new Process { StartInfo = psi };
        proc.Start();

        await proc.StandardInput.WriteAsync(scriptText);
        await proc.StandardInput.FlushAsync();
        proc.StandardInput.Close();

        var stdoutTask = proc.StandardOutput.ReadToEndAsync();
        var stderrTask = proc.StandardError.ReadToEndAsync();

        using var cts = CancellationTokenSource.CreateLinkedTokenSource(ct);
        cts.CancelAfter(timeout);

        var exited = await Task.Run(() => proc.WaitForExit((int)timeout.TotalMilliseconds), cts.Token);
        if (!exited)
        {
            try { proc.Kill(true); } catch { }
            return (124, "", "Timeout");
        }

        var stdout = await stdoutTask;
        var stderr = await stderrTask;
        return (proc.ExitCode, stdout, stderr);
    }

    private static async Task<(int exitCode, string stdout, string stderr)> RunShellAsync(
        string scriptText,
        string[] args,
        Dictionary<string, string> env,
        TimeSpan timeout,
        CancellationToken ct)
    {
        // Generic /bin/bash -c 'script'
        var psi = new ProcessStartInfo
        {
            FileName = "/bin/bash",
            Arguments = "-c \"$@\" bash _ " + EscapeForBash(scriptText),
            RedirectStandardOutput = true,
            RedirectStandardError = true,
            UseShellExecute = false,
            CreateNoWindow = true,
        };

        foreach (var kv in env) psi.Environment[kv.Key] = kv.Value;

        using var proc = new Process { StartInfo = psi };
        proc.Start();

        var stdoutTask = proc.StandardOutput.ReadToEndAsync();
        var stderrTask = proc.StandardError.ReadToEndAsync();

        using var cts = CancellationTokenSource.CreateLinkedTokenSource(ct);
        cts.CancelAfter(timeout);

        var exited = await Task.Run(() => proc.WaitForExit((int)timeout.TotalMilliseconds), cts.Token);
        if (!exited)
        {
            try { proc.Kill(true); } catch { }
            return (124, "", "Timeout");
        }

        var stdout = await stdoutTask;
        var stderr = await stderrTask;
        return (proc.ExitCode, stdout, stderr);
    }

    private static string EscapeForBash(string s)
        => s.Replace("\\", "\\\\").Replace("\"", "\\\"").Replace("$", "\\$").Replace("`", "\\`");

    public async ValueTask DisposeAsync()
    {
        try
        {
            if (_ws is { State: WebSocketState.Open })
            {
                await _ws.CloseAsync(WebSocketCloseStatus.NormalClosure, "bye", CancellationToken.None);
            }
        }
        catch { }
        finally
        {
            _ws?.Dispose();
            _ws = null;
        }
    }
}

===== END FILE remoteiq-minimal-e2e\agent-windows\RemoteIQ.Agent\Services\WebSocketClient.cs =====

===== FILE: remoteiq-minimal-e2e\agent-windows\RemoteIQ.Agent\Models\Contracts.cs (116 lines) =====
// remoteiq-minimal-e2e/agent-windows/RemoteIQ.Agent/Models/Contracts.cs
using System;
using System.Collections.Generic;

namespace RemoteIQ.Agent.Models
{
    // ----- Enrollment -----
    // Backend expects: { enrollmentSecret, deviceId, hostname, os, arch, version }
    public record EnrollRequest(
        string EnrollmentSecret,
        string DeviceId,
        string Hostname,
        string Os,
        string Arch,
        string Version
    );

    public record EnrollResponse(
        string AgentId,
        string AgentToken,
        DateTime? RotateAfter
    );

    // ----- Ping (facts) -----
    // Sent by agent to /api/agent/ping (auth via Agent token)
    public record PingRequest(
        string? Os,
        string? Arch,
        string? Version,
        string? PrimaryIp,
        string? User
    );

    // ====== Legacy / future types (kept for later features) ======

    // OS/Agent info shapes you might reuse later for richer inventory
    public record OsInfo(string Family, string Edition, string Version, string Build, string Arch);
    public record AgentInfo(string Version, string Platform);

    // Optional: earlier heartbeat/inventory/metrics/logs contracts.
    // Safe to keep; they’re not used by the current flow.
    public record HeartbeatRequest(
        string AgentId,
        long UptimeSec,
        List<string> IpAddrs,
        string? LastInventoryHash,
        string AgentVersion
    );

    public record InventoryRequest(
        string AgentId,
        Hardware Hardware,
        OsInfo Os,
        Network Network,
        List<SoftwareItem> Software,
        List<ServiceItem> Services,
        List<ProcessItem> Processes
    );

    public record MetricsRequest(
        string AgentId,
        DateTime SampleTs,
        double CpuPct,
        double MemPct,
        Dictionary<string, double> DiskPct,
        List<TopProcess> TopProcesses
    );

    public record LogsRequest(
        string AgentId,
        string Source,
        string Level,
        List<LogEvent> Events
    );

    public record JobFetchResponse(
        string JobId,
        string Type,
        int TimeoutSec,
        string Command
    );

    public record JobResultRequest(
        string Status,
        int ExitCode,
        string Stdout,
        string Stderr
    );

    // ----- Inventory subtypes -----
    public record Hardware(
        Cpu Cpu,
        long RamBytes,
        List<Disk> Disks,
        List<Gpu> Gpu,
        Motherboard Motherboard,
        Bios Bios
    );
    public record Cpu(string Model, int Cores, int LogicalCpus);
    public record Disk(string Name, long SizeBytes, string Type);
    public record Gpu(string Name, string? DriverVersion);
    public record Motherboard(string Manufacturer, string Product);
    public record Bios(string Vendor, string Version, string? Date);

    public record Network(List<NetIf> Interfaces);
    public record NetIf(string Name, string Mac, List<string> Ipv4, List<string> Ipv6, string? Gateway, List<string> Dns);

    public record SoftwareItem(string DisplayName, string? Version, string? Publisher, string? InstallDate);
    public record ServiceItem(string Name, string DisplayName, string Status, string StartType);
    public record ProcessItem(int Pid, string Name, double CpuPct, long MemBytes);

    // ----- Metrics / Logs -----
    public record TopProcess(int Pid, string Name, double CpuPct, long MemBytes);
    public record LogEvent(int EventId, string Provider, DateTime Time, string Message);
}

===== END FILE remoteiq-minimal-e2e\agent-windows\RemoteIQ.Agent\Models\Contracts.cs =====

===== FILE: remoteiq-minimal-e2e\backend\src\checks\checks.controller.ts (150 lines) =====
//remoteiq-minimal-e2e\backend\src\checks\checks.controller.ts

import {
    Body,
    Controller,
    Delete,
    Get,
    HttpCode,
    HttpStatus,
    Param,
    ParseUUIDPipe,
    Post,
    Put,
    Query,
} from '@nestjs/common';
import { IsBoolean, IsEnum, IsInt, IsOptional, IsString, IsUUID, Max, Min, ValidateIf } from 'class-validator';
import { ChecksService, CheckScope, CheckType } from './checks.service';

/* ========================= DTOs for /api/checks ========================== */

class ListChecksQuery {
    @IsOptional() @IsEnum(CheckScope) scope?: CheckScope;
    @IsOptional() @IsEnum(CheckType) type?: CheckType;
    @IsOptional() @IsBoolean() enabled?: boolean;
    @IsOptional() @IsUUID() clientId?: string;
    @IsOptional() @IsUUID() siteId?: string;
    @IsOptional() @IsUUID() deviceId?: string;
    @IsOptional() @IsInt() @Min(1) @Max(200) limit?: number;
    @IsOptional() @IsString() cursor?: string;
}

class CreateCheckDto {
    @IsEnum(CheckScope) scope!: CheckScope;
    @ValidateIf((o) => o.scope !== CheckScope.GLOBAL) @IsUUID() @IsOptional() scopeId?: string;

    @IsEnum(CheckType) type!: CheckType;

    @IsString() name!: string;
    @IsString() @IsOptional() description?: string;

    @IsOptional() config?: unknown;     // per-type JSON schema validated in service
    @IsOptional() threshold?: unknown;  // per-type JSON schema validated in service

    @IsString() severityDefault!: 'WARN' | 'CRIT';

    @IsInt() @Min(15) @Max(86400) intervalSec!: number;
    @IsInt() @Min(1) @Max(600) timeoutSec!: number;

    @IsBoolean() enabled!: boolean;
}

class UpdateCheckDto {
    @IsOptional() @IsEnum(CheckScope) scope?: CheckScope;
    @ValidateIf((o) => o.scope && o.scope !== CheckScope.GLOBAL) @IsUUID() @IsOptional() scopeId?: string;

    @IsOptional() @IsEnum(CheckType) type?: CheckType;
    @IsOptional() @IsString() name?: string;
    @IsOptional() @IsString() description?: string;
    @IsOptional() config?: unknown;
    @IsOptional() threshold?: unknown;
    @IsOptional() @IsString() severityDefault?: 'WARN' | 'CRIT';
    @IsOptional() @IsInt() @Min(15) @Max(86400) intervalSec?: number;
    @IsOptional() @IsInt() @Min(1) @Max(600) timeoutSec?: number;
    @IsOptional() @IsBoolean() enabled?: boolean;
}

class RunOnDemandDto {
    @IsOptional() deviceIds?: string[] | null;
}

/* ===================== Existing /api/checks controller ==================== */

@Controller('api/checks')
export class ChecksController {
    constructor(private readonly checks: ChecksService) { }

    // TODO: add @UseGuards(AuthGuard) once your authZ guard is ready.

    @Get()
    async list(@Query() query: ListChecksQuery) {
        return this.checks.list(query);
    }

    @Post()
    async create(@Body() dto: CreateCheckDto) {
        // NOTE: Service will perform per-type schema validation server-side.
        return this.checks.create({
            ...dto,
            createdBy: 'system', // TODO: replace with req.user.id
            updatedBy: null,
            createdAt: new Date().toISOString(),
            updatedAt: new Date().toISOString(),
            id: '00000000-0000-0000-0000-000000000000', // placeholder, service should generate
        } as any);
    }

    @Put(':id')
    async update(@Param('id', new ParseUUIDPipe()) id: string, @Body() dto: UpdateCheckDto) {
        return this.checks.update(id, dto as any);
    }

    @Delete(':id')
    @HttpCode(HttpStatus.NO_CONTENT)
    async remove(@Param('id', new ParseUUIDPipe()) id: string) {
        await this.checks.remove(id);
        return;
    }

    @Post(':id/assignments/rebuild')
    async rebuild(@Param('id', new ParseUUIDPipe()) id: string) {
        return this.checks.rebuildAssignments(id);
    }

    @Post(':id/run')
    async runOnDemand(@Param('id', new ParseUUIDPipe()) id: string, @Body() dto: RunOnDemandDto) {
        return this.checks.runOnDemand(id, dto);
    }
}

/* ================= New device-scoped /api/devices/:id/checks route ========= */

function clamp(n: any, min: number, max: number, def: number): number {
    const x = Number(n);
    if (!Number.isFinite(x)) return def;
    return Math.max(min, Math.min(max, Math.trunc(x)));
}

@Controller('api/devices')
export class DeviceChecksController {
    constructor(private readonly checks: ChecksService) { }

    /**
     * Device-scoped checks for the UI:
     * GET /api/devices/:deviceId/checks?limit=100
     *
     * Returns:
     *  { items: Array<{ id, name, status, lastRun, output, ...optional fields }> }
     *  Optional advanced fields (type, severity, metrics, thresholds, tags, maintenance, dedupeKey)
     *  will be included by the service when available.
     */
    @Get(':deviceId/checks')
    async deviceChecks(
        @Param('deviceId', new ParseUUIDPipe()) deviceId: string,
        @Query('limit') limit?: string,
    ) {
        const lim = clamp(limit, 1, 200, 100);
        return this.checks.listByDevice(deviceId, lim);
    }
}

===== END FILE remoteiq-minimal-e2e\backend\src\checks\checks.controller.ts =====

===== FILE: remoteiq-minimal-e2e\backend\src\checks\checks.module.ts (20 lines) =====
// backend/src/checks/checks.module.ts
import { Module, forwardRef } from '@nestjs/common';
import { ChecksService } from './checks.service';
import { ChecksController, DeviceChecksController } from './checks.controller';
import { StorageModule } from '../storage/storage.module';
import { CommonModule } from '../common/common.module'; // <-- add
import { WsModule } from '../ws/ws.module';             // (optional, only if you also use DashboardGateway)

@Module({
    imports: [
        StorageModule,
        CommonModule,               // <-- needed for UiSocketRegistry
        forwardRef(() => WsModule), // ok to keep if you’re also using DashboardGateway elsewhere
    ],
    controllers: [ChecksController, DeviceChecksController],
    providers: [ChecksService],
    exports: [ChecksService],
})
export class ChecksModule { }

===== END FILE remoteiq-minimal-e2e\backend\src\checks\checks.module.ts =====

===== FILE: remoteiq-minimal-e2e\backend\src\checks\checks.service.ts (450 lines) =====
// backend/src/checks/checks.service.ts
import { Injectable, Logger, NotImplementedException } from '@nestjs/common';
import { PgPoolService } from '../storage/pg-pool.service';
import { UiSocketRegistry } from '../common/ui-socket-registry.service';

/* ========================= Types / helpers ========================= */

export enum CheckScope {
    DEVICE = 'DEVICE',
    SITE = 'SITE',
    CLIENT = 'CLIENT',
    GLOBAL = 'GLOBAL',
}

export enum CheckType {
    PING = 'PING',
    CPU = 'CPU',
    MEMORY = 'MEMORY',
    DISK = 'DISK',
    SERVICE = 'SERVICE',
    PROCESS = 'PROCESS',
    PORT = 'PORT',
    WINEVENT = 'WINEVENT',
    SOFTWARE = 'SOFTWARE',
    SECURITY = 'SECURITY',
    SCRIPT = 'SCRIPT',
    PATCH = 'PATCH',
    CERT = 'CERT',
    SMART = 'SMART',
    RDP = 'RDP',
    SMB = 'SMB',
    FIREWALL = 'FIREWALL',
}

export type DeviceCheckDTO = {
    id: string; // assignment id (device-scoped)
    name: string;
    status: 'Passing' | 'Warning' | 'Failing';
    lastRun: string | null;
    output: string;
};

type NormalizedRunStatus = 'OK' | 'WARN' | 'CRIT' | 'TIMEOUT' | 'UNKNOWN';

function normalizeStatus(s?: string | null): NormalizedRunStatus {
    const t = String(s || '').trim().toUpperCase();
    if (t === 'OK' || t === 'PASS' || t === 'PASSING') return 'OK';
    if (t === 'WARN' || t === 'WARNING') return 'WARN';
    if (t === 'TIMEOUT') return 'TIMEOUT';
    if (t === 'CRIT' || t === 'ERROR' || t === 'FAIL' || t === 'FAILING') return 'CRIT';
    return 'UNKNOWN';
}

function toUiStatus(s?: string | null): DeviceCheckDTO['status'] {
    switch (normalizeStatus(s)) {
        case 'OK': return 'Passing';
        case 'WARN': return 'Warning';
        default: return 'Failing';
    }
}

/* =============================== Service =============================== */

@Injectable()
export class ChecksService {
    private readonly logger = new Logger(ChecksService.name);

    // per-device debounce to avoid floods; value is NodeJS.Timeout in Node
    private readonly deviceDebounce = new Map<string, ReturnType<typeof setTimeout>>();

    constructor(
        private readonly pg: PgPoolService,
        private readonly uiSockets: UiSocketRegistry,
    ) { }

    /* ================= Schema guard (idempotent) ================= */

    /** Ensure minimal schema for checks exists (TEXT device_id). Safe to call often. */
    private async ensureSchema() {
        await this.pg.query(`
      CREATE EXTENSION IF NOT EXISTS pgcrypto;

      CREATE TABLE IF NOT EXISTS public.check_assignments (
        id          uuid PRIMARY KEY DEFAULT gen_random_uuid(),
        device_id   text NOT NULL,
        dedupe_key  text,
        check_type  text,
        check_name  text,
        created_at  timestamptz DEFAULT now(),
        updated_at  timestamptz DEFAULT now()
      );

      CREATE TABLE IF NOT EXISTS public.check_runs (
        id            uuid PRIMARY KEY DEFAULT gen_random_uuid(),
        assignment_id uuid,
        device_id     text NOT NULL,
        status        text NOT NULL,
        severity      text,
        metrics       jsonb,
        output        text,
        started_at    timestamptz,
        finished_at   timestamptz,
        created_at    timestamptz DEFAULT now()
      );

      -- Unique dedupe per device: explicit key OR type|name fallback
      CREATE UNIQUE INDEX IF NOT EXISTS check_assignments_uk
        ON public.check_assignments (
          device_id,
          COALESCE(
            NULLIF(dedupe_key, ''),
            LOWER(COALESCE(check_type,'')) || '|' || LOWER(COALESCE(check_name,''))
          )
        );

      CREATE INDEX IF NOT EXISTS check_assignments_device_id_idx ON public.check_assignments (device_id);
      CREATE INDEX IF NOT EXISTS check_runs_assignment_id_idx    ON public.check_runs (assignment_id);
      CREATE INDEX IF NOT EXISTS check_runs_device_id_idx        ON public.check_runs (device_id);
      CREATE INDEX IF NOT EXISTS check_runs_created_at_idx       ON public.check_runs (created_at);
    `);
    }

    /* ====================== Public read for UI ====================== */

    async listByDevice(deviceId: string, limit = 100): Promise<{ items: DeviceCheckDTO[] }> {
        if (!Number.isFinite(limit) || limit < 1) limit = 1;
        if (limit > 200) limit = 200;

        await this.ensureSchema();

        // Latest run per assignment + assignment name (no dependency on separate "checks" table)
        const sql = `
      WITH latest_run AS (
        SELECT
          cr.assignment_id,
          cr.status,
          cr.output,
          cr.finished_at AS last_run,
          ROW_NUMBER() OVER (PARTITION BY cr.assignment_id ORDER BY cr.finished_at DESC NULLS LAST) AS rn
        FROM public.check_runs cr
        WHERE cr.device_id = $1
      )
      SELECT
        a.id                      AS assignment_id,
        COALESCE(NULLIF(a.check_name,''), NULLIF(a.check_type,''), 'Check') AS check_name,
        lr.status                 AS run_status,
        lr.output                 AS run_output,
        lr.last_run               AS last_run
      FROM public.check_assignments a
      LEFT JOIN latest_run lr ON lr.assignment_id = a.id AND lr.rn = 1
      WHERE a.device_id = $1
      ORDER BY lr.last_run DESC NULLS LAST, check_name ASC
      LIMIT $2
    `;

        try {
            const { rows } = await this.pg.query<{
                assignment_id: string;
                check_name: string | null;
                run_status: string | null;
                run_output: string | null;
                last_run: Date | string | null;
            }>(sql, [deviceId, limit]);

            const items: DeviceCheckDTO[] = (rows || []).map((r) => ({
                id: r.assignment_id,
                name: r.check_name ?? 'Check',
                status: toUiStatus(r.run_status),
                lastRun: r.last_run ? new Date(r.last_run as any).toISOString() : null,
                output:
                    (r.run_output ?? '').length > 8192
                        ? (r.run_output ?? '').slice(0, 8192) + '…'
                        : r.run_output ?? '',
            }));

            return { items };
        } catch (err: any) {
            const msg = String(err?.message || '').toLowerCase();
            const code = String((err && (err.code || err?.original?.code)) || '');
            if (code === '42P01' || code === '42703' || (msg.includes('relation') && msg.includes('does not exist'))) {
                this.logger.warn('ChecksService.listByDevice: schema not ready; returning empty items.');
                return { items: [] };
            }
            this.logger.error('ChecksService.listByDevice failed', err?.stack || err);
            return { items: [] };
        }
    }

    /* ======================= Agent ingestion ====================== */

    /**
     * Ingest runs from an agent (TEXT deviceId).
     * - Upsert assignment per device using dedupeKey or (type|name) tuple
     * - Insert runs
     * Returns counts for observability.
     */
    async ingestAgentRuns(input: {
        agentId: string;
        deviceId: string; // TEXT (e.g., "win-...")
        runs: Array<{
            assignmentId?: string;
            dedupeKey?: string;
            checkType?: string;
            checkName?: string;
            status: string;
            severity?: 'WARN' | 'CRIT';
            metrics?: Record<string, any>;
            output?: string;
            startedAt?: string;
            finishedAt?: string;
        }>;
    }): Promise<{ inserted: number; assignmentsCreated: number }> {
        if (!input?.runs?.length) return { inserted: 0, assignmentsCreated: 0 };

        await this.ensureSchema();

        const MAX_OUTPUT = 64 * 1024; // 64 KiB

        // ---------- 1) Prepare src rows with a stable ordinal ----------
        const srcValues: string[] = [];
        const srcParams: any[] = [];
        let p = 1;

        for (let i = 0; i < input.runs.length; i++) {
            const r = input.runs[i];
            const dk = r.dedupeKey ?? null;
            const ct = (r.checkType || '').trim().toUpperCase() || null;
            const cn = (r.checkName || ct || 'Agent Check').trim().substring(0, 200) || 'Agent Check';

            // (ord, device_id, dedupe_key, check_type, check_name)
            srcValues.push(`($${p++}::int, $${p++}::text, $${p++}::text, $${p++}::text, $${p++}::text)`);
            srcParams.push(i + 1, input.deviceId, dk, ct, cn);
        }

        // ---------- 2) Insert missing assignments; count inserted via RETURNING ----------
        const insertSql = `
      WITH src(ord, device_id, dedupe_key, check_type, check_name) AS (
        VALUES ${srcValues.join(',')}
      )
      INSERT INTO public.check_assignments (device_id, dedupe_key, check_type, check_name)
      SELECT s.device_id, s.dedupe_key, s.check_type, s.check_name
      FROM src s
      ON CONFLICT (device_id,
        COALESCE(
          NULLIF(dedupe_key,''),
          LOWER(COALESCE(check_type,'')) || '|' || LOWER(COALESCE(check_name,''))
        ))
      DO NOTHING
      RETURNING id;
    `;
        const insertRes = await this.pg.query<{ id: string }>(insertSql, srcParams);
        const assignmentsCreated = (insertRes.rows || []).length;

        // ---------- 3) Resolve assignment ids for each src row in order ----------
        const mapSql = `
      WITH src(ord, device_id, dedupe_key, check_type, check_name) AS (
        VALUES ${srcValues.join(',')}
      )
      SELECT
        s.ord,
        ca.id::text AS assignment_id
      FROM src s
      JOIN public.check_assignments ca
        ON ca.device_id = s.device_id
       AND COALESCE(NULLIF(ca.dedupe_key,''),
            LOWER(COALESCE(ca.check_type,'')) || '|' || LOWER(COALESCE(ca.check_name,'')))
        = COALESCE(NULLIF(s.dedupe_key,''),
            LOWER(COALESCE(s.check_type,'')) || '|' || LOWER(COALESCE(s.check_name,'')))
      ORDER BY s.ord ASC;
    `;
        const mapRes = await this.pg.query<{ ord: number; assignment_id: string }>(mapSql, srcParams);
        const assignmentByOrd = new Map<number, string>();
        for (const r of mapRes.rows) assignmentByOrd.set(r.ord, r.assignment_id);

        // ---------- 4) Build runs aligned to the original order ----------
        const runValues: string[] = [];
        const runParams: any[] = [];
        p = 1;

        for (let i = 0; i < input.runs.length; i++) {
            const r = input.runs[i];
            const assignmentIdFromMap = assignmentByOrd.get(i + 1);

            const assignmentId =
                (r.assignmentId && /^[0-9a-fA-F-]{8}-[0-9a-fA-F-]{4}-[1-5][0-9a-fA-F-]{3}-[89abAB][0-9a-fA-F-]{3}-[0-9a-fA-F-]{12}$/.test(r.assignmentId))
                    ? r.assignmentId
                    : assignmentIdFromMap;

            if (!assignmentId) continue; // should not happen, but be defensive

            const status = normalizeStatus(r.status);
            const severity = r.severity === 'CRIT' ? 'CRIT' : r.severity === 'WARN' ? 'WARN' : null;
            const output = (r.output ?? '').slice(0, MAX_OUTPUT);
            const startedAt = r.startedAt ? new Date(r.startedAt) : new Date();
            const finishedAt = r.finishedAt ? new Date(r.finishedAt) : new Date();

            runValues.push(`(
        $${p++}::uuid,        -- assignment_id
        $${p++}::text,        -- device_id
        $${p++}::text,        -- status
        $${p++}::text,        -- severity
        $${p++}::jsonb,       -- metrics
        $${p++}::text,        -- output
        $${p++}::timestamptz, -- started_at
        $${p++}::timestamptz  -- finished_at
      )`);

            runParams.push(
                assignmentId,
                input.deviceId,
                status,
                severity,
                r.metrics ? JSON.stringify(r.metrics) : null,
                output,
                startedAt.toISOString(),
                finishedAt.toISOString(),
            );
        }

        let inserted = 0;
        if (runValues.length) {
            const insSql = `
        INSERT INTO public.check_runs
          (assignment_id, device_id, status, severity, metrics, output, started_at, finished_at)
        VALUES ${runValues.join(',')}
        RETURNING id;
      `;
            const ins = await this.pg.query<{ id: string }>(insSql, runParams);
            inserted = (ins.rows || []).length;
        }

        // Debounced UI broadcast per device
        if (inserted > 0) this.scheduleDeviceBroadcast(input.deviceId, inserted);

        this.logger.log(`ingested ${inserted} run(s) for device ${input.deviceId}; new assignments: ${assignmentsCreated}`);
        return { inserted, assignmentsCreated };
    }

    /** Debounce + emit device_checks_updated to subscribed UI sockets */
    private scheduleDeviceBroadcast(deviceId: string, changed: number) {
        const key = String(deviceId);
        const existing = this.deviceDebounce.get(key);
        if (existing) clearTimeout(existing as any);

        const handle = setTimeout(() => {
            try {
                const payload = {
                    t: 'device_checks_updated',
                    deviceId: key,
                    changed,
                    at: new Date().toISOString(),
                };
                const sent = this.uiSockets.broadcastToDevice(key, payload);
                this.logger.debug(`Broadcast device_checks_updated to ${sent} UI socket(s) for device ${key}`);
            } catch (e: any) {
                this.logger.warn(`Broadcast failed for device ${key}: ${e?.message ?? e}`);
            } finally {
                this.deviceDebounce.delete(key);
            }
        }, 750);

        this.deviceDebounce.set(key, handle);
    }

    /* ============== Server-driven assignments for agent (optional) ============ */

    async getAssignmentsForDevice(deviceId: string): Promise<{
        items: Array<{
            assignmentId: string;
            type: string | null;
            name: string | null;
            intervalSec: number; // static defaults for now
            timeoutSec: number;  // static defaults for now
            enabled: boolean;
            dedupeKey?: string | null;
            config?: any;
            thresholds?: any;
        }>;
    }> {
        await this.ensureSchema();

        // We don’t maintain a separate checks catalog here; return lightweight rows
        const { rows } = await this.pg.query(
            `
      SELECT
        a.id::text            AS assignment_id,
        a.check_type          AS check_type,
        a.check_name          AS check_name,
        a.dedupe_key          AS dedupe_key,
        a.created_at,
        a.updated_at
      FROM public.check_assignments a
      WHERE a.device_id = $1
      ORDER BY a.created_at DESC
      `,
            [deviceId]
        );

        return {
            items: rows.map((r: any) => ({
                assignmentId: r.assignment_id,
                type: r.check_type ?? null,
                name: r.check_name ?? null,
                // simple defaults (agents can override via config if/when you add it)
                intervalSec: 60,
                timeoutSec: 10,
                enabled: true,
                dedupeKey: r.dedupe_key,
                config: null,
                thresholds: null,
            })),
        };
    }

    /* ======================== Placeholders (unchanged) ======================== */

    async list(_params: {
        scope?: CheckScope;
        type?: CheckType;
        enabled?: boolean;
        clientId?: string;
        siteId?: string;
        deviceId?: string;
        limit?: number;
        cursor?: string;
    }): Promise<{ items: any[]; nextCursor?: string | null }> {
        throw new NotImplementedException('ChecksService.list not implemented yet');
    }

    async create(_payload: any): Promise<any> {
        throw new NotImplementedException('ChecksService.create not implemented yet');
    }

    async update(_id: string, _payload: any): Promise<any> {
        throw new NotImplementedException('ChecksService.update not implemented yet');
    }

    async remove(_id: string): Promise<{ id: string; deleted: boolean }> {
        throw new NotImplementedException('ChecksService.remove not implemented yet');
    }

    async rebuildAssignments(_id: string): Promise<{ checkId: string; assignmentsRebuilt: number }> {
        throw new NotImplementedException('ChecksService.rebuildAssignments not implemented yet');
    }

    async runOnDemand(_id: string, _params?: { deviceIds?: string[] | null }): Promise<{ enqueued: number }> {
        throw new NotImplementedException('ChecksService.runOnDemand not implemented yet');
    }
}

===== END FILE remoteiq-minimal-e2e\backend\src\checks\checks.service.ts =====

===== FILE: remoteiq-minimal-e2e\backend\src\devices\devices.service.ts (276 lines) =====
// backend/src/devices/devices.service.ts
import { Injectable, NotFoundException } from "@nestjs/common";
import { PgPoolService } from "../storage/pg-pool.service";

export type Device = {
  id: string;
  hostname: string;
  os: string;
  arch?: string | null;
  lastSeen: string | null;
  status: "online" | "offline";
  client?: string | null;
  site?: string | null;
  user?: string | null;
  version?: string | null;
  primaryIp?: string | null;
  agentUuid?: string | null; // <-- NEW
};

function decodeCursor(cur?: string | null) {
  if (!cur) return 0;
  try {
    const n = parseInt(Buffer.from(cur, "base64url").toString("utf8"), 10);
    return Number.isFinite(n) && n >= 0 ? n : 0;
  } catch {
    return 0;
  }
}
function encodeCursor(n: number) {
  return Buffer.from(String(n), "utf8").toString("base64url");
}

@Injectable()
export class DevicesService {
  constructor(private readonly pg: PgPoolService) { }

  async list(opts: {
    pageSize: number;
    cursor?: string | null;
    q?: string;
    status?: "online" | "offline";
    os?: string[];
  }): Promise<{ items: Device[]; nextCursor: string | null }> {
    const { pageSize, cursor, q, status, os } = opts;
    const offset = decodeCursor(cursor);

    const where: string[] = [];
    const params: any[] = [];
    let p = 1;

    if (q && q.trim()) {
      where.push(`hostname ILIKE $${p++}`);
      params.push(`%${q.trim()}%`);
    }
    if (status) {
      where.push(`status = $${p++}`);
      params.push(status);
    }
    if (os && os.length) {
      where.push(`lower(os) = ANY($${p++})`);
      params.push(os.map((o) => String(o).toLowerCase()));
    }

    const limit = pageSize + 1;
    const whereSql = where.length ? `WHERE ${where.join(" AND ")}` : "";

    const sql = `
      WITH agent_rows AS (
        SELECT
          a.id::text                                   AS id,
          COALESCE(a.hostname, a.device_id, 'unknown') AS hostname,
          COALESCE(NULLIF(a.os, ''), 'unknown')        AS os,
          a.arch                                       AS arch,
          a.last_seen_at                               AS last_seen,
          CASE
            WHEN a.last_seen_at IS NOT NULL
             AND a.last_seen_at > NOW() - INTERVAL '5 minutes'
            THEN 'online' ELSE 'offline'
          END                                          AS status,
          a.client                                     AS client,
          a.site                                       AS site,
          NULLIF(a.logged_in_user, '')                 AS "user",
          NULLIF(a.version, '')                        AS version,
          NULLIF(a.primary_ip, '')                     AS primary_ip,
          a.agent_uuid::text                           AS agent_uuid   -- <-- NEW
        FROM public.agents a
      ),
      device_rows AS (
        SELECT
          d.id::text            AS id,
          d.hostname            AS hostname,
          d.os                  AS os,
          d.arch                AS arch,
          d.last_seen           AS last_seen,
          d.status              AS status,
          d.client              AS client,
          d.site                AS site,
          NULLIF(d."user", '')  AS "user",
          NULL::text            AS version,
          NULL::text            AS primary_ip,
          NULL::text            AS agent_uuid                          -- <-- NEW
        FROM devices d
        WHERE NOT EXISTS (
          SELECT 1 FROM public.agents a
          WHERE COALESCE(a.hostname, a.device_id, 'unknown') = d.hostname
        )
      ),
      all_devs AS (
        SELECT * FROM agent_rows
        UNION ALL
        SELECT * FROM device_rows
      )
      SELECT id, hostname, os, arch, last_seen, status, client, site, "user", version, primary_ip, agent_uuid
      FROM all_devs
      ${whereSql}
      ORDER BY hostname ASC
      LIMIT ${limit} OFFSET ${offset};
    `;

    const { rows } = await this.pg.query(sql, params);
    const hasNext = rows.length > pageSize;

    const items = rows.slice(0, pageSize).map((r: any) => ({
      id: r.id,
      hostname: r.hostname,
      os: r.os,
      arch: r.arch ?? null,
      lastSeen: r.last_seen ? new Date(r.last_seen).toISOString() : null,
      status: r.status as "online" | "offline",
      client: r.client ?? null,
      site: r.site ?? null,
      user: r.user ?? null,
      version: r.version ?? null,
      primaryIp: r.primary_ip ?? null,
      agentUuid: r.agent_uuid ?? null, // <-- NEW
    })) as Device[];

    return { items, nextCursor: hasNext ? encodeCursor(offset + pageSize) : null };
  }

  async getOne(id: string): Promise<Device | null> {
    const sql = `
      WITH rows AS (
        SELECT
          0                                                AS pref,
          a.id::text                                      AS id,
          COALESCE(a.hostname, a.device_id, 'unknown')    AS hostname,
          COALESCE(NULLIF(a.os, ''), 'unknown')           AS os,
          a.arch                                          AS arch,
          a.last_seen_at                                  AS last_seen,
          CASE
            WHEN a.last_seen_at IS NOT NULL
             AND a.last_seen_at > NOW() - INTERVAL '5 minutes'
            THEN 'online' ELSE 'offline'
          END                                             AS status,
          a.client                                        AS client,
          a.site                                          AS site,
          NULLIF(a.logged_in_user, '')                    AS "user",
          NULLIF(a.version, '')                           AS version,
          NULLIF(a.primary_ip, '')                        AS primary_ip,
          a.agent_uuid::text                              AS agent_uuid  -- <-- NEW
        FROM public.agents a
        WHERE a.id::text = $1

        UNION ALL

        SELECT
          1                        AS pref,
          d.id::text               AS id,
          d.hostname               AS hostname,
          d.os                     AS os,
          d.arch                   AS arch,
          d.last_seen              AS last_seen,
          d.status                 AS status,
          d.client                 AS client,
          d.site                   AS site,
          NULLIF(d."user", '')     AS "user",
          NULL::text               AS version,
          NULL::text               AS primary_ip,
          NULL::text               AS agent_uuid                         -- <-- NEW
        FROM devices d
        WHERE d.id::text = $1
      )
      SELECT id, hostname, os, arch, last_seen, status, client, site, "user", version, primary_ip, agent_uuid
      FROM rows
      ORDER BY pref ASC
      LIMIT 1;
    `;
    const { rows } = await this.pg.query(sql, [id]);
    const r = rows[0];
    if (!r) return null;

    return {
      id: r.id,
      hostname: r.hostname,
      os: r.os,
      arch: r.arch ?? null,
      lastSeen: r.last_seen ? new Date(r.last_seen).toISOString() : null,
      status: r.status as "online" | "offline",
      client: r.client ?? null,
      site: r.site ?? null,
      user: r.user ?? null,
      version: r.version ?? null,
      primaryIp: r.primary_ip ?? null,
      agentUuid: r.agent_uuid ?? null, // <-- NEW
    };
  }

  async listSoftware(
    id: string
  ): Promise<
    Array<{
      id: string;
      name: string;
      version: string;
      publisher?: string | null;
      installDate?: string | null;
    }>
  > {
    const { rows } = await this.pg.query(
      `
      SELECT
        s.id::text            AS id,
        s.name,
        s.version,
        s.publisher,
        s.install_date        AS install_date
      FROM public.agent_software s
      JOIN public.agents a ON a.id = s.agent_id
      WHERE a.id::text = $1
      ORDER BY lower(s.name) ASC, COALESCE(s.version,'') ASC
      `,
      [id]
    );

    return rows.map((r: any) => ({
      id: r.id,
      name: r.name,
      version: r.version ?? "",
      publisher: r.publisher ?? null,
      installDate: r.install_date ?? null,
    }));
  }

  // NEW: create uninstall job in a simple job queue
  async requestUninstall(
    id: string,
    body: { name: string; version?: string | null }
  ): Promise<string> {
    // ensure agent exists
    const { rows: arows } = await this.pg.query(
      `SELECT id FROM public.agents WHERE id::text = $1`,
      [id]
    );
    const agentId: number | undefined = arows[0]?.id;
    if (!agentId) throw new NotFoundException("Agent not found");

    const payload = {
      action: "uninstall_software",
      name: body.name,
      version: body.version ?? null,
    };

    const { rows } = await this.pg.query(
      `
      INSERT INTO public.agent_jobs (agent_id, kind, payload)
      VALUES ($1, $2, $3::jsonb)
      RETURNING id::text AS id
      `,
      [agentId, "uninstall_software", JSON.stringify(payload)]
    );

    return rows[0].id as string;
  }
}

===== END FILE remoteiq-minimal-e2e\backend\src\devices\devices.service.ts =====

===== FILE: remoteiq-minimal-e2e\backend\src\agents\agents.controller.ts (223 lines) =====
// src/agents/agents.controller.ts
import {
  Body, Controller, Get, Post, Query, Req,
  UseGuards, UsePipes, ValidationPipe, BadRequestException, ForbiddenException,
} from '@nestjs/common';
import { AuthService } from '../auth/auth.service';
import { EnrollAgentDto } from './dto/enroll-agent.dto';
import { AgentsService } from './agents.service';
import { AgentTokenGuard, getAgentFromRequest } from '../common/agent-token.util';
import { UpdateAgentFactsDto } from './dto/update-agent-facts.dto';
import { SubmitSoftwareDto } from './dto/submit-software.dto';
import { ChecksService } from '../checks/checks.service';
import {
  IsArray, IsDateString, IsObject, IsOptional, IsString,
  MaxLength, ValidateNested, ArrayMinSize,
} from 'class-validator';
import { Type } from 'class-transformer';

/* ----------------------------- DTOs for runs ----------------------------- */

export enum AgentRunStatus {
  OK = 'OK',
  PASS = 'PASS',
  PASSING = 'PASSING',
  WARN = 'WARN',
  WARNING = 'WARNING',
  CRIT = 'CRIT',
  ERROR = 'ERROR',
  FAIL = 'FAIL',
  FAILING = 'FAILING',
  TIMEOUT = 'TIMEOUT',
  UNKNOWN = 'UNKNOWN',
}

export class SubmitCheckRunItemDto {
  @IsOptional()
  @IsString()
  @MaxLength(36)
  assignmentId?: string; // uuid string (not strictly validated to allow empty envs)

  @IsOptional()
  @IsString()
  @MaxLength(256)
  dedupeKey?: string;

  @IsOptional()
  @IsString()
  @MaxLength(64)
  checkType?: string;

  @IsOptional()
  @IsString()
  @MaxLength(200)
  checkName?: string;

  @IsString()
  status!: string;

  @IsOptional()
  @IsString()
  @MaxLength(8)
  severity?: 'WARN' | 'CRIT';

  @IsOptional()
  @IsObject()
  metrics?: Record<string, any>;

  @IsOptional()
  @IsString()
  @MaxLength(200000)
  output?: string;

  @IsOptional()
  @IsDateString()
  startedAt?: string;

  @IsOptional()
  @IsDateString()
  finishedAt?: string;
}

export class SubmitCheckRunsDto {
  @IsOptional()
  @IsString() // <— accepts "win-..." style ids
  deviceId?: string;

  @IsArray()
  @ArrayMinSize(1)
  @ValidateNested({ each: true })
  @Type(() => SubmitCheckRunItemDto)
  runs!: SubmitCheckRunItemDto[];
}

/* ----------------------------- Rate limiter ------------------------------ */
const rlWindowMs = 10_000; // 10s
const rlMaxRequests = 20;  // 20 per window
const rlState = new Map<string, number[]>();

function checkRate(agentIdStr: string) {
  const now = Date.now();
  const arr = rlState.get(agentIdStr) ?? [];
  const fresh = arr.filter(ts => now - ts < rlWindowMs);
  fresh.push(now);
  rlState.set(agentIdStr, fresh);
  if (fresh.length > rlMaxRequests) {
    throw new ForbiddenException('Agent is sending check data too fast; back off and retry later.');
  }
}

@Controller('/api/agent')
@UsePipes(new ValidationPipe({ whitelist: true, transform: true, forbidNonWhitelisted: true }))
export class AgentsController {
  constructor(
    private readonly auth: AuthService,
    private readonly agents: AgentsService,
    private readonly checks: ChecksService,
  ) { }

  @Post('/enroll')
  async enroll(
    @Body() body: EnrollAgentDto
  ): Promise<{ agentId: string; agentUuid: string | null; deviceId: string; agentToken: string }> {
    const res: any = await this.auth.enrollAgent(body);

    const agentId = String(res?.agentId ?? res?.agent?.id ?? '');
    const deviceId = String(res?.deviceId ?? res?.device?.id ?? body?.deviceId ?? '');
    const agentToken = String(res?.agentToken ?? res?.token ?? res?.accessToken ?? '');

    if (!agentToken || !agentId) {
      throw new Error('Enrollment succeeded but missing token or agentId in response.');
    }

    let agentUuid: string | null = null;
    try {
      agentUuid = await this.agents.getAgentUuidById(Number(agentId));
    } catch {
      agentUuid = null;
    }

    return { agentId, agentUuid, deviceId, agentToken };
  }

  @Post('/ping')
  @UseGuards(AgentTokenGuard)
  async ping(@Req() req: any, @Body() body: UpdateAgentFactsDto) {
    const agent = getAgentFromRequest(req);
    await this.agents.updateFacts(Number((agent as any).id), body ?? {});
    return { ok: true };
  }

  @Post('/software')
  @UseGuards(AgentTokenGuard)
  async submitSoftware(@Req() req: any, @Body() body: SubmitSoftwareDto) {
    const agent = getAgentFromRequest(req);
    await this.agents.upsertSoftware(Number((agent as any).id), body?.items ?? []);
    return { ok: true, count: body?.items?.length ?? 0 };
  }

  // ===================== Check runs ingestion ======================
  @Post('/check-runs')
  @UseGuards(AgentTokenGuard)
  async submitCheckRuns(@Req() req: any, @Body() body: SubmitCheckRunsDto) {
    const agent = getAgentFromRequest(req);

    checkRate(String((agent as any).id));

    const tokenDeviceRaw = (agent as any)?.deviceId ?? (agent as any)?.device_id;
    const deviceIdFromToken: string | undefined =
      tokenDeviceRaw != null ? String(tokenDeviceRaw) : undefined;

    const deviceIdFromBody: string | undefined =
      body?.deviceId ? String(body.deviceId) : undefined;

    const deviceId = deviceIdFromBody ?? deviceIdFromToken;

    if (!deviceId) {
      throw new BadRequestException('deviceId is required (bind agent to device first, or include in body).');
    }
    if (deviceIdFromBody && deviceIdFromToken && deviceIdFromBody !== deviceIdFromToken) {
      throw new ForbiddenException('deviceId in body does not match the agent binding.');
    }
    if (!Array.isArray(body?.runs) || body.runs.length === 0) {
      throw new BadRequestException('runs is required and must be a non-empty array');
    }

    const result = await this.checks.ingestAgentRuns({
      agentId: String((agent as any).id),
      deviceId, // TEXT id
      runs: body.runs.map(r => ({
        assignmentId: r.assignmentId,
        dedupeKey: r.dedupeKey,
        checkType: r.checkType,
        checkName: r.checkName,
        status: r.status,
        severity: r.severity,
        metrics: r.metrics,
        output: r.output,
        startedAt: r.startedAt,
        finishedAt: r.finishedAt,
      })),
    });

    return { ok: true, inserted: result.inserted, assignmentsCreated: result.assignmentsCreated };
  }

  @Get('/assignments')
  @UseGuards(AgentTokenGuard)
  async getAssignments(@Req() req: any, @Query('deviceId') deviceId?: string) {
    const agent = getAgentFromRequest(req);
    const tokenDeviceRaw = (agent as any)?.deviceId ?? (agent as any)?.device_id;
    const boundDevice: string | undefined =
      tokenDeviceRaw != null ? String(tokenDeviceRaw) : undefined;

    const effective = deviceId ?? boundDevice;
    if (!effective) {
      throw new BadRequestException('deviceId is required (either query param or bound to agent).');
    }

    const { items } = await this.checks.getAssignmentsForDevice(effective);
    return { items };
  }
}

===== END FILE remoteiq-minimal-e2e\backend\src\agents\agents.controller.ts =====

===== FILE: remoteiq-minimal-e2e\backend\src\agents\agents.module.ts (17 lines) =====
// remoteiq-minimal-e2e\backend\src\agents\agents.module.ts
import { Module } from '@nestjs/common';
import { AgentsController } from './agents.controller';
import { AgentsService } from './agents.service';
import { AuthModule } from '../auth/auth.module';
import { StorageModule } from '../storage/storage.module'; // provides PgPoolService
import { CommonModule } from '../common/common.module';    // provides AgentTokenGuard utilities
import { ChecksModule } from '../checks/checks.module';    // <-- provides ChecksService to controller

@Module({
  imports: [AuthModule, StorageModule, CommonModule, ChecksModule],
  controllers: [AgentsController],
  providers: [AgentsService],
  exports: [AgentsService],
})
export class AgentsModule { }

===== END FILE remoteiq-minimal-e2e\backend\src\agents\agents.module.ts =====

===== FILE: remoteiq-minimal-e2e\backend\src\agents\agents.service.ts (142 lines) =====
// backend/src/agents/agents.service.ts
import { Injectable } from "@nestjs/common";
import { PgPoolService } from "../storage/pg-pool.service";

// DTOs are validated in controllers; here we accept partials safely.
type UpdateAgentFacts = Partial<{
    hostname: string;
    os: string;
    arch: string | null;         // NOT NULL in DB → we will ignore null updates
    version: string | null;      // nullable
    primaryIp: string | null;    // nullable
    client: string | null;       // nullable
    site: string | null;         // nullable
    user: string | null;         // alias accepted from agent payloads
    loggedInUser: string | null; // alias (both map to logged_in_user)
}>;

type SoftwareItem = {
    name: string;
    version?: string | null;
    publisher?: string | null;
    installDate?: string | null;
};

@Injectable()
export class AgentsService {
    constructor(private readonly pg: PgPoolService) { }

    /** Return the stable UUID mirror for a numeric agent id (or null if absent). */
    async getAgentUuidById(agentId: number): Promise<string | null> {
        try {
            const { rows } = await this.pg.query<{ agent_uuid: string | null }>(
                `SELECT agent_uuid FROM public.agents WHERE id = $1 LIMIT 1`,
                [agentId]
            );
            return rows[0]?.agent_uuid ?? null;
        } catch {
            return null;
        }
    }

    /**
     * Update agent facts and bump last_seen_at.
     * - Only updates provided fields.
     * - Never sets NOT NULL columns to NULL.
     */
    async updateFacts(agentId: number, facts: UpdateAgentFacts): Promise<void> {
        const sets: string[] = [`last_seen_at = NOW()`];
        const params: any[] = [];
        let p = 1;

        // For columns that are NOT NULL in your schema, do not accept null writes.
        const setIfDefined = (col: string, val: any) => {
            if (val !== undefined) {
                sets.push(`${col} = $${p++}`);
                params.push(val);
            }
        };
        const setIfNullable = (col: string, val: any) => {
            if (val !== undefined) {
                sets.push(`${col} = $${p++}`);
                params.push(val); // can be null; that’s fine for nullable cols
            }
        };
        const setIfNotNull = (col: string, val: any) => {
            if (val !== undefined && val !== null) {
                sets.push(`${col} = $${p++}`);
                params.push(val);
            }
        };

        // Likely NOT NULL in table
        setIfDefined("hostname", facts.hostname);
        setIfDefined("os", facts.os);
        setIfNotNull("arch", facts.arch); // skip if null/undefined

        // Nullable fields
        setIfNullable("version", facts.version ?? undefined);
        setIfNullable("primary_ip", facts.primaryIp ?? undefined);
        setIfNullable("client", facts.client ?? undefined);
        setIfNullable("site", facts.site ?? undefined);

        // Accept both 'user' and 'loggedInUser' from payloads → store in logged_in_user
        const loginUser = facts.user ?? facts.loggedInUser;
        setIfNullable("logged_in_user", loginUser ?? undefined);

        const sql = `
      UPDATE public.agents
      SET ${sets.join(", ")}
      WHERE id = $${p}
    `;
        params.push(agentId);

        await this.pg.query(sql, params);
    }

    /** Upsert full software inventory for an agent. */
    async upsertSoftware(agentId: number, items: SoftwareItem[]): Promise<void> {
        if (!Array.isArray(items) || items.length === 0) return;

        const valuesSql: string[] = [];
        const params: any[] = [];
        let p = 1;

        for (const it of items) {
            const name = (it.name || "").trim();
            if (!name) continue;

            valuesSql.push(`(
        $${p++}::integer,
        $${p++}::text,
        $${p++}::text,
        $${p++}::text,
        $${p++}::timestamptz
      )`);

            params.push(
                agentId,
                name,
                it.version ?? null,
                it.publisher ?? null,
                it.installDate ? new Date(it.installDate) : null
            );
        }

        if (valuesSql.length === 0) return;

        // Requires a matching unique index/constraint in DB:
        // CREATE UNIQUE INDEX IF NOT EXISTS agent_software_uk ON public.agent_software (agent_id, lower(name), COALESCE(version,''));
        const sql = `
      INSERT INTO public.agent_software (agent_id, name, version, publisher, install_date)
      VALUES ${valuesSql.join(",")}
      ON CONFLICT (agent_id, lower(name), COALESCE(version,'')) DO UPDATE
      SET
        publisher = EXCLUDED.publisher,
        install_date = EXCLUDED.install_date
    `;
        await this.pg.query(sql, params);
    }
}


===== END FILE remoteiq-minimal-e2e\backend\src\agents\agents.service.ts =====

===== FILE: remoteiq-minimal-e2e\backend\src\common\admin-api.guard.ts (14 lines) =====
import { CanActivate, ExecutionContext, Injectable, UnauthorizedException } from "@nestjs/common";

@Injectable()
export class AdminApiGuard implements CanActivate {
  canActivate(ctx: ExecutionContext): boolean {
    const req = ctx.switchToHttp().getRequest();
    const key = req.header("x-admin-api-key");
    const expected = process.env.ADMIN_API_KEY || "";
    if (!expected || key !== expected) {
      throw new UnauthorizedException("Invalid or missing x-admin-api-key");
    }
    return true;
  }
}
===== END FILE remoteiq-minimal-e2e\backend\src\common\admin-api.guard.ts =====

===== FILE: remoteiq-minimal-e2e\backend\src\common\agent-token.util.ts (98 lines) =====
// remoteiq-minimal-e2e/backend/src/common/agent-token.util.ts
import { Injectable, CanActivate, ExecutionContext, UnauthorizedException } from '@nestjs/common';
import type { Request } from 'express';
import crypto from 'node:crypto';
import jwt from 'jsonwebtoken';
import { PgPoolService } from '../storage/pg-pool.service';

/** ───────────────────────────
 *  Crypto helpers
 *  ─────────────────────────── */
const algo = 'sha256';

export function hashToken(token: string): string {
  return crypto.createHash(algo).update(token, 'utf8').digest('hex');
}

export function newOpaqueToken(): string {
  return crypto.randomBytes(24).toString('base64url');
}

export function signAgentJwt(agentId: string): string {
  const secret = process.env.JWT_SECRET || 'dev';
  return jwt.sign({ sub: agentId, typ: 'agent' }, secret, { algorithm: 'HS256' });
}

export function verifyAgentJwt(token: string): string | null {
  try {
    const secret = process.env.JWT_SECRET || 'dev';
    const payload = jwt.verify(token, secret) as any;
    return payload?.sub as string;
  } catch {
    return null;
  }
}

/** ───────────────────────────
 *  Request augmentation helper
 *  ─────────────────────────── */
export type AgentAuthContext = {
  id: number;
  token?: string;
};

export function getAgentFromRequest(req: any): AgentAuthContext {
  return (req as any).agent as AgentAuthContext;
}

/** ───────────────────────────
 *  DB row shape(s)
 *  ─────────────────────────── */
type AgentRow = {
  id: number;
  token_hash: string | null;
};

/** ───────────────────────────
 *  Bearer token guard for agents
 *  ─────────────────────────── */
@Injectable()
export class AgentTokenGuard implements CanActivate {
  constructor(private readonly db: PgPoolService) { }

  async canActivate(context: ExecutionContext): Promise<boolean> {
    const req = context.switchToHttp().getRequest<Request>();

    const authHeader = req.headers['authorization'];
    if (!authHeader || Array.isArray(authHeader)) {
      throw new UnauthorizedException('Missing Authorization header');
    }

    const match = /^Bearer\s+(.+)$/.exec(authHeader);
    if (!match) {
      throw new UnauthorizedException('Invalid Authorization header format');
    }

    const token = match[1];
    const tokenHash = hashToken(token);

    // Use the typed query helper (no private pool access)
    const { rows } = await this.db.query<AgentRow>(
      `SELECT id, token_hash
         FROM public.agents
        WHERE token_hash = $1
        LIMIT 1`,
      [tokenHash],
    );

    if (rows.length === 0) {
      throw new UnauthorizedException('Invalid or unknown agent token');
    }

    // Stash minimal agent context on the request
    (req as any).agent = { id: rows[0].id, token } as AgentAuthContext;

    return true;
  }
}

===== END FILE remoteiq-minimal-e2e\backend\src\common\agent-token.util.ts =====

===== FILE: remoteiq-minimal-e2e\backend\src\common\auth-cookie.middleware.ts (42 lines) =====
import { Injectable, NestMiddleware } from "@nestjs/common";
import type { Request, Response, NextFunction } from "express";
import { JwtService } from "@nestjs/jwt";

type AnyReq = Request & { user?: any };

@Injectable()
export class AuthCookieMiddleware implements NestMiddleware {
    constructor(private readonly jwt: JwtService) { }

    use(req: AnyReq, _res: Response, next: NextFunction) {
        try {
            const cookieName = process.env.AUTH_COOKIE_NAME || "auth_token";
            const token = (req as any).cookies?.[cookieName];

            if (!token) {
                return next();
            }

            // If tokens were signed with "sub" as user id (recommended)
            const payload = this.jwt.verify(token, {
                secret: process.env.JWT_SECRET ?? "dev-secret",
            });

            // Normalize a common shape for controllers:
            // prefer `sub`, but support `id` for older tokens
            const id = (payload as any).sub ?? (payload as any).id;
            if (id) {
                req.user = {
                    id,
                    email: (payload as any).email,
                    name: (payload as any).name,
                    role: (payload as any).role,
                };
            }
        } catch {
            // ignore invalid/expired token; route can still be public
        }
        next();
    }
}

===== END FILE remoteiq-minimal-e2e\backend\src\common\auth-cookie.middleware.ts =====

===== FILE: remoteiq-minimal-e2e\backend\src\common\common.module.ts (14 lines) =====
// backend/src/common/common.module.ts
import { Module } from '@nestjs/common';
import { SocketRegistry } from './socket-registry.service';
import { UiSocketRegistry } from './ui-socket-registry.service';
import { AgentTokenGuard } from './agent-token.util';
import { StorageModule } from '../storage/storage.module';

@Module({
    imports: [StorageModule],
    providers: [SocketRegistry, UiSocketRegistry, AgentTokenGuard],
    exports: [SocketRegistry, UiSocketRegistry, AgentTokenGuard],
})
export class CommonModule { }

===== END FILE remoteiq-minimal-e2e\backend\src\common\common.module.ts =====

===== FILE: remoteiq-minimal-e2e\backend\src\common\health.controller.ts (8 lines) =====
// src/common/health.controller.ts
import { Controller, Get } from '@nestjs/common';

@Controller('/healthz')
export class HealthController {
    @Get() get() { return { ok: true, ts: Date.now() }; }
}

===== END FILE remoteiq-minimal-e2e\backend\src\common\health.controller.ts =====

===== FILE: remoteiq-minimal-e2e\backend\src\common\online.util.ts (6 lines) =====
// src/common/online.util.ts
export function isAgentOnline(lastHeartbeatAt?: Date | null, thresholdMs = 30_000): boolean {
    if (!lastHeartbeatAt) return false;
    return Date.now() - new Date(lastHeartbeatAt).getTime() < thresholdMs;
}

===== END FILE remoteiq-minimal-e2e\backend\src\common\online.util.ts =====

===== FILE: remoteiq-minimal-e2e\backend\src\common\pagination.ts (11 lines) =====
// src/common/pagination.ts
export function encodeCursor(val: string | number | Date): string {
  const s = typeof val === "string" ? val : (val instanceof Date ? val.toISOString() : String(val));
  return Buffer.from(s, "utf8").toString("base64url");
}
export function decodeCursor(cursor?: string): string | undefined {
  if (!cursor) return undefined;
  try { return Buffer.from(cursor, "base64url").toString("utf8"); }
  catch { return undefined; }
}

===== END FILE remoteiq-minimal-e2e\backend\src\common\pagination.ts =====

===== FILE: remoteiq-minimal-e2e\backend\src\common\socket-registry.service.ts (61 lines) =====
//remoteiq-minimal-e2e\backend\src\common\socket-registry.service.ts

import { Injectable } from "@nestjs/common";
import type { WebSocket } from "ws";

export type AgentSocket = WebSocket & {
    agentId?: string;
    deviceId?: string;
};

@Injectable()
export class SocketRegistry {
    private socketsByAgent = new Map<string, AgentSocket>();
    private socketsByDevice = new Map<string, AgentSocket>();

    // --- Primary API ---
    getByAgent(agentId: string): AgentSocket | undefined {
        return this.socketsByAgent.get(agentId);
    }

    getByDevice(deviceId: string): AgentSocket | undefined {
        return this.socketsByDevice.get(deviceId);
    }

    set(agentId: string | undefined, deviceId: string | undefined, socket: AgentSocket) {
        if (agentId) {
            this.socketsByAgent.set(agentId, socket);
            socket.agentId = agentId;
        }
        if (deviceId) {
            this.socketsByDevice.set(deviceId, socket);
            socket.deviceId = deviceId;
        }
    }

    deleteByAgent(agentId: string) {
        const sock = this.socketsByAgent.get(agentId);
        if (sock?.deviceId) this.socketsByDevice.delete(sock.deviceId);
        this.socketsByAgent.delete(agentId);
    }

    deleteByDevice(deviceId: string) {
        const sock = this.socketsByDevice.get(deviceId);
        if (sock?.agentId) this.socketsByAgent.delete(sock.agentId);
        this.socketsByDevice.delete(deviceId);
    }

    // --- Back-compat aliases (so older callers like dispatcher.service can keep using .get) ---
    /** Alias for getByAgent */
    get(agentId: string): AgentSocket | undefined {
        return this.getByAgent(agentId);
    }
    /** Aliases in case other code uses these names */
    setByAgent(agentId: string, socket: AgentSocket) {
        this.set(agentId, /*deviceId*/ undefined, socket);
    }
    setByDevice(deviceId: string, socket: AgentSocket) {
        this.set(/*agentId*/ undefined, deviceId, socket);
    }
}

===== END FILE remoteiq-minimal-e2e\backend\src\common\socket-registry.service.ts =====

===== FILE: remoteiq-minimal-e2e\backend\src\common\types.ts (17 lines) =====
export type WSIncoming =
  | { t: "hello"; agentId: string; capabilities: string[]; os: string; arch: string; hostname: string; version: string }
  | { t: "hb"; at: string; metrics?: { cpu?: number; mem?: number } }
  | { t: "job_result"; jobId: string; exitCode: number; stdout: string; stderr: string; startedAt: string; finishedAt: string };

export type WSOutgoing =
  | { t: "ack"; id: string }
  | {
    t: "job_run_script";
    jobId: string;
    language: "powershell" | "bash";
    scriptText: string;
    args?: string[];
    env?: Record<string, string>;
    timeoutSec?: number;
  };

===== END FILE remoteiq-minimal-e2e\backend\src\common\types.ts =====

===== FILE: remoteiq-minimal-e2e\backend\src\common\ui-socket-registry.service.ts (200 lines) =====
// backend/src/common/ui-socket-registry.service.ts
import { Injectable, Logger } from "@nestjs/common";
import type { WebSocket } from "ws";

/**
 * UI (dashboard) socket with metadata.
 * - userId: authenticated user identifier (string)
 * - subscriptions: deviceIds this socket has subscribed to
 */
export type UiSocket = WebSocket & {
    userId?: string;
    subscriptions?: Set<string>;
};

function isOpen(ws: WebSocket): boolean {
    // 'OPEN' is a numeric const on ws WebSocket instances
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    return (ws as any).readyState === (ws as any).OPEN;
}

/**
 * Registry for **dashboard/user** WebSocket connections and their subscriptions.
 * Isolation from the Agent socket registry keeps privileges and broadcasting clean.
 *
 * Notes:
 * - In-memory only (per-process). For multi-node deployments, back this with Redis or a message bus.
 * - Broadcast methods return the number of sockets that were attempted (best-effort).
 */
@Injectable()
export class UiSocketRegistry {
    private readonly log = new Logger("UiSocketRegistry");

    /** All sockets for a given user */
    private socketsByUser = new Map<string, Set<UiSocket>>();

    /** Subscribers for a given deviceId */
    private socketsByDevice = new Map<string, Set<UiSocket>>();

    /** Track every active socket for cleanup/metrics */
    private allSockets = new Set<UiSocket>();

    /* ---------------------------- Socket lifecycle ---------------------------- */

    /** Register a new UI socket for a specific user (auth already verified). */
    add(userId: string, socket: UiSocket): void {
        socket.userId = String(userId);
        socket.subscriptions = socket.subscriptions ?? new Set<string>();

        // Per-user index
        if (!this.socketsByUser.has(userId)) this.socketsByUser.set(userId, new Set());
        this.socketsByUser.get(userId)!.add(socket);

        // Global index
        this.allSockets.add(socket);
    }

    /** Remove a UI socket from all indexes (called on close/error). */
    remove(socket: UiSocket): void {
        // Unsubscribe from all device topics first
        if (socket.subscriptions && socket.subscriptions.size) {
            for (const deviceId of socket.subscriptions) {
                this.unsubscribe(socket, deviceId);
            }
            socket.subscriptions.clear();
        }

        // Detach from per-user map
        const uid = socket.userId;
        if (uid && this.socketsByUser.has(uid)) {
            const set = this.socketsByUser.get(uid)!;
            set.delete(socket);
            if (set.size === 0) this.socketsByUser.delete(uid);
        }

        // Global index
        this.allSockets.delete(socket);
    }

    /** Remove all sockets for a given user (e.g., on logout/revoke). */
    removeAllForUser(userId: string): number {
        const set = this.socketsByUser.get(userId);
        if (!set || !set.size) return 0;
        let n = 0;
        for (const s of Array.from(set)) {
            try {
                // Close with policy code; UI can auto-reconnect if appropriate
                // eslint-disable-next-line @typescript-eslint/no-explicit-any
                (s as any).close?.(4401, "User sessions revoked");
            } catch {
                /* ignore */
            }
            this.remove(s);
            n++;
        }
        return n;
    }

    /* ----------------------------- Subscriptions ------------------------------ */

    /** Subscribe a socket to a device topic (idempotent). */
    subscribe(socket: UiSocket, deviceId: string): void {
        const id = String(deviceId);
        socket.subscriptions = socket.subscriptions ?? new Set<string>();
        if (socket.subscriptions.has(id)) return;

        socket.subscriptions.add(id);

        if (!this.socketsByDevice.has(id)) this.socketsByDevice.set(id, new Set());
        this.socketsByDevice.get(id)!.add(socket);
    }

    /** Unsubscribe a socket from a device topic (no-op if not subscribed). */
    unsubscribe(socket: UiSocket, deviceId: string): void {
        const id = String(deviceId);
        if (socket.subscriptions && socket.subscriptions.has(id)) {
            socket.subscriptions.delete(id);
        }
        const set = this.socketsByDevice.get(id);
        if (set) {
            set.delete(socket);
            if (set.size === 0) this.socketsByDevice.delete(id);
        }
    }

    /** Unsubscribe a socket from all topics. */
    unsubscribeAll(socket: UiSocket): void {
        if (!socket.subscriptions) return;
        for (const id of Array.from(socket.subscriptions)) {
            this.unsubscribe(socket, id);
        }
    }

    /* -------------------------------- Broadcasts ------------------------------ */

    /** Broadcast to all UI sockets (rare; prefer topic broadcasts). */
    broadcastAll(payload: unknown): number {
        const msg = JSON.stringify(payload);
        let sent = 0;
        for (const s of this.allSockets) {
            if (!isOpen(s)) continue;
            try {
                s.send(msg);
                sent++;
            } catch {
                /* ignore per-socket send errors */
            }
        }
        return sent;
    }

    /** Broadcast to all sockets subscribed to a specific deviceId. */
    broadcastToDevice(deviceId: string, payload: unknown): number {
        const set = this.socketsByDevice.get(String(deviceId));
        if (!set || set.size === 0) return 0;
        const msg = JSON.stringify(payload);
        let sent = 0;
        for (const s of set) {
            if (!isOpen(s)) continue;
            try {
                s.send(msg);
                sent++;
            } catch {
                /* ignore per-socket send errors */
            }
        }
        return sent;
    }

    /** Broadcast to all sockets for a given userId (e.g., personal notices). */
    broadcastToUser(userId: string, payload: unknown): number {
        const set = this.socketsByUser.get(String(userId));
        if (!set || set.size === 0) return 0;
        const msg = JSON.stringify(payload);
        let sent = 0;
        for (const s of set) {
            if (!isOpen(s)) continue;
            try {
                s.send(msg);
                sent++;
            } catch {
                /* ignore per-socket send errors */
            }
        }
        return sent;
    }

    /* --------------------------------- Metrics -------------------------------- */

    countAll(): number {
        return this.allSockets.size;
    }
    countUsers(): number {
        return this.socketsByUser.size;
    }
    countDeviceSubscribers(deviceId: string): number {
        const set = this.socketsByDevice.get(String(deviceId));
        return set ? set.size : 0;
    }
}

===== END FILE remoteiq-minimal-e2e\backend\src\common\ui-socket-registry.service.ts =====

===== FILE: remoteiq-minimal-e2e\backend\src\ws\agent.gateway.ts (192 lines) =====
// backend/src/ws/agent.gateway.ts
import {
  Inject,
  Injectable,
  Logger,
  OnModuleDestroy,
  OnModuleInit,
  forwardRef,
} from "@nestjs/common";
import { WebSocketGateway, WebSocketServer } from "@nestjs/websockets";
import type { Server as WsServer, WebSocket, RawData } from "ws";

import { SocketRegistry, type AgentSocket } from "../common/socket-registry.service";
import { DispatcherService } from "../jobs/dispatcher.service";
import { JobsService } from "../jobs/jobs.service";

type JobResultMsg = {
  t: "job_result";
  jobId: string;
  exitCode?: number;
  stdout?: string;
  stderr?: string;
  durationMs?: number;
  status?: string; // agent may send custom text, we will map to our enum
};

type AgentHelloMsg = {
  t: "agent_hello";
  agentId?: string;
  deviceId?: string;
  hostname?: string;
  os?: string;
  arch?: string;
  version?: string;
};

function rawToString(data: RawData): string {
  if (typeof data === "string") return data;
  if (Buffer.isBuffer(data)) return data.toString("utf8");
  if (Array.isArray(data)) return Buffer.concat(data as Buffer[]).toString("utf8");
  if (data instanceof ArrayBuffer) return Buffer.from(data).toString("utf8");
  return "";
}

@WebSocketGateway({ path: "/ws" })
@Injectable()
export class AgentGateway implements OnModuleInit, OnModuleDestroy {
  private readonly log = new Logger("AgentGateway");

  @WebSocketServer()
  private ws!: WsServer;

  constructor(
    private readonly sockets: SocketRegistry,
    @Inject(forwardRef(() => DispatcherService))
    private readonly dispatcher: DispatcherService,
    @Inject(forwardRef(() => JobsService))
    private readonly jobs: JobsService,
  ) { }

  onModuleInit() {
    if (!this.ws) {
      this.log.warn("WS server not initialized by adapter; ensure a WS adapter is configured.");
      return;
    }

    this.ws.on("connection", (socket: WebSocket & Partial<AgentSocket>) => {
      this.log.debug("Agent WS connected (awaiting hello)");

      socket.on("message", async (data: RawData) => {
        const text = rawToString(data);
        if (!text) return;

        let msg: any;
        try {
          msg = JSON.parse(text);
        } catch {
          return;
        }
        const t = msg?.t as string | undefined;
        if (!t) return;

        if (t === "agent_hello") {
          const hello = msg as AgentHelloMsg;
          const agentId = String(hello.agentId ?? "").trim();
          const deviceId = String(hello.deviceId ?? "").trim();
          const hostname = String(hello.hostname ?? "").trim();

          if (!agentId) {
            this.log.warn("agent_hello missing agentId; closing socket.");
            socket.close(1008, "agentId required");
            return;
          }

          // Persist identifiers on the socket so cleanup works
          (socket as AgentSocket).agentId = agentId;
          (socket as AgentSocket).deviceId = deviceId || undefined;
          // AgentSocket doesn't declare hostname; store it loosely for logs/debug
          (socket as any).hostname = hostname || undefined;

          // Register into the registry
          this.sockets.set(agentId, deviceId || undefined, socket as AgentSocket);

          this.log.log(
            `Registered agent socket: agentId=${agentId}` +
            (deviceId ? ` deviceId=${deviceId}` : "") +
            (hostname ? ` host=${hostname}` : ""),
          );

          try {
            await this.dispatcher.dispatchQueuedForAgent(agentId);
          } catch (e: any) {
            this.log.warn(`dispatchQueuedForAgent failed: ${e?.message ?? e}`);
          }
          return;
        }

        if (t === "job_result") {
          const jr = msg as JobResultMsg;
          if (!jr.jobId) {
            this.log.warn("job_result missing jobId; ignoring");
            return;
          }

          const exitCode = Number.isFinite(jr.exitCode) ? Number(jr.exitCode) : -1;
          const stdout = typeof jr.stdout === "string" ? jr.stdout : "";
          const stderr = typeof jr.stderr === "string" ? jr.stderr : "";
          const durationMs = Number.isFinite(jr.durationMs) ? Number(jr.durationMs) : 0;

          // Map to our JobsService status enum: "succeeded" | "failed" | "timeout"
          let status: "succeeded" | "failed" | "timeout";
          const s = (jr.status ?? "").toLowerCase();
          if (s === "timeout") status = "timeout";
          else if (s === "succeeded" || (s === "finished" && exitCode === 0) || exitCode === 0) status = "succeeded";
          else status = "failed";

          try {
            await this.jobs.finishJob(
              jr.jobId,
              { exitCode, stdout, stderr, durationMs },
              status,
            );
          } catch (e: any) {
            this.log.warn(`finishJob failed for ${jr.jobId}: ${e?.message ?? e}`);
          }
          return;
        }
      });

      socket.on("close", () => {
        const s = socket as AgentSocket;
        if (s.agentId) this.sockets.deleteByAgent(s.agentId);
        if (s.deviceId) this.sockets.deleteByDevice(s.deviceId);
      });

      socket.on("error", () => {
        // close handler will clean up
      });
    });
  }

  onModuleDestroy() {
    try {
      this.ws?.close();
    } catch {
      /* ignore */
    }
  }

  /**
   * Broadcast a JSON message to all connected agent sockets.
   * automation.controller.ts expects this to exist.
   */
  public broadcast(payload: unknown, filter?: (s: AgentSocket) => boolean): number {
    if (!this.ws?.clients) return 0;
    let sent = 0;
    for (const client of this.ws.clients) {
      const sock = client as AgentSocket;
      // 'OPEN' is a numeric const on ws WebSocket instances
      if ((client as any).readyState !== (client as any).OPEN) continue;
      if (filter && !filter(sock)) continue;
      try {
        client.send(JSON.stringify(payload));
        sent++;
      } catch {
        // ignore per-socket send errors
      }
    }
    return sent;
  }
}

===== END FILE remoteiq-minimal-e2e\backend\src\ws\agent.gateway.ts =====

===== FILE: remoteiq-minimal-e2e\backend\src\ws\dashboard.gateway.ts (251 lines) =====
// backend/src/ws/dashboard.gateway.ts
import {
    Injectable,
    Logger,
    OnModuleDestroy,
    OnModuleInit,
} from "@nestjs/common";
import { WebSocketGateway, WebSocketServer } from "@nestjs/websockets";
import type { Server as WsServer, WebSocket, RawData } from "ws";
import type { IncomingMessage } from "http";
import { JwtService } from "@nestjs/jwt";

import {
    UiSocketRegistry,
    type UiSocket,
} from "../common/ui-socket-registry.service";

/**
 * Minimal cookie parser (avoids external deps).
 */
function parseCookieHeader(h?: string): Record<string, string> {
    const out: Record<string, string> = {};
    if (!h) return out;
    for (const p of h.split(";")) {
        const i = p.indexOf("=");
        if (i > -1) out[p.slice(0, i).trim()] = decodeURIComponent(p.slice(i + 1));
    }
    return out;
}

/**
 * Safely stringify payloads for WS.
 */
function safeJson(data: unknown): string {
    try {
        return JSON.stringify(data);
    } catch {
        return "{}";
    }
}

/**
 * UI (dashboard) WebSocket gateway.
 * - Authenticates users by JWT cookie (same cookie as HTTP)
 * - Registers sockets into UiSocketRegistry
 * - Supports per-device subscriptions: {t:"subscribe", deviceId}, {t:"unsubscribe", deviceId}
 * - Heartbeat: {t:"ping"} -> {t:"pong"}
 *
 * NOTE: Remember to add DashboardGateway to WsModule.providers.
 */
@WebSocketGateway({ path: "/ws-ui" })
@Injectable()
export class DashboardGateway implements OnModuleInit, OnModuleDestroy {
    private readonly log = new Logger("DashboardGateway");

    @WebSocketServer()
    private ws!: WsServer;

    private readonly cookieName =
        process.env.AUTH_COOKIE_NAME?.trim() || "auth_token";
    private readonly jwtSecret =
        process.env.JWT_SECRET?.trim() || "dev-secret"; // dev fallback

    constructor(
        private readonly uiSockets: UiSocketRegistry,
        private readonly jwt: JwtService
    ) { }

    onModuleInit() {
        if (!this.ws) {
            this.log.warn(
                "WS server not initialized by adapter; ensure a WS adapter is configured."
            );
            return;
        }

        this.ws.on(
            "connection",
            async (rawSocket: WebSocket, req: IncomingMessage) => {
                const socket = rawSocket as UiSocket;

                // ---- Authenticate user from cookie JWT ----
                const cookies = parseCookieHeader(
                    (req.headers && (req.headers as any).cookie) || ""
                );
                const token = cookies[this.cookieName];
                if (!token) {
                    this.closeWithPolicy(socket, 4401, "Missing auth cookie");
                    return;
                }

                let userId = "";
                try {
                    const payload: any = await this.jwt.verifyAsync(token, {
                        secret: this.jwtSecret,
                    });
                    // Expect standard fields from your login flow
                    userId = String(payload?.sub || payload?.id || "");
                    if (!userId) throw new Error("No sub in JWT");
                } catch (e: any) {
                    this.closeWithPolicy(
                        socket,
                        4401,
                        `Invalid auth token: ${e?.message || e}`
                    );
                    return;
                }

                // ---- Register socket ----
                try {
                    // Ensure subscriptions set exists for this socket
                    socket.subscriptions = socket.subscriptions ?? new Set<string>();
                    this.uiSockets.add(userId, socket);

                    // Ack the connection
                    socket.send(
                        safeJson({
                            t: "ack",
                            userId,
                            subscriptions: Array.from(socket.subscriptions),
                            totals: {
                                sockets: this.uiSockets.countAll(),
                                users: this.uiSockets.countUsers(),
                            },
                        })
                    );
                } catch (e: any) {
                    this.log.warn(
                        `Failed to register UI socket for user ${userId}: ${e?.message || e}`
                    );
                    this.closeWithPolicy(socket, 1011, "Registration failed");
                    return;
                }

                // ---- Message handling ----
                socket.on("message", (data: RawData) => {
                    const text = this.rawToString(data);
                    if (!text) return;

                    let msg: any;
                    try {
                        msg = JSON.parse(text);
                    } catch {
                        return;
                    }
                    const t: string = String(msg?.t || "");

                    // Ping/Pong
                    if (t === "ping") {
                        socket.send(safeJson({ t: "pong", at: new Date().toISOString() }));
                        return;
                    }

                    // Subscribe to a deviceId
                    if (t === "subscribe") {
                        const deviceId = String(msg?.deviceId || "").trim();
                        if (!deviceId) return;

                        try {
                            this.uiSockets.subscribe(socket, deviceId);
                            socket.send(
                                safeJson({
                                    t: "subscribed",
                                    deviceId,
                                    subscribers: this.uiSockets.countDeviceSubscribers(deviceId),
                                })
                            );
                        } catch (e: any) {
                            socket.send(
                                safeJson({
                                    t: "error",
                                    error: "subscribe_failed",
                                    message: e?.message || String(e),
                                })
                            );
                        }
                        return;
                    }

                    // Unsubscribe from a deviceId
                    if (t === "unsubscribe") {
                        const deviceId = String(msg?.deviceId || "").trim();
                        if (!deviceId) return;

                        try {
                            this.uiSockets.unsubscribe(socket, deviceId);
                            socket.send(
                                safeJson({
                                    t: "unsubscribed",
                                    deviceId,
                                    subscribers: this.uiSockets.countDeviceSubscribers(deviceId),
                                })
                            );
                        } catch (e: any) {
                            socket.send(
                                safeJson({
                                    t: "error",
                                    error: "unsubscribe_failed",
                                    message: e?.message || String(e),
                                })
                            );
                        }
                        return;
                    }

                    // Unknown message type — ignore silently or send error
                });

                // ---- Cleanup on close/error ----
                const cleanup = () => {
                    try {
                        this.uiSockets.remove(socket);
                    } catch {
                        /* ignore */
                    }
                };
                socket.on("close", cleanup);
                socket.on("error", cleanup);
            }
        );
    }

    onModuleDestroy() {
        try {
            this.ws?.close();
        } catch {
            /* ignore */
        }
    }

    /* ------------------------------- Helpers -------------------------------- */

    private rawToString(data: RawData): string {
        if (typeof data === "string") return data;
        if (Buffer.isBuffer(data)) return data.toString("utf8");
        if (Array.isArray(data))
            return Buffer.concat(data as Buffer[]).toString("utf8");
        if (data instanceof ArrayBuffer) return Buffer.from(data).toString("utf8");
        return "";
    }

    private closeWithPolicy(ws: WebSocket, code: number, reason: string) {
        try {
            // eslint-disable-next-line @typescript-eslint/no-explicit-any
            (ws as any).close?.(code, reason);
        } catch {
            /* ignore */
        }
    }
}

===== END FILE remoteiq-minimal-e2e\backend\src\ws\dashboard.gateway.ts =====

===== FILE: remoteiq-minimal-e2e\backend\src\ws\ws.module.ts (29 lines) =====
// backend/src/ws/ws.module.ts
import { Module, forwardRef } from "@nestjs/common";
import { JwtModule } from "@nestjs/jwt";

import { AgentGateway } from "./agent.gateway";
import { DashboardGateway } from "./dashboard.gateway";

import { JobsModule } from "../jobs/jobs.module";
import { CommonModule } from "../common/common.module";
import { StorageModule } from "../storage/storage.module";

@Module({
  imports: [
    CommonModule,                  // SocketRegistry + UiSocketRegistry
    StorageModule,                 // PgPoolService (Agent/Dashboard gateways)
    forwardRef(() => JobsModule),  // circular with jobs <-> ws is fine

    // Provide JwtService for DashboardGateway auth (typing-safe for ms StringValue)
    JwtModule.register({
      secret: process.env.JWT_SECRET ?? "dev-secret",
      // jsonwebtoken accepts number (seconds) or ms-format string; cast to satisfy strict types
      signOptions: { expiresIn: ((process.env.JWT_EXPIRES as any) ?? ("7d" as any)) },
    }),
  ],
  providers: [AgentGateway, DashboardGateway],
  exports: [AgentGateway, DashboardGateway],
})
export class WsModule { }

===== END FILE remoteiq-minimal-e2e\backend\src\ws\ws.module.ts =====

### Summary
Files written: 51
Files missing (skipped): 0
