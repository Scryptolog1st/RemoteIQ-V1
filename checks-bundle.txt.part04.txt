===== FILE: remoteiq-minimal-e2e\backend\src\ws\agent.gateway.ts (192 lines) =====
// backend/src/ws/agent.gateway.ts
import {
  Inject,
  Injectable,
  Logger,
  OnModuleDestroy,
  OnModuleInit,
  forwardRef,
} from "@nestjs/common";
import { WebSocketGateway, WebSocketServer } from "@nestjs/websockets";
import type { Server as WsServer, WebSocket, RawData } from "ws";

import { SocketRegistry, type AgentSocket } from "../common/socket-registry.service";
import { DispatcherService } from "../jobs/dispatcher.service";
import { JobsService } from "../jobs/jobs.service";

type JobResultMsg = {
  t: "job_result";
  jobId: string;
  exitCode?: number;
  stdout?: string;
  stderr?: string;
  durationMs?: number;
  status?: string; // agent may send custom text, we will map to our enum
};

type AgentHelloMsg = {
  t: "agent_hello";
  agentId?: string;
  deviceId?: string;
  hostname?: string;
  os?: string;
  arch?: string;
  version?: string;
};

function rawToString(data: RawData): string {
  if (typeof data === "string") return data;
  if (Buffer.isBuffer(data)) return data.toString("utf8");
  if (Array.isArray(data)) return Buffer.concat(data as Buffer[]).toString("utf8");
  if (data instanceof ArrayBuffer) return Buffer.from(data).toString("utf8");
  return "";
}

@WebSocketGateway({ path: "/ws" })
@Injectable()
export class AgentGateway implements OnModuleInit, OnModuleDestroy {
  private readonly log = new Logger("AgentGateway");

  @WebSocketServer()
  private ws!: WsServer;

  constructor(
    private readonly sockets: SocketRegistry,
    @Inject(forwardRef(() => DispatcherService))
    private readonly dispatcher: DispatcherService,
    @Inject(forwardRef(() => JobsService))
    private readonly jobs: JobsService,
  ) { }

  onModuleInit() {
    if (!this.ws) {
      this.log.warn("WS server not initialized by adapter; ensure a WS adapter is configured.");
      return;
    }

    this.ws.on("connection", (socket: WebSocket & Partial<AgentSocket>) => {
      this.log.debug("Agent WS connected (awaiting hello)");

      socket.on("message", async (data: RawData) => {
        const text = rawToString(data);
        if (!text) return;

        let msg: any;
        try {
          msg = JSON.parse(text);
        } catch {
          return;
        }
        const t = msg?.t as string | undefined;
        if (!t) return;

        if (t === "agent_hello") {
          const hello = msg as AgentHelloMsg;
          const agentId = String(hello.agentId ?? "").trim();
          const deviceId = String(hello.deviceId ?? "").trim();
          const hostname = String(hello.hostname ?? "").trim();

          if (!agentId) {
            this.log.warn("agent_hello missing agentId; closing socket.");
            socket.close(1008, "agentId required");
            return;
          }

          // Persist identifiers on the socket so cleanup works
          (socket as AgentSocket).agentId = agentId;
          (socket as AgentSocket).deviceId = deviceId || undefined;
          // AgentSocket doesn't declare hostname; store it loosely for logs/debug
          (socket as any).hostname = hostname || undefined;

          // Register into the registry
          this.sockets.set(agentId, deviceId || undefined, socket as AgentSocket);

          this.log.log(
            `Registered agent socket: agentId=${agentId}` +
            (deviceId ? ` deviceId=${deviceId}` : "") +
            (hostname ? ` host=${hostname}` : ""),
          );

          try {
            await this.dispatcher.dispatchQueuedForAgent(agentId);
          } catch (e: any) {
            this.log.warn(`dispatchQueuedForAgent failed: ${e?.message ?? e}`);
          }
          return;
        }

        if (t === "job_result") {
          const jr = msg as JobResultMsg;
          if (!jr.jobId) {
            this.log.warn("job_result missing jobId; ignoring");
            return;
          }

          const exitCode = Number.isFinite(jr.exitCode) ? Number(jr.exitCode) : -1;
          const stdout = typeof jr.stdout === "string" ? jr.stdout : "";
          const stderr = typeof jr.stderr === "string" ? jr.stderr : "";
          const durationMs = Number.isFinite(jr.durationMs) ? Number(jr.durationMs) : 0;

          // Map to our JobsService status enum: "succeeded" | "failed" | "timeout"
          let status: "succeeded" | "failed" | "timeout";
          const s = (jr.status ?? "").toLowerCase();
          if (s === "timeout") status = "timeout";
          else if (s === "succeeded" || (s === "finished" && exitCode === 0) || exitCode === 0) status = "succeeded";
          else status = "failed";

          try {
            await this.jobs.finishJob(
              jr.jobId,
              { exitCode, stdout, stderr, durationMs },
              status,
            );
          } catch (e: any) {
            this.log.warn(`finishJob failed for ${jr.jobId}: ${e?.message ?? e}`);
          }
          return;
        }
      });

      socket.on("close", () => {
        const s = socket as AgentSocket;
        if (s.agentId) this.sockets.deleteByAgent(s.agentId);
        if (s.deviceId) this.sockets.deleteByDevice(s.deviceId);
      });

      socket.on("error", () => {
        // close handler will clean up
      });
    });
  }

  onModuleDestroy() {
    try {
      this.ws?.close();
    } catch {
      /* ignore */
    }
  }

  /**
   * Broadcast a JSON message to all connected agent sockets.
   * automation.controller.ts expects this to exist.
   */
  public broadcast(payload: unknown, filter?: (s: AgentSocket) => boolean): number {
    if (!this.ws?.clients) return 0;
    let sent = 0;
    for (const client of this.ws.clients) {
      const sock = client as AgentSocket;
      // 'OPEN' is a numeric const on ws WebSocket instances
      if ((client as any).readyState !== (client as any).OPEN) continue;
      if (filter && !filter(sock)) continue;
      try {
        client.send(JSON.stringify(payload));
        sent++;
      } catch {
        // ignore per-socket send errors
      }
    }
    return sent;
  }
}

===== END FILE remoteiq-minimal-e2e\backend\src\ws\agent.gateway.ts =====

===== FILE: remoteiq-minimal-e2e\backend\src\ws\dashboard.gateway.ts (251 lines) =====
// backend/src/ws/dashboard.gateway.ts
import {
    Injectable,
    Logger,
    OnModuleDestroy,
    OnModuleInit,
} from "@nestjs/common";
import { WebSocketGateway, WebSocketServer } from "@nestjs/websockets";
import type { Server as WsServer, WebSocket, RawData } from "ws";
import type { IncomingMessage } from "http";
import { JwtService } from "@nestjs/jwt";

import {
    UiSocketRegistry,
    type UiSocket,
} from "../common/ui-socket-registry.service";

/**
 * Minimal cookie parser (avoids external deps).
 */
function parseCookieHeader(h?: string): Record<string, string> {
    const out: Record<string, string> = {};
    if (!h) return out;
    for (const p of h.split(";")) {
        const i = p.indexOf("=");
        if (i > -1) out[p.slice(0, i).trim()] = decodeURIComponent(p.slice(i + 1));
    }
    return out;
}

/**
 * Safely stringify payloads for WS.
 */
function safeJson(data: unknown): string {
    try {
        return JSON.stringify(data);
    } catch {
        return "{}";
    }
}

/**
 * UI (dashboard) WebSocket gateway.
 * - Authenticates users by JWT cookie (same cookie as HTTP)
 * - Registers sockets into UiSocketRegistry
 * - Supports per-device subscriptions: {t:"subscribe", deviceId}, {t:"unsubscribe", deviceId}
 * - Heartbeat: {t:"ping"} -> {t:"pong"}
 *
 * NOTE: Remember to add DashboardGateway to WsModule.providers.
 */
@WebSocketGateway({ path: "/ws-ui" })
@Injectable()
export class DashboardGateway implements OnModuleInit, OnModuleDestroy {
    private readonly log = new Logger("DashboardGateway");

    @WebSocketServer()
    private ws!: WsServer;

    private readonly cookieName =
        process.env.AUTH_COOKIE_NAME?.trim() || "auth_token";
    private readonly jwtSecret =
        process.env.JWT_SECRET?.trim() || "dev-secret"; // dev fallback

    constructor(
        private readonly uiSockets: UiSocketRegistry,
        private readonly jwt: JwtService
    ) { }

    onModuleInit() {
        if (!this.ws) {
            this.log.warn(
                "WS server not initialized by adapter; ensure a WS adapter is configured."
            );
            return;
        }

        this.ws.on(
            "connection",
            async (rawSocket: WebSocket, req: IncomingMessage) => {
                const socket = rawSocket as UiSocket;

                // ---- Authenticate user from cookie JWT ----
                const cookies = parseCookieHeader(
                    (req.headers && (req.headers as any).cookie) || ""
                );
                const token = cookies[this.cookieName];
                if (!token) {
                    this.closeWithPolicy(socket, 4401, "Missing auth cookie");
                    return;
                }

                let userId = "";
                try {
                    const payload: any = await this.jwt.verifyAsync(token, {
                        secret: this.jwtSecret,
                    });
                    // Expect standard fields from your login flow
                    userId = String(payload?.sub || payload?.id || "");
                    if (!userId) throw new Error("No sub in JWT");
                } catch (e: any) {
                    this.closeWithPolicy(
                        socket,
                        4401,
                        `Invalid auth token: ${e?.message || e}`
                    );
                    return;
                }

                // ---- Register socket ----
                try {
                    // Ensure subscriptions set exists for this socket
                    socket.subscriptions = socket.subscriptions ?? new Set<string>();
                    this.uiSockets.add(userId, socket);

                    // Ack the connection
                    socket.send(
                        safeJson({
                            t: "ack",
                            userId,
                            subscriptions: Array.from(socket.subscriptions),
                            totals: {
                                sockets: this.uiSockets.countAll(),
                                users: this.uiSockets.countUsers(),
                            },
                        })
                    );
                } catch (e: any) {
                    this.log.warn(
                        `Failed to register UI socket for user ${userId}: ${e?.message || e}`
                    );
                    this.closeWithPolicy(socket, 1011, "Registration failed");
                    return;
                }

                // ---- Message handling ----
                socket.on("message", (data: RawData) => {
                    const text = this.rawToString(data);
                    if (!text) return;

                    let msg: any;
                    try {
                        msg = JSON.parse(text);
                    } catch {
                        return;
                    }
                    const t: string = String(msg?.t || "");

                    // Ping/Pong
                    if (t === "ping") {
                        socket.send(safeJson({ t: "pong", at: new Date().toISOString() }));
                        return;
                    }

                    // Subscribe to a deviceId
                    if (t === "subscribe") {
                        const deviceId = String(msg?.deviceId || "").trim();
                        if (!deviceId) return;

                        try {
                            this.uiSockets.subscribe(socket, deviceId);
                            socket.send(
                                safeJson({
                                    t: "subscribed",
                                    deviceId,
                                    subscribers: this.uiSockets.countDeviceSubscribers(deviceId),
                                })
                            );
                        } catch (e: any) {
                            socket.send(
                                safeJson({
                                    t: "error",
                                    error: "subscribe_failed",
                                    message: e?.message || String(e),
                                })
                            );
                        }
                        return;
                    }

                    // Unsubscribe from a deviceId
                    if (t === "unsubscribe") {
                        const deviceId = String(msg?.deviceId || "").trim();
                        if (!deviceId) return;

                        try {
                            this.uiSockets.unsubscribe(socket, deviceId);
                            socket.send(
                                safeJson({
                                    t: "unsubscribed",
                                    deviceId,
                                    subscribers: this.uiSockets.countDeviceSubscribers(deviceId),
                                })
                            );
                        } catch (e: any) {
                            socket.send(
                                safeJson({
                                    t: "error",
                                    error: "unsubscribe_failed",
                                    message: e?.message || String(e),
                                })
                            );
                        }
                        return;
                    }

                    // Unknown message type — ignore silently or send error
                });

                // ---- Cleanup on close/error ----
                const cleanup = () => {
                    try {
                        this.uiSockets.remove(socket);
                    } catch {
                        /* ignore */
                    }
                };
                socket.on("close", cleanup);
                socket.on("error", cleanup);
            }
        );
    }

    onModuleDestroy() {
        try {
            this.ws?.close();
        } catch {
            /* ignore */
        }
    }

    /* ------------------------------- Helpers -------------------------------- */

    private rawToString(data: RawData): string {
        if (typeof data === "string") return data;
        if (Buffer.isBuffer(data)) return data.toString("utf8");
        if (Array.isArray(data))
            return Buffer.concat(data as Buffer[]).toString("utf8");
        if (data instanceof ArrayBuffer) return Buffer.from(data).toString("utf8");
        return "";
    }

    private closeWithPolicy(ws: WebSocket, code: number, reason: string) {
        try {
            // eslint-disable-next-line @typescript-eslint/no-explicit-any
            (ws as any).close?.(code, reason);
        } catch {
            /* ignore */
        }
    }
}

===== END FILE remoteiq-minimal-e2e\backend\src\ws\dashboard.gateway.ts =====

===== FILE: remoteiq-minimal-e2e\backend\src\ws\ws.module.ts (29 lines) =====
// backend/src/ws/ws.module.ts
import { Module, forwardRef } from "@nestjs/common";
import { JwtModule } from "@nestjs/jwt";

import { AgentGateway } from "./agent.gateway";
import { DashboardGateway } from "./dashboard.gateway";

import { JobsModule } from "../jobs/jobs.module";
import { CommonModule } from "../common/common.module";
import { StorageModule } from "../storage/storage.module";

@Module({
  imports: [
    CommonModule,                  // SocketRegistry + UiSocketRegistry
    StorageModule,                 // PgPoolService (Agent/Dashboard gateways)
    forwardRef(() => JobsModule),  // circular with jobs <-> ws is fine

    // Provide JwtService for DashboardGateway auth (typing-safe for ms StringValue)
    JwtModule.register({
      secret: process.env.JWT_SECRET ?? "dev-secret",
      // jsonwebtoken accepts number (seconds) or ms-format string; cast to satisfy strict types
      signOptions: { expiresIn: ((process.env.JWT_EXPIRES as any) ?? ("7d" as any)) },
    }),
  ],
  providers: [AgentGateway, DashboardGateway],
  exports: [AgentGateway, DashboardGateway],
})
export class WsModule { }

===== END FILE remoteiq-minimal-e2e\backend\src\ws\ws.module.ts =====

### Summary
Files written: 51
Files missing (skipped): 0
