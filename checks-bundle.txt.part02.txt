===== FILE: remoteiq-frontend\lib\api.ts (934 lines) =====
// Centralized typed API client used by the frontend (Next.js / React).
// It reads NEXT_PUBLIC_API_BASE for the backend base URL.

// ---------------------------- ENV / BASE ------------------------------------
const API_BASE =
  (typeof process !== "undefined" && process.env.NEXT_PUBLIC_API_BASE) || "";

// Utility to join base + path safely
function url(path: string) {
  if (!API_BASE) return path;
  return `${API_BASE.replace(/\/+$/, "")}${path.startsWith("/") ? "" : "/"}${path}`;
}

type JsonInit = Omit<RequestInit, "body" | "method"> & {
  body?: any;
  method?: "GET" | "POST" | "PUT" | "PATCH" | "DELETE";
};

// unified fetch wrapper w/ JSON
export async function jfetch<T>(path: string, init: JsonInit = {}): Promise<T> {
  const { body, ...rest } = init;
  const res = await fetch(url(path), {
    method: init.method ?? (body != null ? "POST" : "GET"),
    credentials: "include",
    headers: {
      "Content-Type": "application/json",
      ...(init.headers ?? {}),
    },
    body: body != null ? JSON.stringify(body) : undefined,
    ...rest,
  });

  if (!res.ok) {
    // try to surface JSON message; fall back to text
    let msg = "";
    try {
      const data = await res.json();
      msg = typeof (data as any)?.message === "string" ? (data as any).message : JSON.stringify(data);
    } catch {
      try {
        msg = await res.text();
      } catch {
        // ignore
      }
    }
    const err = new Error(msg || `Request failed: ${res.status}`);
    (err as any).status = res.status; // preserve status for caller fallbacks
    throw err;
  }

  if (res.status === 204) return undefined as unknown as T;
  try {
    return (await res.json()) as T;
  } catch {
    // when backend returns 200 with empty body
    return undefined as unknown as T;
  }
}

// ---------------------------------------------------------------------------
// Devices (grid + details)
// ---------------------------------------------------------------------------
// lib/api.ts  (only showing the Device type block; keep the rest as-is)
export type Device = {
  id: string;
  hostname: string;
  os: string;
  arch?: string | null;
  lastSeen?: string | null;
  status: "online" | "offline";
  client?: string | null;
  site?: string | null;
  user?: string | string[] | null;
  version?: string | null;      // <-- add
  primaryIp?: string | null;    // <-- add
  /** Optional UUID for the underlying agent (if backend provides it). */
  agentUuid?: string | null;    // <-- NEW (harmless if absent)
};

export type DevicesResponse = {
  items: Device[];
  nextCursor: string | null;
};

export type DeviceFilters = {
  q?: string;
  status?: "online" | "offline";
  os?: string[];
};

export async function fetchDevices(
  pageSize = 25,
  cursor: string | null = null,
  filters?: DeviceFilters
): Promise<DevicesResponse> {
  const sp = new URLSearchParams();
  sp.set("pageSize", String(pageSize));
  if (cursor) sp.set("cursor", cursor);
  if (filters?.q) sp.set("q", filters.q);
  if (filters?.status) sp.set("status", filters.status);
  (filters?.os ?? []).forEach((o) => sp.append("os", o));
  return await jfetch<DevicesResponse>(`/api/devices?${sp.toString()}`);
}

export async function fetchDevice(id: string): Promise<Device> {
  return await jfetch<Device>(`/api/devices/${encodeURIComponent(id)}`);
}

// ---------------------------------------------------------------------------
// Device insights (checks / software)
// ---------------------------------------------------------------------------
export type DeviceCheck = {
  id: string;
  name: string;
  status: "Passing" | "Warning" | "Failing";
  lastRun: string;
  output: string;

  // ----- Optional advanced fields (rendered when present) -----
  /** e.g., "PING","CPU","MEMORY","DISK","SERVICE","PROCESS","PORT","WINEVENT","SOFTWARE","SECURITY","SCRIPT","PATCH","CERT","SMART","RDP","SMB","FIREWALL" */
  type?: string;
  /** severity classification applied to alerting paths */
  severity?: "WARN" | "CRIT";
  /** optional grouping like "Performance", "Security", "Compliance" */
  category?: string;
  /** arbitrary labels */
  tags?: string[];
  /** thresholds used to evaluate this check (key/value) */
  thresholds?: Record<string, any>;
  /** metrics captured by the last run (key/value) */
  metrics?: Record<string, number | string | boolean>;
  /** true if within an active maintenance window */
  maintenance?: boolean;
  /** deduplication key for alert correlation */
  dedupeKey?: string;
};

/** Fetch device-scoped checks; limit is optional and passed to the backend if provided. */
export async function fetchDeviceChecks(
  deviceId: string,
  limit?: number
): Promise<{ items: DeviceCheck[] }> {
  const base = `/api/devices/${encodeURIComponent(deviceId)}/checks`;
  const path = typeof limit === "number" ? `${base}?limit=${encodeURIComponent(String(limit))}` : base;
  return await jfetch(path);
}

export type DeviceSoftware = {
  id: string;
  name: string;
  version: string;
  publisher?: string | null;
  installDate?: string | null;
};

export async function fetchDeviceSoftware(deviceId: string): Promise<{ items: DeviceSoftware[] }> {
  return await jfetch(`/api/devices/${encodeURIComponent(deviceId)}/software`);
}

// ---------------------------------------------------------------------------
// Device actions
// ---------------------------------------------------------------------------
export async function rebootDevice(id: string): Promise<{ accepted: true; jobId: string }> {
  return await jfetch(`/api/devices/${encodeURIComponent(id)}/actions/reboot`, { method: "POST" });
}
export async function patchDevice(id: string): Promise<{ accepted: true; jobId: string }> {
  return await jfetch(`/api/devices/${encodeURIComponent(id)}/actions/patch`, { method: "POST" });
}

// ---------------------------------------------------------------------------
// Automation / Runs
// ---------------------------------------------------------------------------
export type RunScriptRequest = {
  deviceId: string;
  script: string;
  shell?: "powershell" | "bash" | "cmd";
  timeoutSec?: number;
};

export async function postRunScript(req: RunScriptRequest): Promise<{ jobId: string }> {
  return await jfetch(`/api/automation/runs`, { method: "POST", body: req });
}

export type JobSnapshot = {
  jobId: string;
  deviceId: string;
  status: "queued" | "running" | "succeeded" | "failed" | "canceled";
  log: string;
  exitCode?: number | null;
  startedAt: number;
  finishedAt?: number | null;
};

export async function fetchJob(jobId: string): Promise<JobSnapshot> {
  return await jfetch(`/api/automation/runs/${encodeURIComponent(jobId)}`);
}
export async function fetchJobLog(jobId: string): Promise<{ jobId: string; log: string }> {
  return await jfetch(`/api/automation/runs/${encodeURIComponent(jobId)}/log`);
}

// ---------------------------------------------------------------------------
// Admin → Database configuration
// ---------------------------------------------------------------------------
export type DbEngine = "postgresql" | "mysql" | "mssql" | "sqlite" | "mongodb";
export type DbAuthMode = "fields" | "url";
export type StorageDomain =
  | "users" | "roles" | "sessions" | "audit_logs" | "devices" | "policies" | "email_queue";

export type DatabaseMappings = Record<StorageDomain, string>;

export type DatabaseConfig = {
  enabled: boolean;
  engine: DbEngine;
  authMode: DbAuthMode;
  url?: string;
  host?: string;
  port?: number;
  dbName?: string;
  username?: string;
  password?: string;
  ssl: boolean;
  poolMin: number;
  poolMax: number;
  readReplicas?: string;
  mappings: DatabaseMappings;
};

export type DbTestResult = {
  ok: boolean;
  engine: DbEngine;
  primary: { ok: boolean; message?: string };
  replicas?: Array<{ url: string; ok: boolean; message?: string }>;
  note?: string;
};

export async function getDatabaseConfig(): Promise<DatabaseConfig | { enabled: false }> {
  return await jfetch(`/api/admin/database`);
}

export async function testDatabaseConfig(cfg: DatabaseConfig): Promise<DbTestResult> {
  return await jfetch(`/api/admin/database/test`, { method: "POST", body: cfg });
}

export async function saveDatabaseConfig(cfg: DatabaseConfig): Promise<void> {
  await jfetch<void>(`/api/admin/database/save`, { method: "POST", body: cfg });
}

export async function dryRunDatabaseMigration(): Promise<{ ok: true; destructive: false; steps: string[] }> {
  return await jfetch(`/api/admin/database/migrate/dry-run`, { method: "POST" });
}

// --- Company profile (admin) ---
export type CompanyProfile = {
  name: string;
  legalName?: string;
  email?: string;
  phone?: string;
  fax?: string;
  website?: string;
  vatTin?: string;
  address1?: string;
  address2?: string;
  city?: string;
  state?: string;
  postal?: string;
  country?: string;
};

export async function getCompanyProfile(): Promise<CompanyProfile> {
  return await jfetch(`/api/admin/company`);
}

export async function saveCompanyProfile(p: CompanyProfile): Promise<void> {
  await jfetch(`/api/admin/company/save`, { method: "POST", body: p });
}

// --- Localization (admin) ---
export type LocalizationSettings = {
  language: string;                // "en-US"
  dateFormat: string;              // "MM/DD/YYYY"
  timeFormat: "12h" | "24h";       // strictly 12h/24h for UI consistency
  numberFormat: string;            // "1,234.56"
  timeZone: string;                // "America/New_York"
  firstDayOfWeek: "sunday" | "monday";
  currency?: string;               // "USD"
};

export async function getLocalizationSettings(): Promise<LocalizationSettings> {
  const res = await jfetch<LocalizationSettings | { exists: false }>(`/api/admin/localization`);
  if ((res as any)?.exists === false) {
    return {
      language: "en-US",
      dateFormat: "MM/DD/YYYY",
      timeFormat: "12h",
      numberFormat: "1,234.56",
      timeZone: "America/New_York",
      firstDayOfWeek: "sunday",
      currency: "USD",
    };
  }
  // Back-compat: normalize any legacy strings to the union
  const tfRaw = (res as any).timeFormat as string | undefined;
  const timeFormat: "12h" | "24h" = tfRaw === "24h" || tfRaw === "HH:mm" ? "24h" : "12h";
  return { ...(res as LocalizationSettings), timeFormat };
}

export async function saveLocalizationSettings(p: LocalizationSettings): Promise<void> {
  await jfetch(`/api/admin/localization/save`, { method: "POST", body: p });
}

// --- Support & Legal (admin) ---
export type SupportLegalSettings = {
  id?: number;                 // present on GET only
  supportEmail?: string;
  supportPhone?: string;
  knowledgeBaseUrl?: string;
  statusPageUrl?: string;
  privacyPolicyUrl?: string;
  termsUrl?: string;
  gdprContactEmail?: string;
  legalAddress?: string;
  ticketPortalUrl?: string;
  phoneHours?: string;
  notesHtml?: string;
};

export async function getSupportLegalSettings(): Promise<SupportLegalSettings> {
  return await jfetch(`/api/admin/support-legal`);
}

export async function saveSupportLegalSettings(
  p: Omit<SupportLegalSettings, "id">
): Promise<void> {
  await jfetch(`/api/admin/support-legal/save`, { method: "POST", body: p });
}

// ======================= Users & Roles (Admin) =======================
export type RoleDTO = { id: string; name: string };
export type UserDTO = {
  id: string;
  name: string;
  email: string;
  role: string;
  twoFactorEnabled: boolean;
  suspended: boolean;
  lastSeen: string | null;
  status: "active" | "invited" | "suspended";
  createdAt?: string;
  updatedAt?: string;

  // Optional profile fields (present if your DB exposes them)
  phone?: string | null;
  address1?: string | null;
  address2?: string | null;
  city?: string | null;
  state?: string | null;
  postal?: string | null;
  country?: string | null;
};

export async function getAdminRoles(): Promise<{ items: RoleDTO[] }> {
  // Wrap server response (array) into {items} for consistency
  const arr = await jfetch<RoleDTO[]>(`/api/admin/users/roles`);
  return { items: arr };
}

export async function getAdminUsers(): Promise<{ items: UserDTO[]; total?: number }> {
  // backend returns {items, total}
  return await jfetch(`/api/admin/users`);
}

export type InvitePayload = { name?: string; email: string; role?: string; message?: string };

/** Invite one-by-one under the hood to keep types simple */
export async function inviteUsers(invites: InvitePayload[]): Promise<{ created: UserDTO[] }> {
  const created: UserDTO[] = [];
  for (const i of invites) {
    const resp = await jfetch<{ id: string }>(`/api/admin/users/invite`, {
      method: "POST",
      body: i,
    });
    created.push({
      id: resp.id,
      name: i.name ?? i.email.split("@")[0],
      email: i.email,
      role: i.role ?? "User",
      status: "invited",
      twoFactorEnabled: false,
      suspended: false,
      lastSeen: null,
    });
  }
  return { created };
}

/** Change a user's role */
export async function updateUserRole(userId: string, role: string): Promise<void> {
  await jfetch<void>(`/api/admin/users/${encodeURIComponent(userId)}/role`, {
    method: "PATCH",
    body: { role },
  });
}

/** Trigger a 2FA reset */
export async function resetUser2FA(userId: string): Promise<void> {
  await jfetch<void>(`/api/admin/users/${encodeURIComponent(userId)}/reset-2fa`, {
    method: "POST",
  });
}

/** Remove (delete) a user */
export async function removeUser(userId: string): Promise<void> {
  await jfetch<void>(`/api/admin/users/${encodeURIComponent(userId)}`, {
    method: "DELETE",
  });
}

/** Suspend / Unsuspend user */
export async function setUserSuspended(userId: string, suspended: boolean): Promise<void> {
  await jfetch<void>(`/api/admin/users/${encodeURIComponent(userId)}/suspend`, {
    method: "POST",
    body: { suspended },
  });
}

/* -------- Admin create + reset password -------- */
export type CreateUserPayload = {
  name: string;
  email: string;
  role?: string;
  password: string;
  status?: "active" | "invited" | "suspended";
};

export async function createAdminUser(p: CreateUserPayload): Promise<{ id: string }> {
  return await jfetch(`/api/admin/users/create`, { method: "POST", body: p });
}

export async function setUserPassword(userId: string, password: string): Promise<void> {
  await jfetch(`/api/admin/users/${encodeURIComponent(userId)}/password`, {
    method: "POST",
    body: { password },
  });
}

/* -------- NEW: Update user details (partial) -------- */
export type UpdateUserPayload = Partial<{
  name: string;
  email: string;
  role: string;
  phone: string;
  address1: string;
  address2: string;
  city: string;
  state: string;
  postal: string;
  country: string;
}>;

export async function updateUser(userId: string, p: UpdateUserPayload): Promise<void> {
  await jfetch<void>(`/api/admin/users/${encodeURIComponent(userId)}`, {
    method: "PATCH",
    body: p,
  });
}

// ---------------------------------------------------------------------------
// Account (current user) - Profile
// ---------------------------------------------------------------------------
export type MeProfile = {
  id: string;
  name: string;
  email: string;
  username?: string;
  phone?: string | null;
  address1?: string | null;
  address2?: string | null;
  city?: string | null;
  state?: string | null;
  postal?: string | null;
  country?: string | null;
  timezone?: string | null;
  locale?: string | null;
  avatarUrl?: string | null; // backend may store as avatar_url; mapped server-side
  createdAt?: string;
  updatedAt?: string;
};

export type UpdateMePayload = Partial<{
  name: string;
  email: string;
  username: string;
  phone: string | null;
  address1: string | null;
  address2: string | null;
  city: string | null;
  state: string | null;
  postal: string | null;
  country: string | null;
  timezone: string | null;
  locale: string | null;
  avatarUrl: string | null;
}>;

/** Load the signed-in user's profile */
export async function getMyProfile(): Promise<MeProfile> {
  return await jfetch<MeProfile>(`/api/users/me`);
}

/** Patch the signed-in user's profile (only sends provided keys) */
export async function updateMyProfile(patch: UpdateMePayload): Promise<MeProfile> {
  const body = Object.fromEntries(Object.entries(patch).filter(([, v]) => v !== undefined));
  return await jfetch<MeProfile>(`/api/users/me`, { method: "PATCH", body });
}

// ---------------------------------------------------------------------------
// Account (current user) - Security & Sessions (legacy helpers kept)
// ---------------------------------------------------------------------------
export type SecuritySettings = {
  twoFaEnabled: boolean;
  autoRevokeSessions?: boolean;
};

export async function getSecuritySettings(): Promise<SecuritySettings> {
  return await jfetch(`/api/users/security`);
}
export async function saveSecuritySettings(p: Partial<SecuritySettings>): Promise<void> {
  await jfetch(`/api/users/security`, { method: "PATCH", body: p });
}

export type SessionDTO = {
  id: string;
  device: string;
  ip: string;
  lastActive: string;
  current: boolean;
  city?: string;
  isp?: string;
  trusted?: boolean;
};

export async function listSessions(): Promise<{ items: SessionDTO[] }> {
  return await jfetch(`/api/users/sessions`);
}
export async function toggleTrustSession(sessionId: string, trusted: boolean): Promise<void> {
  await jfetch(`/api/users/sessions/${encodeURIComponent(sessionId)}/trust`, {
    method: "POST",
    body: { trusted },
  });
}
export async function revokeSession(sessionId: string): Promise<void> {
  await jfetch(`/api/users/sessions/${encodeURIComponent(sessionId)}`, { method: "DELETE" });
}
export async function revokeAllSessions(): Promise<void> {
  await jfetch(`/api/users/sessions`, { method: "DELETE" });
}

// ---------------------------------------------------------------------------
// Account (current user) - Notifications
// ---------------------------------------------------------------------------
export type NotificationSettings = {
  email: boolean;
  push: boolean;
  product: boolean;
  digest: "off" | "daily" | "weekly";
  quiet?: { enabled: boolean; start?: string; end?: string };
  products?: string[];
};

export async function getNotificationSettings(): Promise<NotificationSettings> {
  return await jfetch(`/api/users/notifications`);
}
export async function saveNotificationSettings(p: Partial<NotificationSettings>): Promise<void> {
  await jfetch(`/api/users/notifications`, { method: "PATCH", body: p });
}

// ---------------------------------------------------------------------------
// Account (current user) - Integrations (Slack + generic webhook)
// ---------------------------------------------------------------------------
export type IntegrationsSettings = {
  slackWebhook?: string;
  webhookUrl?: string;
  webhookSigningSecret?: string;
  events?: string[];
};

export async function getIntegrationsSettings(): Promise<IntegrationsSettings> {
  return await jfetch(`/api/users/integrations`);
}
export async function saveIntegrationsSettings(p: Partial<IntegrationsSettings>): Promise<void> {
  await jfetch(`/api/users/integrations`, { method: "PATCH", body: p });
}

export async function testSlackWebhook(urlStr: string): Promise<{ ok: boolean; status: number; ms?: number }> {
  return await jfetch(`/api/users/integrations/test/slack`, { method: "POST", body: { url: urlStr } });
}
export async function testGenericWebhook(urlStr: string): Promise<{ ok: boolean; status: number; ms?: number }> {
  return await jfetch(`/api/users/integrations/test/webhook`, { method: "POST", body: { url: urlStr } });
}
export async function rotateSigningSecret(): Promise<{ secret: string }> {
  return await jfetch(`/api/users/integrations/rotate-signing-secret`, { method: "POST" });
}

// ---------------------------------------------------------------------------
// Account (current user) - API Keys
// ---------------------------------------------------------------------------
export type ApiKeyDTO = {
  id: string;          // token id (e.g., "rk_live_xxx")
  label: string;
  lastUsed?: string;
  scopes?: string[];
  expiresAt?: string;  // iso or empty string if never
};

export async function listApiKeys(): Promise<{ items: ApiKeyDTO[] }> {
  const arr = await jfetch<ApiKeyDTO[]>(`/api/users/api-keys`);
  return { items: arr };
}

export async function createApiKey(
  label: string,
  scopes: string[],
  expiresIn: "never" | "30d" | "90d",
  ipAllowlist?: string
): Promise<ApiKeyDTO> {
  return await jfetch(`/api/users/api-keys`, {
    method: "POST",
    body: { label, scopes, expiresIn, ipAllowlist },
  });
}

export async function revokeApiKey(id: string): Promise<void> {
  await jfetch(`/api/users/api-keys/${encodeURIComponent(id)}`, { method: "DELETE" });
}

export async function regenerateApiKey(id: string): Promise<{ oldId: string; newKey: string }> {
  return await jfetch(`/api/users/api-keys/${encodeURIComponent(id)}/regenerate`, { method: "POST" });
}

// Upload avatar to the dedicated endpoint
export async function uploadMyAvatar(file: File): Promise<{ url: string }> {
  const form = new FormData();
  form.append("file", file, file.name || "avatar.png");

  const base = (typeof process !== "undefined" && process.env.NEXT_PUBLIC_API_BASE) || "";
  const res = await fetch(`${base.replace(/\/+$/, "")}/api/users/me/avatar`, {
    method: "POST",
    credentials: "include",
    body: form,
  });
  if (!res.ok) {
    let msg = "";
    try { msg = (await res.json())?.message || ""; } catch { }
    if (!msg) try { msg = await res.text(); } catch { }
    throw new Error(msg || `Upload failed (${res.status})`);
  }
  return (await res.json()) as { url: string };
}

export async function removeMyAvatar(): Promise<void> {
  await jfetch<void>(`/api/users/me/avatar`, { method: "DELETE" });
}

/* ============================================================================
   NEW: Security Overview + TOTP + Sessions (ME scope) + PAT + WebAuthn stubs
   ==========================================================================*/

// ---- Types used by the Security tab ----
export type SecurityEvent = {
  id: string;
  type:
  | "signed_in"
  | "password_changed"
  | "2fa_enabled"
  | "2fa_disabled"
  | "recovery_codes_regenerated"
  | "session_revoked";
  at: string;
  ip?: string;
  userAgent?: string;
};

export type WebAuthnCredential = {
  id: string;
  label: string;
  createdAt: string;
  lastUsedAt?: string;
};

export type RecoveryCodes = string[];

// ---- Sessions (ME) ----
export type Session = {
  id: string;
  createdAt: string;
  lastSeenAt: string | null;
  ip: string | null;
  userAgent: string | null;
  current: boolean;
  trusted?: boolean;
  label?: string | null;
  revokedAt?: string | null; // <-- include so we can filter locally
};

export type SecurityOverview = {
  twoFactorEnabled: boolean;
  sessions: Session[];
  events: SecurityEvent[];
  webAuthn?: WebAuthnCredential[];
};

export type TOTPInit = { secret: string; otpauthUrl: string; qrPngDataUrl: string };

// ---- Overview ----
export async function getSecurityOverview(): Promise<SecurityOverview> {
  return await jfetch<SecurityOverview>(`/api/users/me/security`);
}

// ---- Change Password ----
export async function changePasswordSelf(current: string, next: string): Promise<void> {
  await jfetch(`/api/users/me/password`, { method: "POST", body: { current, next } });
}

// ---- TOTP 2FA ----
export async function start2FA(): Promise<TOTPInit> {
  return await jfetch<TOTPInit>(`/api/users/me/2fa/start`, { method: "POST" });
}

export async function confirm2FA(p: { code: string }): Promise<void> {
  await jfetch(`/api/users/me/2fa/confirm`, { method: "POST", body: p });
}

export async function disable2FA(p?: { code?: string; recoveryCode?: string }): Promise<void> {
  await jfetch(`/api/users/me/2fa/disable`, { method: "POST", body: p ?? {} });
}

export async function regenerateRecoveryCodes(): Promise<RecoveryCodes> {
  const res = await jfetch<{ recoveryCodes: string[] }>(`/api/users/me/2fa/recovery/regen`, {
    method: "POST",
  });
  return res.recoveryCodes;
}

// ---- Sessions (ME) ----
// NOTE: some servers include revoked sessions in the list; we filter them out.
export async function listMySessions(): Promise<{ items: Session[]; currentJti?: string }> {
  const res = await jfetch<{ items: Session[]; currentJti?: string }>(`/api/users/me/sessions/`);
  const items = (res.items ?? []).filter((s) => !s.revokedAt); // <-- hide revoked
  return { items, currentJti: res.currentJti };
}

export async function revokeAllOtherSessions(): Promise<void> {
  await jfetch(`/api/users/me/sessions/revoke-all`, { method: "POST" });
}

/**
 * Revoke a single session (ME).
 * Tries a sequence of plausible endpoints so we work with whatever the backend exposes.
 */
export async function revokeMySession(sessionId: string): Promise<void> {
  const enc = encodeURIComponent(sessionId);
  const base = `/api/users/me/sessions/${enc}`;

  // 1) Preferred: DELETE /me/sessions/:id
  try {
    await jfetch(base, { method: "DELETE" });
    return;
  } catch (e: any) {
    const msg = String(e?.message || "").toLowerCase();
    const status = e?.status ?? e?.code;
    if (!(status === 404 || status === 405 || msg.includes("cannot delete"))) throw e;
  }

  // 2) Alt: POST /me/sessions/:id/revoke
  try {
    await jfetch(`${base}/revoke`, { method: "POST" });
    return;
  } catch (e: any) {
    const status = e?.status ?? e?.code;
    if (!(status === 404 || status === 405)) throw e;
  }

  // 3) Alt: POST /me/sessions/revoke  { sessionId }
  try {
    await jfetch(`/api/users/me/sessions/revoke`, { method: "POST", body: { sessionId } });
    return;
  } catch (e: any) {
    const status = e?.status ?? e?.code;
    if (!(status === 404 || status === 405)) throw e;
  }

  // 4) Alt: POST /me/sessions/revoke/:id
  try {
    await jfetch(`/api/users/me/sessions/revoke/${enc}`, { method: "POST" });
    return;
  } catch (e: any) {
    const status = e?.status ?? e?.code;
    if (!(status === 404 || status === 405)) throw e;
  }

  // 5) Last-resort: PATCH /me/sessions/:id { action: "revoke" }
  await jfetch(base, { method: "PATCH", body: { action: "revoke" } });
}

/** Trust / untrust a session (ME) with fallbacks similar to revoke */
export async function trustMySession(
  sessionId: string,
  trusted: boolean
): Promise<{ trusted: boolean }> {
  const enc = encodeURIComponent(sessionId);
  const base = `/api/users/me/sessions/${enc}`;

  // 1) Preferred: POST /me/sessions/:id/trust { trusted }
  try {
    return await jfetch(`${base}/trust`, { method: "POST", body: { trusted } });
  } catch (e: any) {
    const status = e?.status ?? e?.code;
    if (!(status === 404 || status === 405)) throw e;
  }

  // 2) Alt: POST /me/sessions/trust { sessionId, trusted }
  try {
    return await jfetch(`/api/users/me/sessions/trust`, {
      method: "POST",
      body: { sessionId, trusted },
    });
  } catch (e: any) {
    const status = e?.status ?? e?.code;
    if (!(status === 404 || status === 405)) throw e;
  }

  // 3) Last-resort: PATCH /me/sessions/:id { trusted }
  return await jfetch(base, { method: "PATCH", body: { trusted } });
}

/** Optional: label a session (ME) */
export async function labelMySession(sessionId: string, label: string): Promise<void> {
  await jfetch(`/api/users/me/sessions/${encodeURIComponent(sessionId)}/label`, {
    method: "POST",
    body: { label },
  });
}

// lib/api.ts → mapMeSessionToDTO
export function mapMeSessionToDTO(s: Session): SessionDTO {
  return {
    id: s.id,
    device: s.label || s.userAgent || "Unknown device",
    ip: s.ip ?? "",                 // string (never undefined)
    lastActive: s.lastSeenAt ?? "", // string (never undefined)
    current: !!s.current,           // boolean
    city: undefined,
    isp: undefined,
    trusted: s.trusted ?? false,
  };
}


// ---- Personal Tokens (ME) ----
export type PersonalToken = {
  id: string;
  name: string;
  createdAt: string;
  lastUsedAt?: string;
  revokedAt?: string;
};

export async function listMyTokens(): Promise<{ items: PersonalToken[] }> {
  return await jfetch(`/api/users/me/tokens`);
}

export async function createMyToken(name: string): Promise<{ token: string; id: string }> {
  return await jfetch(`/api/users/me/tokens`, { method: "POST", body: { name } });
}

export async function revokeMyToken(id: string): Promise<void> {
  await jfetch(`/api/users/me/tokens/revoke`, { method: "POST", body: { id } });
}

// ---- WebAuthn (optional / stubbed) ----
export async function webauthnCreateOptions(): Promise<PublicKeyCredentialCreationOptions> {
  return await jfetch(`/api/users/me/webauthn/create-options`);
}

export async function webauthnFinishRegistration(attestationResponse: any): Promise<WebAuthnCredential> {
  return await jfetch(`/api/users/me/webauthn/finish`, { method: "POST", body: attestationResponse });
}

export async function deleteWebAuthnCredential(id: string): Promise<void> {
  return await jfetch(`/api/users/me/webauthn/${encodeURIComponent(id)}`, { method: "DELETE" });
}

// --- Device software: request uninstall --------------------------------
export async function requestUninstallSoftware(
  deviceId: string,
  body: { name: string; version?: string }
): Promise<{ accepted: true; jobId?: string }> {
  const res = await fetch(
    `${((typeof process !== "undefined" && process.env.NEXT_PUBLIC_API_BASE) || "").replace(/\/+$/, "")}/api/devices/${encodeURIComponent(deviceId)}/actions/uninstall`,
    {
      method: "POST",
      credentials: "include",
      headers: { "Content-Type": "application/json" },
      body: JSON.stringify(body),
    }
  );

  if (!res.ok) {
    // surface error text
    let msg = "";
    try { msg = (await res.clone().json())?.message || ""; } catch { }
    if (!msg) try { msg = await res.text(); } catch { }
    throw new Error(msg || `Request failed: ${res.status}`);
  }

  // Try JSON first
  let jobId: string | undefined;
  try {
    const json = await res.clone().json();
    jobId = json?.jobId;
  } catch {
    /* no json body */
  }

  // Fallback: parse Location header (e.g. /api/automation/runs/<uuid>)
  if (!jobId) {
    const loc = res.headers.get("Location") || res.headers.get("location");
    const m = loc?.match(/([0-9a-fA-F-]{8}-[0-9a-fA-F-]{4}-[1-5][0-9a-fA-F-]{3}-[89abAB][0-9a-fA-F-]{3}-[0-9a-fA-F-]{12})$/);
    if (m) jobId = m[1];
  }

  return { accepted: true, jobId };
}

===== END FILE remoteiq-frontend\lib\api.ts =====

===== FILE: remoteiq-frontend\lib\ws.ts (28 lines) =====
// lib/ws.ts
type Listener = (msg: any) => void;

let socket: WebSocket | null = null;
const listeners = new Set<Listener>();

export function ensureSocket(): WebSocket {
  const base = process.env.NEXT_PUBLIC_WS_BASE || "ws://localhost:3001/ws";
  if (socket && (socket.readyState === WebSocket.OPEN || socket.readyState === WebSocket.CONNECTING)) {
    return socket;
  }
  socket = new WebSocket(base);
  socket.onmessage = (ev) => {
    try {
      const data = JSON.parse(ev.data);
      for (const cb of Array.from(listeners)) cb(data);
    } catch {
      // ignore malformed frames
    }
  };
  return socket;
}

export function onWsMessage(cb: Listener) {
  listeners.add(cb);
  return () => listeners.delete(cb);
}

===== END FILE remoteiq-frontend\lib\ws.ts =====

===== FILE: remoteiq-frontend\components\checks-and-alerts-tab.tsx (986 lines) =====
// components/checks-and-alerts-tab.tsx
"use client";

import * as React from "react";
import { useParams } from "next/navigation";
import {
    Card, CardHeader, CardTitle, CardDescription, CardContent,
} from "@/components/ui/card";
import {
    Table, TableHeader, TableRow, TableHead, TableBody, TableCell,
} from "@/components/ui/table";
import { AlertTriangle, CheckCircle2, OctagonX, Info, Search, Filter, Ban, Download, Play } from "lucide-react";
import { fetchDeviceChecks, type DeviceCheck } from "@/lib/api";
import { Input } from "@/components/ui/input";
import { Button } from "@/components/ui/button";
import { Badge } from "@/components/ui/badge";
import { Tooltip, TooltipContent, TooltipProvider, TooltipTrigger } from "@/components/ui/tooltip";
import { Separator } from "@/components/ui/separator";
import { Sheet, SheetContent, SheetDescription, SheetHeader, SheetTitle } from "@/components/ui/sheet";
import { Popover, PopoverContent, PopoverTrigger } from "@/components/ui/popover";
import { Checkbox } from "@/components/ui/checkbox";
import { Tabs, TabsContent, TabsList, TabsTrigger } from "@/components/ui/tabs";

/* --------------------------- palette + glyphs --------------------------- */
type CheckStatus = "Passing" | "Failing" | "Warning";
const STATUS_META: Record<
    CheckStatus,
    {
        icon: React.ComponentType<React.SVGProps<SVGSVGElement>>;
        text: string;
        chipBg: string;
        ring: string;
        badgeBg: string;
        badgeText: string;
    }
> = {
    Passing: {
        icon: CheckCircle2,
        text: "text-emerald-500",
        chipBg: "bg-emerald-500/15",
        ring: "ring-emerald-500/25",
        badgeBg: "bg-emerald-500",
        badgeText: "text-white",
    },
    Warning: {
        icon: AlertTriangle,
        text: "text-amber-500",
        chipBg: "bg-amber-500/15",
        ring: "ring-amber-500/25",
        badgeBg: "bg-amber-500",
        badgeText: "text-black",
    },
    Failing: {
        icon: OctagonX,
        text: "text-red-500",
        chipBg: "bg-red-500/15",
        ring: "ring-red-500/25",
        badgeBg: "bg-red-500",
        badgeText: "text-white",
    },
};

function StatusGlyph({
    status,
    size = 18,
    className = "",
}: {
    status: CheckStatus;
    size?: number;
    className?: string;
}) {
    const s = STATUS_META[status];
    const Icon = s.icon;
    return (
        <span
            className={[
                "inline-flex items-center justify-center rounded-md p-1 ring-1",
                s.chipBg,
                s.ring,
                className,
            ].join(" ")}
            aria-hidden="true"
        >
            <Icon width={size} height={size} className={s.text} />
        </span>
    );
}

function StatusCountBadge({
    status,
    children,
    title,
    size = "md",
}: {
    status: CheckStatus;
    children: React.ReactNode;
    title?: string;
    size?: "sm" | "md" | "lg";
}) {
    const s = STATUS_META[status];
    const sizeClasses =
        size === "lg"
            ? "h-8 min-w-[2.25rem] px-2.5 text-sm font-semibold"
            : size === "sm"
                ? "h-5 min-w-[1.25rem] px-1.5 text-[11px]"
                : "h-6 min-w-[1.5rem] px-2 text-xs font-medium";
    return (
        <span
            title={title}
            className={[
                "inline-flex items-center justify-center rounded-full",
                sizeClasses,
                s.badgeBg,
                s.badgeText,
                "shadow-sm ring-1 ring-black/5 dark:ring-white/5",
            ].join(" ")}
        >
            {children}
        </span>
    );
}

/* ------------------------------- types (UI) ------------------------------- */
type Severity = "WARN" | "CRIT";
type CheckType =
    | "PING" | "CPU" | "MEMORY" | "DISK" | "SERVICE" | "PROCESS" | "PORT" | "WINEVENT"
    | "SOFTWARE" | "SECURITY" | "SCRIPT" | "PATCH" | "CERT" | "SMART" | "RDP" | "SMB" | "FIREWALL";

type AugmentedDeviceCheck = DeviceCheck & {
    type?: CheckType;
    severity?: Severity;
    category?: string;
    tags?: string[];
    thresholds?: Record<string, any>;
    metrics?: Record<string, number | string | boolean>;
    maintenance?: boolean;
    dedupeKey?: string;
};

/* ------------------------------- utilities ------------------------------- */

function formatWhen(iso?: string) {
    if (!iso) return "";
    const d = new Date(iso);
    if (Number.isNaN(+d)) return iso;
    return d.toLocaleString();
}

function truncate(str: string, max = 160) {
    if (!str) return "";
    return str.length > max ? `${str.slice(0, max)}…` : str;
}

function toCSV(items: AugmentedDeviceCheck[]) {
    const cols = [
        "id", "name", "status", "type", "severity",
        "category", "lastRun", "maintenance", "dedupeKey", "output",
    ];
    const esc = (v: any) => {
        if (v == null) return "";
        const s = String(v);
        if (s.includes(",") || s.includes("\"") || s.includes("\n")) {
            return `"${s.replace(/"/g, '""')}"`;
        }
        return s;
    };
    const header = cols.join(",");
    const lines = items.map((it) =>
        [
            it.id, it.name, it.status, (it as any).type ?? "", (it as any).severity ?? "",
            (it as any).category ?? "", it.lastRun ?? "", (it as any).maintenance ?? "",
            (it as any).dedupeKey ?? "", it.output ?? "",
        ].map(esc).join(",")
    );
    return [header, ...lines].join("\n");
}

/* ------------------------------ WS utilities ------------------------------ */

type UiWsIncoming =
    | { t: "welcome" }
    | { t: "device_checks_updated"; deviceId: string; changed?: number; at?: string }
    | { t: "error"; message: string }
    | { t: "pong" };

function makeWsUrl(path = "/ws") {
    const proto = typeof window !== "undefined" && window.location.protocol === "https:" ? "wss" : "ws";
    const host = typeof window !== "undefined" ? window.location.host : "";
    return `${proto}://${host}${path}`;
}

/* -------------------------------- component ------------------------------- */

export default function ChecksAndAlertsTab() {
    const params = useParams<{ deviceId: string }>();
    const deviceId = params?.deviceId;

    const [items, setItems] = React.useState<AugmentedDeviceCheck[]>([]);
    const [loading, setLoading] = React.useState(false);
    const [error, setError] = React.useState<string | null>(null);

    // client-side UI aids
    const [q, setQ] = React.useState("");
    const [statusFilter, setStatusFilter] = React.useState<"all" | CheckStatus>("all");
    const [severityFilter, setSeverityFilter] = React.useState<"all" | Severity>("all");
    const [typeFilter, setTypeFilter] = React.useState<"all" | CheckType>("all");
    const [selected, setSelected] = React.useState<AugmentedDeviceCheck | null>(null);
    const [selectedIds, setSelectedIds] = React.useState<Set<string>>(new Set());

    // WS refs
    const wsRef = React.useRef<WebSocket | null>(null);
    const retryRef = React.useRef<number>(1000); // backoff ms
    const pingTimerRef = React.useRef<number | null>(null);
    const reconnectTimerRef = React.useRef<number | null>(null);
    const debounceFetchTimerRef = React.useRef<number | null>(null);
    const subscribedDeviceRef = React.useRef<string | null>(null);
    const connectWsRef = React.useRef<null | (() => void)>(null);

    const isVisible = () =>
        typeof document !== "undefined" ? document.visibilityState !== "hidden" : true;

    const clearTimer = (ref: React.MutableRefObject<number | null>) => {
        if (ref.current) {
            window.clearTimeout(ref.current);
            ref.current = null;
        }
    };

    // ✅ Memoized stop/start heartbeat
    const stopHeartbeat = React.useCallback(() => {
        clearTimer(pingTimerRef);
    }, []);

    const startHeartbeat = React.useCallback(() => {
        stopHeartbeat();
        // Send ping every 25s to keep idle proxies happy
        pingTimerRef.current = window.setTimeout(function tick() {
            try {
                wsRef.current?.send(JSON.stringify({ t: "ping", at: new Date().toISOString() }));
            } catch { /* ignore */ }
            pingTimerRef.current = window.setTimeout(tick, 25_000) as unknown as number;
        }, 25_000) as unknown as number;
    }, [stopHeartbeat]);

    // ✅ Memoized reconnect scheduler using a ref to avoid circular deps
    const scheduleReconnect = React.useCallback(() => {
        clearTimer(reconnectTimerRef);
        const delay = Math.min(retryRef.current, 25_000);
        reconnectTimerRef.current = window.setTimeout(() => {
            connectWsRef.current?.(); // call latest connectWs
            retryRef.current = Math.min(retryRef.current * 2, 25_000);
        }, delay) as unknown as number;
    }, []);

    // Stable, memoized safe close
    const safeCloseWs = React.useCallback(() => {
        try { wsRef.current?.close(); } catch { /* ignore */ }
        wsRef.current = null;
        stopHeartbeat();
    }, [stopHeartbeat]);

    // Subscribe helper (no need to memoize)
    const subscribeDevice = (id: string | null | undefined) => {
        const target = id ? String(id) : null;
        if (!wsRef.current || wsRef.current.readyState !== WebSocket.OPEN) return;
        if (!target) return;
        if (subscribedDeviceRef.current === target) return;
        subscribedDeviceRef.current = target;
        try {
            wsRef.current.send(JSON.stringify({ t: "subscribe_device", deviceId: target }));
        } catch { /* ignore */ }
    };

    // ✅ Memoized incoming handler
    const refetchChecks = React.useCallback(async () => {
        if (!deviceId) return;
        try {
            setLoading(true);
            setError(null);
            const { items } = await fetchDeviceChecks(deviceId);
            setItems((items ?? []) as AugmentedDeviceCheck[]);
        } catch (e: any) {
            setError(e?.message ?? "Failed to load checks");
        } finally {
            setLoading(false);
        }
    }, [deviceId]);

    const handleIncoming = React.useCallback((raw: MessageEvent<string>) => {
        let msg: UiWsIncoming | null = null;
        try {
            msg = JSON.parse(raw.data) as UiWsIncoming;
        } catch {
            return;
        }
        if (!msg || typeof (msg as any).t !== "string") return;

        switch (msg.t) {
            case "welcome": {
                subscribeDevice(deviceId);
                break;
            }
            case "device_checks_updated": {
                if (!deviceId || msg.deviceId !== String(deviceId)) return;
                if (debounceFetchTimerRef.current) window.clearTimeout(debounceFetchTimerRef.current);
                debounceFetchTimerRef.current = window.setTimeout(async () => {
                    await refetchChecks();
                }, 500) as unknown as number;
                break;
            }
            case "pong": {
                break;
            }
            case "error": {
                // eslint-disable-next-line no-console
                console.warn("[UI WS] error:", (msg as any).message);
                break;
            }
            default:
                break;
        }
    }, [deviceId, refetchChecks]);

    // ✅ Memoized connect using memoized deps; store to ref for scheduler
    const connectWs = React.useCallback(() => {
        if (!isVisible()) return; // don't connect while tab hidden
        try {
            safeCloseWs();
            const url = makeWsUrl("/ws");
            const ws = new WebSocket(url);
            wsRef.current = ws;

            ws.addEventListener("open", () => {
                retryRef.current = 1000; // reset backoff
                startHeartbeat();
                try {
                    ws.send(JSON.stringify({ t: "ui_hello" }));
                } catch { /* ignore */ }
                subscribeDevice(deviceId);
            });

            ws.addEventListener("message", handleIncoming);
            ws.addEventListener("close", () => {
                stopHeartbeat();
                scheduleReconnect();
            });
            ws.addEventListener("error", () => {
                try { ws.close(); } catch { /* ignore */ }
            });
        } catch {
            scheduleReconnect();
        }
    }, [deviceId, handleIncoming, safeCloseWs, scheduleReconnect, startHeartbeat, stopHeartbeat]);

    // Keep the latest connectWs in a ref (used by scheduleReconnect)
    React.useEffect(() => {
        connectWsRef.current = connectWs;
    }, [connectWs]);

    /* ----------------------------- initial data load ----------------------------- */

    React.useEffect(() => {
        let alive = true;
        (async () => {
            if (!deviceId) return;
            setLoading(true); setError(null);
            try {
                const { items } = await fetchDeviceChecks(deviceId);
                if (!alive) return;
                setItems((items ?? []) as AugmentedDeviceCheck[]);
            } catch (e: any) {
                if (!alive) return;
                setError(e?.message ?? "Failed to load checks");
            } finally {
                if (alive) setLoading(false);
            }
        })();
        return () => { alive = false; };
    }, [deviceId]);

    /* ----------------------------- ws lifecycle & vis ---------------------------- */

    React.useEffect(() => {
        // Initial connect
        connectWs();

        // Re-subscribe when deviceId changes
        if (deviceId) subscribeDevice(deviceId);

        // Visibility handling (pause connections while hidden)
        const onVis = () => {
            if (isVisible()) {
                connectWsRef.current?.();
            } else {
                // optional: could safeCloseWs() to save resources
            }
        };
        document.addEventListener("visibilitychange", onVis);

        return () => {
            document.removeEventListener("visibilitychange", onVis);
            clearTimer(reconnectTimerRef);
            clearTimer(pingTimerRef);
            clearTimer(debounceFetchTimerRef);
            safeCloseWs();
        };
    }, [deviceId, connectWs, safeCloseWs]);

    // counts
    const failingChecks = items.filter((c) => c.status === "Failing").length;
    const warningChecks = items.filter((c) => c.status === "Warning").length;

    // derive type list for filter menu
    const allTypes = React.useMemo(() => {
        const t = new Set<string>();
        for (const it of items) if ((it as any).type) t.add((it as any).type as string);
        return Array.from(t).sort();
    }, [items]);

    // filtered view
    const filtered = items
        .filter((c) => (statusFilter === "all" ? true : c.status === statusFilter))
        .filter((c) => (severityFilter === "all" ? true : (c as any).severity === severityFilter))
        .filter((c) => (typeFilter === "all" ? true : (c as any).type === typeFilter))
        .filter((c) => {
            if (!q.trim()) return true;
            const hay = [
                c.name, c.output ?? "", (c as any).type ?? "", (c as any).category ?? "",
                Object.entries((c as any).metrics ?? {}).map(([k, v]) => `${k}:${v}`).join(" "),
                Object.entries((c as any).thresholds ?? {}).map(([k, v]) => `${k}:${v}`).join(" "),
                ((c as any).tags ?? []).join(" "),
            ].join(" ").toLowerCase();
            return hay.includes(q.toLowerCase());
        })
        .sort((a, b) => {
            const da = (a.lastRun ? +new Date(a.lastRun) : 0);
            const db = (b.lastRun ? +new Date(b.lastRun) : 0);
            return db - da;
        });

    const allSelected = filtered.length > 0 && filtered.every((r) => selectedIds.has(r.id));
    const toggleSelectAll = (checked: boolean) => {
        const next = new Set(selectedIds);
        if (checked) filtered.forEach((r) => next.add(r.id));
        else filtered.forEach((r) => next.delete(r.id));
        setSelectedIds(next);
    };
    const toggleRow = (id: string, on: boolean) => {
        const next = new Set(selectedIds);
        if (on) next.add(id); else next.delete(id);
        setSelectedIds(next);
    };

    // CSV export
    const exportCSV = () => {
        const csv = toCSV(filtered);
        const blob = new Blob([csv], { type: "text/csv;charset=utf-8" });
        const url = URL.createObjectURL(blob);
        const a = document.createElement("a");
        a.href = url;
        a.download = `device-checks-${deviceId ?? "unknown"}.csv`;
        a.click();
        URL.revokeObjectURL(url);
    };

    // NOTE: Bulk actions are UI-only for now (backend endpoints pending)
    const bulkAck = () => { /* wire to /api/alerts/bulk when ready */ };
    const bulkSilence = () => { /* wire to /api/alerts/bulk when ready */ };
    const bulkResolve = () => { /* wire to /api/alerts/bulk when ready */ };
    const runNow = (id: string) => { /* wire to /api/check-assignments/:id/run or /api/checks/:id/run */ };

    return (
        <TooltipProvider>
            <div className="grid gap-6">
                <div className="grid md:grid-cols-2 gap-6">
                    {/* Active Alerts */}
                    <Card>
                        <CardHeader>
                            <CardTitle>Active Alerts</CardTitle>
                            <CardDescription>A summary of checks that require attention.</CardDescription>
                        </CardHeader>
                        <CardContent className="grid gap-4">
                            {/* Failing */}
                            <div className="flex items-center justify-between p-4 rounded-lg ring-1 ring-red-500/25 bg-red-500/10">
                                <div className="flex items-center gap-4">
                                    <StatusGlyph status="Failing" className="scale-110" />
                                    <div>
                                        <p className="font-semibold">
                                            {failingChecks} Failing Check{failingChecks !== 1 && "s"}
                                        </p>
                                        <p className="text-sm text-muted-foreground">Immediate attention required.</p>
                                    </div>
                                </div>
                                <StatusCountBadge status="Failing" size="lg" title="Failing count">
                                    {failingChecks}
                                </StatusCountBadge>
                            </div>

                            {/* Warning */}
                            <div className="flex items-center justify-between p-4 rounded-lg ring-1 ring-amber-500/25 bg-amber-500/10">
                                <div className="flex items-center gap-4">
                                    <StatusGlyph status="Warning" className="scale-110" />
                                    <div>
                                        <p className="font-semibold">
                                            {warningChecks} Warning Check{warningChecks !== 1 && "s"}
                                        </p>
                                        <p className="text-sm text-muted-foreground">Potential issues detected.</p>
                                    </div>
                                </div>
                                <StatusCountBadge status="Warning" size="lg" title="Warning count">
                                    {warningChecks}
                                </StatusCountBadge>
                            </div>
                        </CardContent>
                    </Card>

                    {/* Summary / Filters */}
                    <Card>
                        <CardHeader>
                            <CardTitle>Checks Summary</CardTitle>
                            <CardDescription>Overview of all monitored checks on this device.</CardDescription>
                        </CardHeader>
                        <CardContent className="grid gap-3">
                            {loading && <div className="text-sm text-muted-foreground">Loading…</div>}
                            {error && <div className="text-sm text-red-600">{error}</div>}
                            {!loading && !error && items.length === 0 && (
                                <div className="text-sm text-muted-foreground">No checks found.</div>
                            )}

                            {/* Quick filters */}
                            <div className="flex flex-wrap items-center gap-2">
                                <Button
                                    variant={statusFilter === "all" ? "default" : "secondary"}
                                    size="sm"
                                    onClick={() => setStatusFilter("all")}
                                >
                                    All
                                </Button>
                                <Button
                                    variant={statusFilter === "Failing" ? "destructive" : "secondary"}
                                    size="sm"
                                    onClick={() => setStatusFilter("Failing")}
                                >
                                    <StatusGlyph status="Failing" className="mr-2" /> Failing
                                </Button>
                                <Button
                                    variant={statusFilter === "Warning" ? "default" : "secondary"}
                                    size="sm"
                                    onClick={() => setStatusFilter("Warning")}
                                >
                                    <StatusGlyph status="Warning" className="mr-2" /> Warning
                                </Button>
                                <Button
                                    variant={statusFilter === "Passing" ? "default" : "secondary"}
                                    size="sm"
                                    onClick={() => setStatusFilter("Passing")}
                                >
                                    <StatusGlyph status="Passing" className="mr-2" /> Passing
                                </Button>

                                <Separator orientation="vertical" className="mx-1 h-6" />

                                <div className="relative w/full sm:w-64">
                                    <Search className="absolute left-2 top-2.5 h-4 w-4 text-muted-foreground" />
                                    <Input
                                        className="pl-8"
                                        placeholder="Search checks, type, tags, output…"
                                        value={q}
                                        onChange={(e) => setQ(e.target.value)}
                                    />
                                </div>

                                <Popover>
                                    <PopoverTrigger asChild>
                                        <Button variant="outline" size="sm" className="ml-auto">
                                            <Filter className="mr-2 h-4 w-4" />
                                            More Filters
                                        </Button>
                                    </PopoverTrigger>
                                    <PopoverContent className="w-80">
                                        <div className="grid gap-3">
                                            <div className="text-sm font-medium">Severity</div>
                                            <div className="flex gap-2">
                                                <Button
                                                    size="sm"
                                                    variant={severityFilter === "all" ? "default" : "secondary"}
                                                    onClick={() => setSeverityFilter("all")}
                                                >All</Button>
                                                <Button
                                                    size="sm"
                                                    variant={severityFilter === "WARN" ? "default" : "secondary"}
                                                    onClick={() => setSeverityFilter("WARN")}
                                                >WARN</Button>
                                                <Button
                                                    size="sm"
                                                    variant={severityFilter === "CRIT" ? "destructive" : "secondary"}
                                                    onClick={() => setSeverityFilter("CRIT")}
                                                >CRIT</Button>
                                            </div>

                                            <Separator />

                                            <div className="text-sm font-medium">Type</div>
                                            <div className="flex flex-wrap gap-2">
                                                <Button
                                                    size="sm"
                                                    variant={typeFilter === "all" ? "default" : "secondary"}
                                                    onClick={() => setTypeFilter("all")}
                                                >All</Button>
                                                {allTypes.map((t) => (
                                                    <Button
                                                        key={t}
                                                        size="sm"
                                                        variant={typeFilter === (t as CheckType) ? "default" : "secondary"}
                                                        onClick={() => setTypeFilter(t as CheckType)}
                                                    >
                                                        {t}
                                                    </Button>
                                                ))}
                                            </div>
                                        </div>
                                    </PopoverContent>
                                </Popover>

                                <div className="flex items-center gap-2 ml-auto">
                                    <Button variant="outline" size="sm" onClick={exportCSV}>
                                        <Download className="mr-2 h-4 w-4" /> Export CSV
                                    </Button>
                                </div>
                            </div>

                            {/* Legend */}
                            <div className="flex flex-wrap items-center gap-2 text-xs text-muted-foreground">
                                <Info className="h-4 w-4" />
                                <span>Type/Severity/Thresholds/Metrics columns show when provided by backend.</span>
                            </div>
                        </CardContent>
                    </Card>
                </div>

                {/* History / Results */}
                <Card>
                    <CardHeader>
                        <CardTitle>Check History</CardTitle>
                        <CardDescription>A log of the most recent check results.</CardDescription>
                    </CardHeader>

                    <CardContent className="overflow-x-auto">
                        {/* Bulk bar */}
                        <div className="flex items-center justify-between pb-2">
                            <div className="flex items-center gap-3">
                                <Checkbox
                                    checked={filtered.length > 0 && filtered.every((r) => selectedIds.has(r.id))}
                                    onCheckedChange={(v) => toggleSelectAll(Boolean(v))}
                                    aria-label="Select all"
                                />
                                <span className="text-sm text-muted-foreground">
                                    {selectedIds.size} selected
                                </span>
                            </div>
                            <div className="flex items-center gap-2">
                                {/* Disabled until backend routes are wired */}
                                <Tooltip>
                                    <TooltipTrigger asChild>
                                        <span>
                                            <Button variant="secondary" size="sm" disabled onClick={bulkAck}>
                                                Ack
                                            </Button>
                                        </span>
                                    </TooltipTrigger>
                                    <TooltipContent>Bulk acknowledge (backend route pending)</TooltipContent>
                                </Tooltip>
                                <Tooltip>
                                    <TooltipTrigger asChild>
                                        <span>
                                            <Button variant="outline" size="sm" disabled onClick={bulkSilence}>
                                                Silence
                                            </Button>
                                        </span>
                                    </TooltipTrigger>
                                    <TooltipContent>Bulk silence (backend route pending)</TooltipContent>
                                </Tooltip>
                                <Tooltip>
                                    <TooltipTrigger asChild>
                                        <span>
                                            <Button variant="ghost" size="sm" disabled onClick={bulkResolve}>
                                                Resolve
                                            </Button>
                                        </span>
                                    </TooltipTrigger>
                                    <TooltipContent>Bulk resolve (backend route pending)</TooltipContent>
                                </Tooltip>
                            </div>
                        </div>

                        <Table>
                            <TableHeader>
                                <TableRow>
                                    <TableHead className="w-[44px]">
                                        <Checkbox
                                            checked={filtered.length > 0 && filtered.every((r) => selectedIds.has(r.id))}
                                            onCheckedChange={(v) => toggleSelectAll(Boolean(v))}
                                            aria-label="Select all"
                                        />
                                    </TableHead>
                                    <TableHead className="w/[44px]"></TableHead>
                                    <TableHead>Check Name</TableHead>
                                    <TableHead className="hidden xl:table-cell">Type</TableHead>
                                    <TableHead className="hidden lg:table-cell">Severity</TableHead>
                                    <TableHead className="hidden 2xl:table-cell">Metrics</TableHead>
                                    <TableHead className="hidden 2xl:table-cell">Thresholds</TableHead>
                                    <TableHead>Last Run</TableHead>
                                    <TableHead>Output</TableHead>
                                    <TableHead className="hidden md:table-cell">Actions</TableHead>
                                </TableRow>
                            </TableHeader>
                            <TableBody>
                                {filtered.map((check) => {
                                    const type = (check as any).type as string | undefined;
                                    const severity = (check as any).severity as Severity | undefined;
                                    const metrics = (check as any).metrics as Record<string, any> | undefined;
                                    const thresholds = (check as any).thresholds as Record<string, any> | undefined;
                                    const tags = (check as any).tags as string[] | undefined;
                                    const output = check.output || "";
                                    const long = output.length > 160;

                                    return (
                                        <TableRow
                                            key={check.id}
                                            className="hover:bg-accent/40"
                                        >
                                            <TableCell>
                                                <Checkbox
                                                    checked={selectedIds.has(check.id)}
                                                    onCheckedChange={(v) => toggleRow(check.id, Boolean(v))}
                                                    aria-label={`Select ${check.name}`}
                                                />
                                            </TableCell>

                                            <TableCell>
                                                <Tooltip>
                                                    <TooltipTrigger asChild>
                                                        <span>
                                                            <StatusGlyph status={check.status as CheckStatus} />
                                                        </span>
                                                    </TooltipTrigger>
                                                    <TooltipContent>{check.status}</TooltipContent>
                                                </Tooltip>
                                            </TableCell>

                                            <TableCell className="font-medium">
                                                <button
                                                    type="button"
                                                    className="text-left hover:underline decoration-dotted"
                                                    onClick={() => setSelected(check)}
                                                    title="View details"
                                                >
                                                    {check.name}
                                                </button>
                                                {!!tags?.length && (
                                                    <div className="mt-1 flex flex-wrap gap-1">
                                                        {tags.slice(0, 4).map((t) => (
                                                            <Badge key={t} variant="secondary" className="text-[10px]">{t}</Badge>
                                                        ))}
                                                        {tags.length > 4 && (
                                                            <Badge variant="outline" className="text-[10px]">
                                                                +{tags.length - 4}
                                                            </Badge>
                                                        )}
                                                    </div>
                                                )}
                                            </TableCell>

                                            <TableCell className="hidden xl:table-cell">
                                                {type ? <Badge variant="secondary">{type}</Badge> : <span className="text-muted-foreground">—</span>}
                                            </TableCell>

                                            <TableCell className="hidden lg:table-cell">
                                                {severity ? (
                                                    <Badge variant={severity === "CRIT" ? "destructive" : "secondary"}>
                                                        {severity}
                                                    </Badge>
                                                ) : (
                                                    <span className="text-muted-foreground">—</span>
                                                )}
                                            </TableCell>

                                            <TableCell className="hidden 2xl:table-cell">
                                                {metrics && Object.keys(metrics).length ? (
                                                    <div className="flex flex-wrap gap-1">
                                                        {Object.entries(metrics).slice(0, 5).map(([k, v]) => (
                                                            <Badge key={k} variant="outline" className="text-[10px]">
                                                                {k}:{String(v)}
                                                            </Badge>
                                                        ))}
                                                        {Object.keys(metrics).length > 5 && (
                                                            <Badge variant="outline" className="text-[10px]">+{Object.keys(metrics).length - 5}</Badge>
                                                        )}
                                                    </div>
                                                ) : <span className="text-muted-foreground">—</span>}
                                            </TableCell>

                                            <TableCell className="hidden 2xl:table-cell">
                                                {thresholds && Object.keys(thresholds).length ? (
                                                    <div className="flex flex-wrap gap-1">
                                                        {Object.entries(thresholds).slice(0, 5).map(([k, v]) => (
                                                            <Badge key={k} variant="outline" className="text-[10px]">
                                                                {k}:{String(v)}
                                                            </Badge>
                                                        ))}
                                                        {Object.keys(thresholds).length > 5 && (
                                                            <Badge variant="outline" className="text-[10px]">+{Object.keys(thresholds).length - 5}</Badge>
                                                        )}
                                                    </div>
                                                ) : <span className="text-muted-foreground">—</span>}
                                            </TableCell>

                                            <TableCell className="text-muted-foreground">{formatWhen(check.lastRun)}</TableCell>

                                            <TableCell className="text-muted-foreground">
                                                {long ? (
                                                    <Popover>
                                                        <PopoverTrigger asChild>
                                                            <Button variant="ghost" size="sm" className="px-0 h-auto text-left font-normal">
                                                                {truncate(output)}
                                                            </Button>
                                                        </PopoverTrigger>
                                                        <PopoverContent className="max-w-[80vw] md:max-w-[50vw] whitespace-pre-wrap">
                                                            {output}
                                                        </PopoverContent>
                                                    </Popover>
                                                ) : (
                                                    <span className="whitespace-pre-wrap">
                                                        {output || <span className="text-muted-foreground">—</span>}
                                                    </span>
                                                )}
                                            </TableCell>

                                            <TableCell className="hidden md:table-cell">
                                                <div className="flex items-center gap-2">
                                                    <Tooltip>
                                                        <TooltipTrigger asChild>
                                                            <span>
                                                                <Button size="sm" variant="outline" disabled onClick={() => runNow(check.id)}>
                                                                    <Play className="h-3.5 w-3.5 mr-1" /> Run now
                                                                </Button>
                                                            </span>
                                                        </TooltipTrigger>
                                                        <TooltipContent>Dispatch on-demand run (backend pending)</TooltipContent>
                                                    </Tooltip>

                                                    <Tooltip>
                                                        <TooltipTrigger asChild>
                                                            <span>
                                                                <Button size="sm" variant="ghost" disabled>
                                                                    <Ban className="h-3.5 w-3.5 mr-1" /> Silence
                                                                </Button>
                                                            </span>
                                                        </TooltipTrigger>
                                                        <TooltipContent>Silence alert (backend pending)</TooltipContent>
                                                    </Tooltip>
                                                </div>
                                            </TableCell>
                                        </TableRow>
                                    );
                                })}

                                {!loading && filtered.length === 0 && (
                                    <TableRow>
                                        <TableCell colSpan={10} className="text-sm text-muted-foreground">
                                            {items.length ? "No checks match the current filters." : "No checks found."}
                                        </TableCell>
                                    </TableRow>
                                )}
                            </TableBody>
                        </Table>
                    </CardContent>
                </Card>

                {/* Detail drawer */}
                <Sheet open={!!selected} onOpenChange={(open) => !open && setSelected(null)}>
                    <SheetContent side="right" className="w-full sm:max-w-xl">
                        <SheetHeader>
                            <SheetTitle className="flex items-center gap-2">
                                {selected && <StatusGlyph status={selected.status as CheckStatus} />}
                                <span>{selected?.name ?? "Check"}</span>
                            </SheetTitle>
                            <SheetDescription>
                                {selected ? (
                                    <div className="grid gap-3 text-sm">
                                        <div className="flex flex-wrap items-center gap-2">
                                            {(selected as any).type && (
                                                <Badge variant="secondary">{(selected as any).type}</Badge>
                                            )}
                                            {(selected as any).severity && (
                                                <Badge variant={(selected as any).severity === "CRIT" ? "destructive" : "secondary"}>
                                                    {(selected as any).severity}
                                                </Badge>
                                            )}
                                            {(selected as any).category && (
                                                <Badge variant="outline">{(selected as any).category}</Badge>
                                            )}
                                            {(selected as any).maintenance && (
                                                <Badge variant="outline">Maintenance</Badge>
                                            )}
                                        </div>

                                        <div className="flex items-center gap-2">
                                            <span className="text-muted-foreground">Last run:</span>
                                            <span>{formatWhen(selected.lastRun) || "—"}</span>
                                        </div>

                                        {(selected as any).dedupeKey && (
                                            <div className="flex items-center gap-2">
                                                <span className="text-muted-foreground">Key:</span>
                                                <code className="text-xs">{(selected as any).dedupeKey}</code>
                                            </div>
                                        )}

                                        {(selected as any).tags?.length ? (
                                            <div className="flex items-center gap-2">
                                                <span className="text-muted-foreground">Tags:</span>
                                                <div className="flex flex-wrap gap-1">
                                                    {(selected as any).tags.map((t: string) => (
                                                        <Badge key={t} variant="secondary" className="text-[10px]">{t}</Badge>
                                                    ))}
                                                </div>
                                            </div>
                                        ) : null}

                                        <Separator />

                                        <Tabs defaultValue="output">
                                            <TabsList className="grid grid-cols-3 w-full">
                                                <TabsTrigger value="output">Output</TabsTrigger>
                                                <TabsTrigger value="metrics">Metrics</TabsTrigger>
                                                <TabsTrigger value="thresholds">Thresholds</TabsTrigger>
                                            </TabsList>

                                            <TabsContent value="output" className="pt-2">
                                                <div className="rounded-md border p-3 bg-muted/30 whitespace-pre-wrap">
                                                    {selected.output || <span className="text-muted-foreground">No output</span>}
                                                </div>
                                            </TabsContent>

                                            <TabsContent value="metrics" className="pt-2">
                                                {Object.keys((selected as any).metrics ?? {}).length ? (
                                                    <div className="grid grid-cols-2 gap-2">
                                                        {Object.entries((selected as any).metrics).map(([k, v]) => (
                                                            <div key={k} className="flex items-center justify-between rounded border bg-muted/20 px-2 py-1">
                                                                <span className="text-muted-foreground">{k}</span>
                                                                <span className="font-medium">{String(v)}</span>
                                                            </div>
                                                        ))}
                                                    </div>
                                                ) : (
                                                    <div className="text-muted-foreground">No metrics</div>
                                                )}
                                            </TabsContent>

                                            <TabsContent value="thresholds" className="pt-2">
                                                {Object.keys((selected as any).thresholds ?? {}).length ? (
                                                    <div className="grid grid-cols-2 gap-2">
                                                        {Object.entries((selected as any).thresholds).map(([k, v]) => (
                                                            <div key={k} className="flex items-center justify-between rounded border bg-muted/20 px-2 py-1">
                                                                <span className="text-muted-foreground">{k}</span>
                                                                <span className="font-medium">{String(v)}</span>
                                                            </div>
                                                        ))}
                                                    </div>
                                                ) : (
                                                    <div className="text-muted-foreground">No thresholds</div>
                                                )}
                                            </TabsContent>
                                        </Tabs>
                                    </div>
                                ) : null}
                            </SheetDescription>
                        </SheetHeader>
                    </SheetContent>
                </Sheet>
            </div>
        </TooltipProvider>
    );
}

===== END FILE remoteiq-frontend\components\checks-and-alerts-tab.tsx =====

===== FILE: remoteiq-frontend\app\(dashboard)\devices\[deviceId]\page.tsx (334 lines) =====
// app/(dashboard)/devices/[deviceId]/page.tsx
"use client";

import * as React from "react";
import Link from "next/link";
import { useRouter, useSearchParams, usePathname } from "next/navigation";
import { Power, Play, ShieldCheck, Tag, Move, Copy } from "lucide-react";

import {
    Breadcrumb,
    BreadcrumbItem,
    BreadcrumbLink,
    BreadcrumbList,
    BreadcrumbPage,
    BreadcrumbSeparator,
} from "@/components/ui/breadcrumb";
import { Button } from "@/components/ui/button";
import { Card, CardContent, CardDescription, CardHeader, CardTitle } from "@/components/ui/card";
import { Separator } from "@/components/ui/separator";
import { Tabs, TabsContent, TabsList, TabsTrigger } from "@/components/ui/tabs";

import { useDashboard, type Device as UiDevice } from "@/app/(dashboard)/dashboard-context";
import { StatusBadge } from "@/components/status-badge";
import SoftwareTab from "@/components/software-tab";
import ChecksAndAlertsTab from "@/components/checks-and-alerts-tab";
import PatchTab from "@/components/patch-tab";
import RemoteTab from "@/components/remote-tab";

import { useDevice } from "@/lib/use-device";

// US-style "MM/DD/YYYY - H:MM AM/PM"
const dtFmt = new Intl.DateTimeFormat("en-US", {
    month: "2-digit",
    day: "2-digit",
    year: "numeric",
    hour: "numeric",
    minute: "2-digit",
    hour12: true,
});

type BadgeStatus = "healthy" | "warning" | "critical" | "offline";
function normalizeStatus(s?: string): BadgeStatus {
    switch ((s || "").toLowerCase()) {
        case "healthy":
            return "healthy";
        case "warning":
            return "warning";
        case "critical":
            return "critical";
        case "online":
            return "healthy";
        default:
            return "offline";
    }
}

export default function DeviceDetailPage({ params }: { params: { deviceId: string } }) {
    const { masterDevices, filteredDevices } = useDashboard();
    const devices = masterDevices?.length ? masterDevices : filteredDevices;

    // Local (dashboard) device if present
    const localDevice: UiDevice | undefined = React.useMemo(
        () => devices.find((d) => d.id === params.deviceId),
        [devices, params.deviceId]
    );

    // Backend device (authoritative)
    const { device: apiDevice, loading, error, refresh } = useDevice(params.deviceId);

    // Merge API device into the UI shape your page expects.
    const device: UiDevice | undefined = React.useMemo(() => {
        if (!apiDevice && !localDevice) return undefined;

        const status = normalizeStatus(apiDevice?.status ?? (localDevice as any)?.status);
        const merged: Partial<UiDevice> = {
            id: apiDevice?.id ?? localDevice?.id ?? params.deviceId,
            hostname: apiDevice?.hostname ?? localDevice?.hostname ?? "",
            alias: localDevice?.alias ?? apiDevice?.hostname ?? "",
            client: (localDevice as any)?.client ?? "—",
            site: (localDevice as any)?.site ?? "—",
            os: apiDevice?.os ?? (localDevice as any)?.os ?? "Unknown",
            status,
            // carry lastSeen through as lastResponse for display
            lastResponse: apiDevice?.lastSeen ?? (localDevice as any)?.lastResponse ?? null,
            // extra fields from backend we’ll show directly below
            ...(apiDevice
                ? {
                    arch: apiDevice.arch,
                    primaryIp: apiDevice.primaryIp,
                    version: apiDevice.version,
                    user: apiDevice.user,
                    agentUuid: (apiDevice as any)?.agentUuid ?? (localDevice as any)?.agentUuid ?? null,
                }
                : {
                    agentUuid: (localDevice as any)?.agentUuid ?? null,
                }),
        };

        return merged as unknown as UiDevice;
    }, [apiDevice, localDevice, params.deviceId]);

    const router = useRouter();
    const pathname = usePathname();
    const search = useSearchParams();

    const openRunScript = React.useCallback(() => {
        const current = new URLSearchParams(search?.toString() ?? "");
        current.set("device", params.deviceId);
        router.push(`${pathname}?${current.toString()}`);
    }, [params.deviceId, pathname, router, search]);

    const onReboot = React.useCallback(async () => {
        // TODO: wire your reboot call if available
    }, []);
    const onPatchNow = React.useCallback(async () => {
        // TODO: wire your patch call if available
    }, []);

    // ✅ HOOK DECLARED BEFORE ANY CONDITIONAL RETURNS
    const copy = React.useCallback(async (text: string) => {
        try {
            await navigator.clipboard.writeText(text);
            // optional: toast here
        } catch {
            // ignore
        }
    }, []);

    // ----- Conditional returns (no hooks below this line) -----
    if (loading && !device) {
        return (
            <div className="flex flex-col items-center justify-center h-full gap-3 text-center p-6">
                <div className="text-sm text-muted-foreground">Loading device…</div>
            </div>
        );
    }
    if (error && !device) {
        return (
            <div className="flex flex-col items-center justify-center h-full gap-4 text-center p-6">
                <h2 className="text-2xl font-semibold">Error loading device</h2>
                <p className="text-muted-foreground">{String(error)}</p>
                <div className="flex gap-2">
                    <Button variant="outline" onClick={refresh}>
                        Retry
                    </Button>
                    <Button asChild>
                        <Link href="/">Return to Dashboard</Link>
                    </Button>
                </div>
            </div>
        );
    }
    if (!device) {
        return (
            <div className="flex flex-col items-center justify-center h-full gap-4 text-center p-6">
                <h2 className="text-2xl font-semibold">Device Not Found</h2>
                <p className="text-muted-foreground">
                    The device with ID &apos;{params.deviceId}&apos; could not be found.
                </p>
                <Button asChild>
                    <Link href="/">Return to Dashboard</Link>
                </Button>
            </div>
        );
    }

    const badgeStatus: BadgeStatus = normalizeStatus(device.status as unknown as string);

    const lastSeenIso = (device as any).lastResponse as string | null;
    const lastSeenStr = lastSeenIso ? dtFmt.format(new Date(lastSeenIso)).replace(",", " -") : "—";

    const os = (device as any).os ?? "Unknown";
    const arch = (device as any).arch ?? "—";
    const primaryIp = (device as any).primaryIp ?? "—";
    const version = (device as any).version ?? "—";
    const currentUser = (device as any).user ?? "—";
    const agentUuid = (device as any)?.agentUuid as string | undefined | null;

    return (
        <main className="grid flex-1 items-start gap-4 p-4 sm:px-6 sm:py-0 md:gap-8">
            <div className="mx-auto grid w-full flex-1 auto-rows-max gap-4">
                <div className="flex items-center justify-between gap-4">
                    <Breadcrumb className="hidden md:flex">
                        <BreadcrumbList>
                            <BreadcrumbItem>
                                <BreadcrumbLink asChild>
                                    <Link href="/">Dashboard</Link>
                                </BreadcrumbLink>
                            </BreadcrumbItem>
                            <BreadcrumbSeparator />
                            <BreadcrumbItem>
                                <BreadcrumbLink asChild>
                                    <Link href="/customers">Devices</Link>
                                </BreadcrumbLink>
                            </BreadcrumbItem>
                            <BreadcrumbSeparator />
                            <BreadcrumbItem>
                                <BreadcrumbPage>{(device as any).alias || (device as any).hostname}</BreadcrumbPage>
                            </BreadcrumbItem>
                        </BreadcrumbList>
                    </Breadcrumb>

                    <div className="flex items-center gap-2">
                        <Button
                            variant="default"
                            size="sm"
                            onClick={openRunScript}
                            className="gap-2"
                            title="Open Run Script"
                        >
                            <Play className="h-4 w-4" /> Run Script
                        </Button>
                        <Button variant="outline" size="sm" title="Trigger a patch cycle" onClick={onPatchNow}>
                            <ShieldCheck className="h-4 w-4" /> Patch Now
                        </Button>
                        <Button variant="destructive" size="sm" title="Reboot this device" onClick={onReboot}>
                            <Power className="h-4 w-4" /> Reboot
                        </Button>
                    </div>
                </div>

                <Tabs defaultValue="overview">
                    <div className="flex items-center">
                        <TabsList>
                            <TabsTrigger value="overview">Overview</TabsTrigger>
                            <TabsTrigger value="remote">Remote</TabsTrigger>
                            <TabsTrigger value="checks">Checks &amp; Alerts</TabsTrigger>
                            <TabsTrigger value="patch">Patch</TabsTrigger>
                            <TabsTrigger value="software">Software</TabsTrigger>
                        </TabsList>
                        <div className="ml-auto flex items-center gap-2">
                            <Button variant="outline" size="sm" onClick={refresh} title="Refresh device data">
                                Refresh
                            </Button>
                        </div>
                    </div>

                    <TabsContent value="overview">
                        <Card>
                            <CardHeader>
                                <div className="flex justify-between items-start gap-4">
                                    <div className="min-w-0">
                                        <CardTitle className="truncate">
                                            {(device as any).alias || (device as any).hostname}
                                        </CardTitle>
                                        <CardDescription className="truncate">
                                            {(device as any).client} / {(device as any).site}
                                        </CardDescription>
                                    </div>
                                    <div className="flex items-center gap-2 shrink-0">
                                        <Button variant="outline" size="icon" title="Edit alias" aria-label="Edit alias">
                                            <Tag className="h-4 w-4" />
                                        </Button>
                                        <Button variant="outline" size="icon" title="Move device" aria-label="Move device">
                                            <Move className="h-4 w-4" />
                                        </Button>
                                    </div>
                                </div>
                            </CardHeader>
                            <CardContent>
                                <Separator className="my-4" />
                                <div className="grid grid-cols-1 md:grid-cols-3 gap-6 text-sm">
                                    <div className="space-y-1">
                                        <h3 className="font-medium text-muted-foreground">Status</h3>
                                        <StatusBadge status={badgeStatus} />
                                    </div>
                                    <div className="space-y-1">
                                        <h3 className="font-medium text-muted-foreground">Operating System</h3>
                                        <p>{os}</p>
                                    </div>
                                    <div className="space-y-1">
                                        <h3 className="font-medium text-muted-foreground">Architecture</h3>
                                        <p>{arch}</p>
                                    </div>
                                    <div className="space-y-1">
                                        <h3 className="font-medium text-muted-foreground">IP Address</h3>
                                        <p>{primaryIp}</p>
                                    </div>
                                    <div className="space-y-1">
                                        <h3 className="font-medium text-muted-foreground">Agent Version</h3>
                                        <p>{version}</p>
                                    </div>
                                    <div className="space-y-1">
                                        <h3 className="font-medium text-muted-foreground">Last Response</h3>
                                        <p>{lastSeenStr}</p>
                                    </div>

                                    {/* Agent UUID (optional) */}
                                    {agentUuid ? (
                                        <div className="space-y-1 md:col-span-3">
                                            <h3 className="font-medium text-muted-foreground">Agent UUID</h3>
                                            <div className="flex items-center gap-2">
                                                <code className="text-xs break-all">{agentUuid}</code>
                                                <Button
                                                    size="sm"
                                                    variant="outline"
                                                    title="Copy agent UUID"
                                                    onClick={() => copy(agentUuid)}
                                                    className="gap-2"
                                                >
                                                    <Copy className="h-3.5 w-3.5" />
                                                    Copy
                                                </Button>
                                            </div>
                                        </div>
                                    ) : null}

                                    <div className="space-y-1 md:col-span-3">
                                        <h3 className="font-medium text-muted-foreground">Logged-in User</h3>
                                        <p>{currentUser}</p>
                                    </div>
                                </div>
                            </CardContent>
                        </Card>
                    </TabsContent>

                    <TabsContent value="remote">
                        <RemoteTab />
                    </TabsContent>
                    <TabsContent value="checks">
                        <ChecksAndAlertsTab />
                    </TabsContent>
                    <TabsContent value="patch">
                        <PatchTab />
                    </TabsContent>
                    <TabsContent value="software">
                        <SoftwareTab />
                    </TabsContent>
                </Tabs>
            </div>
        </main>
    );
}

===== END FILE remoteiq-frontend\app\(dashboard)\devices\[deviceId]\page.tsx =====

===== FILE: remoteiq-minimal-e2e\agent-windows\RemoteIQ.Agent\Services\Http\ApiClient.cs (119 lines) =====
// remoteiq-minimal-e2e/agent-windows/RemoteIQ.Agent/Services/Http/ApiClient.cs
using System;
using System.Linq;
using System.Net.Http;
using System.Net.Http.Headers;
using System.Text;
using System.Text.Json;
using System.Threading;
using System.Threading.Tasks;
using RemoteIQ.Agent.Models;

namespace RemoteIQ.Agent.Services.Http
{
    public sealed class ApiClient
    {
        private readonly HttpClient _http;
        private readonly JsonSerializerOptions _json;

        public readonly struct VoidType { }

        public ApiClient(HttpClient http)
        {
            _http = http;
            _json = new JsonSerializerOptions
            {
                PropertyNamingPolicy = JsonNamingPolicy.CamelCase,
                PropertyNameCaseInsensitive = true,
                WriteIndented = false
            };

            _http.DefaultRequestHeaders.Accept.Clear();
            _http.DefaultRequestHeaders.Accept.Add(new MediaTypeWithQualityHeaderValue("application/json"));
        }

        public void SetBearer(string? token)
        {
            _http.DefaultRequestHeaders.Authorization =
                string.IsNullOrWhiteSpace(token) ? null : new AuthenticationHeaderValue("Bearer", token);
        }

        // ---------- Health & Enrollment ----------
        public async Task<bool> HealthAsync(CancellationToken ct = default)
        {
            using var res = await _http.GetAsync("/healthz", ct).ConfigureAwait(false);
            return res.IsSuccessStatusCode;
        }

        public async Task<EnrollResponse> EnrollAsync(EnrollRequest body, CancellationToken ct = default)
            => await PostJsonAsync<EnrollRequest, EnrollResponse>("/api/agent/enroll", body, ct).ConfigureAwait(false);

        // ---------- Ping with facts ----------
        public async Task<VoidType> PingAsync(PingRequest body, CancellationToken ct = default)
            => await PostJsonAsync<PingRequest, VoidType>("/api/agent/ping", body, ct).ConfigureAwait(false);

        // ---------- Software inventory ----------
        public async Task<VoidType> SubmitSoftwareAsync(System.Collections.Generic.IEnumerable<InstalledApp> items, CancellationToken ct = default)
        {
            var payload = new
            {
                items = items?.Select(s => new
                {
                    name = s.DisplayName,
                    version = s.Version,
                    publisher = s.Publisher,
                    installDate = s.InstallDate
                }).ToArray() ?? Array.Empty<object>()
            };

            return await PostJsonAsync<object, VoidType>("/api/agent/software", payload, ct).ConfigureAwait(false);
        }

        // ---------- Generic helpers ----------
        public async Task<T> GetJsonAsync<T>(string path, CancellationToken ct = default)
        {
            using var res = await _http.GetAsync(path, ct).ConfigureAwait(false);
            await EnsureOk(res, ct).ConfigureAwait(false);
            if (typeof(T) == typeof(VoidType)) return default!;
            await using var s = await res.Content.ReadAsStreamAsync(ct).ConfigureAwait(false);
            return (await JsonSerializer.DeserializeAsync<T>(s, _json, ct).ConfigureAwait(false))!;
        }

        public async Task<TResponse> PostJsonAsync<TRequest, TResponse>(string path, TRequest body, CancellationToken ct = default)
        {
            var content = new StringContent(JsonSerializer.Serialize(body, _json), Encoding.UTF8, "application/json");
            using var res = await _http.PostAsync(path, content, ct).ConfigureAwait(false);
            await EnsureOk(res, ct).ConfigureAwait(false);
            if (typeof(TResponse) == typeof(VoidType)) return default!;
            await using var s = await res.Content.ReadAsStreamAsync(ct).ConfigureAwait(false);
            return (await JsonSerializer.DeserializeAsync<TResponse>(s, _json, ct).ConfigureAwait(false))!;
        }

        public async Task<TResponse> PostNoBodyAsync<TResponse>(string path, CancellationToken ct = default)
        {
            using var res = await _http.PostAsync(path, content: null, ct).ConfigureAwait(false);
            await EnsureOk(res, ct).ConfigureAwait(false);
            if (typeof(TResponse) == typeof(VoidType)) return default!;
            await using var s = await res.Content.ReadAsStreamAsync(ct).ConfigureAwait(false);
            return (await JsonSerializer.DeserializeAsync<TResponse>(s, _json, ct).ConfigureAwait(false))!;
        }

        public async Task DeleteAsync(string path, CancellationToken ct = default)
        {
            using var res = await _http.DeleteAsync(path, ct).ConfigureAwait(false);
            await EnsureOk(res, ct).ConfigureAwait(false);
        }

        internal static async Task EnsureOk(HttpResponseMessage res, CancellationToken ct)
        {
            if (res.IsSuccessStatusCode) return;
            string body;
            try { body = await res.Content.ReadAsStringAsync(ct).ConfigureAwait(false); }
            catch { body = "<no body>"; }
            var status = (int)res.StatusCode;
            var reason = res.ReasonPhrase ?? "Unknown";
            throw new HttpRequestException($"HTTP {status} {reason}: {body}");
        }
    }
}

===== END FILE remoteiq-minimal-e2e\agent-windows\RemoteIQ.Agent\Services\Http\ApiClient.cs =====

===== FILE: remoteiq-minimal-e2e\agent-windows\RemoteIQ.Agent\Services\Collectors\MetricsCollector.cs (87 lines) =====
using System.Diagnostics;
using RemoteIQ.Agent.Models;
using System.Management; // <-- ADDED THIS
using System.Linq; // <-- ADDED THIS

namespace RemoteIQ.Agent.Services.Collectors;

public class MetricsCollector
{
    public (double cpuPct, double memPct, Dictionary<string, double> diskPct, List<TopProcess> tops) Sample(int topN = 5)
    {
        double cpu = GetCpuUsagePct();
        double mem = GetMemPct();
        var disk = GetDiskPct();
        var tops = GetTopProcesses(topN);
        return (cpu, mem, disk, tops);
    }

    static double GetCpuUsagePct()
    {
        try
        {
            using var cpu = new PerformanceCounter("Processor", "% Processor Time", "_Total");
            _ = cpu.NextValue();
            Thread.Sleep(500);
            return Math.Round(cpu.NextValue(), 1);
        }
        catch { return 0; }
    }

    // --- THIS METHOD IS UPDATED ---
    static double GetMemPct()
    {
        try
        {
            // Use WMI (System.Management) instead of VisualBasic
            using var searcher = new ManagementObjectSearcher("SELECT TotalVisibleMemorySize, FreePhysicalMemory FROM Win32_OperatingSystem");
            using var collection = searcher.Get();
            using var mem = collection.Cast<ManagementObject>().First();

            var totalMemKb = (ulong)mem["TotalVisibleMemorySize"];
            var freeMemKb = (ulong)mem["FreePhysicalMemory"];
            var usedMemKb = totalMemKb - freeMemKb;

            if (totalMemKb == 0) return 0; // Avoid divide by zero

            return Math.Round(100.0 * usedMemKb / totalMemKb, 1);
        }
        catch { return 0; }
    }

    static Dictionary<string, double> GetDiskPct()
    {
        var dict = new Dictionary<string, double>();
        try
        {
            foreach (var di in DriveInfo.GetDrives().Where(d => d.IsReady && d.DriveType == DriveType.Fixed))
            {
                var used = di.TotalSize - di.AvailableFreeSpace;
                var pct = 100.0 * used / Math.Max(1, (double)di.TotalSize);
                dict[di.Name.TrimEnd('\\')] = Math.Round(pct, 1);
            }
        }
        catch { }
        return dict;
    }

    static List<TopProcess> GetTopProcesses(int topN)
    {
        try
        {
            var list = Process.GetProcesses()
                .Select(p =>
                {
                    long mem = 0;
                    try { mem = p.WorkingSet64; } catch { }
                    return new { p.Id, p.ProcessName, Mem = mem };
                })
                .OrderByDescending(x => x.Mem)
                .Take(topN)
                .Select(x => new TopProcess(x.Id, x.ProcessName + ".exe", 0, x.Mem))
                .ToList();
            return list;
        }
        catch { return new List<TopProcess>(); }
    }
}
===== END FILE remoteiq-minimal-e2e\agent-windows\RemoteIQ.Agent\Services\Collectors\MetricsCollector.cs =====

===== FILE: remoteiq-minimal-e2e\agent-windows\RemoteIQ.Agent\Services\Collectors\InventoryCollector.cs (221 lines) =====
// remoteiq-minimal-e2e/agent-windows/RemoteIQ.Agent/Services/Collectors/InventoryCollector.cs
using System;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using System.Management;
using RemoteIQ.Agent.Models;

namespace RemoteIQ.Agent.Services.Collectors
{
    public class InventoryCollector
    {
        public (Hardware hw, Network net, List<SoftwareItem> sw, List<ServiceItem> svcs, List<ProcessItem> procs) Collect(int topN = 5)
        {
            var hw = GetHardware();
            var net = GetNetwork();
            var sw = GetSoftware();
            var svcs = GetServices();
            var procs = GetProcesses(topN);
            return (hw, net, sw, svcs, procs);
        }

        static Hardware GetHardware()
        {
            var cpu = new Cpu(GetCpuName(), GetCoreCount(), Environment.ProcessorCount);
            long ram = GetTotalRam();
            var disks = GetDisks();
            var gpus = GetGpus();
            var mobo = GetMotherboard();
            var bios = GetBios();
            return new Hardware(cpu, ram, disks, gpus, mobo, bios);
        }

        static string GetCpuName()
        {
            try
            {
                using var mos = new ManagementObjectSearcher("select Name from Win32_Processor");
                foreach (ManagementObject mo in mos.Get()) return mo["Name"]?.ToString() ?? "";
            }
            catch { }
            return "";
        }

        static int GetCoreCount()
        {
            try
            {
                using var mos = new ManagementObjectSearcher("select NumberOfCores from Win32_Processor");
                foreach (ManagementObject mo in mos.Get()) return Convert.ToInt32(mo["NumberOfCores"] ?? 0);
            }
            catch { }
            return Environment.ProcessorCount;
        }

        static long GetTotalRam()
        {
            try
            {
                using var mos = new ManagementObjectSearcher("select TotalVisibleMemorySize from Win32_OperatingSystem");
                foreach (ManagementObject mo in mos.Get())
                {
                    var kb = Convert.ToInt64(mo["TotalVisibleMemorySize"] ?? 0);
                    return kb * 1024;
                }
            }
            catch { }
            return 0;
        }

        static List<Disk> GetDisks()
        {
            var list = new List<Disk>();
            try
            {
                using var mos = new ManagementObjectSearcher("select Name,Size,MediaType from Win32_DiskDrive");
                foreach (ManagementObject mo in mos.Get())
                {
                    var name = mo["Name"]?.ToString() ?? "";
                    var size = Convert.ToInt64(mo["Size"] ?? 0);
                    var type = mo["MediaType"]?.ToString() ?? "";
                    list.Add(new Disk(name, size, type));
                }
            }
            catch { }
            return list;
        }

        static List<Gpu> GetGpus()
        {
            var list = new List<Gpu>();
            try
            {
                using var mos = new ManagementObjectSearcher("select Name,DriverVersion from Win32_VideoController");
                foreach (ManagementObject mo in mos.Get())
                    list.Add(new Gpu(mo["Name"]?.ToString() ?? "", mo["DriverVersion"]?.ToString()));
            }
            catch { }
            return list;
        }

        static Motherboard GetMotherboard()
        {
            try
            {
                using var mos = new ManagementObjectSearcher("select Manufacturer,Product from Win32_BaseBoard");
                foreach (ManagementObject mo in mos.Get())
                    return new Motherboard(mo["Manufacturer"]?.ToString() ?? "", mo["Product"]?.ToString() ?? "");
            }
            catch { }
            return new Motherboard("", "");
        }

        static Bios GetBios()
        {
            try
            {
                using var mos = new ManagementObjectSearcher("select Manufacturer,SMBIOSBIOSVersion,ReleaseDate from Win32_BIOS");
                foreach (ManagementObject mo in mos.Get())
                    return new Bios(mo["Manufacturer"]?.ToString() ?? "", mo["SMBIOSBIOSVersion"]?.ToString() ?? "", mo["ReleaseDate"]?.ToString());
            }
            catch { }
            return new Bios("", "", null);
        }

        static Network GetNetwork()
        {
            var list = new List<NetIf>();
            try
            {
                using var mos = new ManagementObjectSearcher(
                    "select Description,MACAddress,IPEnabled,IPAddress,DefaultIPGateway,DNSServerSearchOrder from Win32_NetworkAdapterConfiguration where IPEnabled = true");
                foreach (ManagementObject mo in mos.Get())
                {
                    var name = mo["Description"]?.ToString() ?? "Adapter";
                    var mac = mo["MACAddress"]?.ToString() ?? "";

                    var ips = mo["IPAddress"] as string[] ?? Array.Empty<string>();
                    var ipv4 = ips.Where(ip => ip != null && ip.Contains('.')).ToList();
                    var ipv6 = ips.Where(ip => ip != null && ip.Contains(':')).ToList();

                    var gw = (mo["DefaultIPGateway"] as string[] ?? Array.Empty<string>()).FirstOrDefault();
                    var dns = (mo["DNSServerSearchOrder"] as string[] ?? Array.Empty<string>()).ToList();

                    list.Add(new NetIf(name, mac, ipv4, ipv6, gw, dns));
                }
            }
            catch { }
            return new Network(list);
        }

        static List<SoftwareItem> GetSoftware()
        {
            var list = new List<SoftwareItem>();
            try
            {
                var roots = new[] {
                    Microsoft.Win32.Registry.LocalMachine.OpenSubKey(@"SOFTWARE\Microsoft\Windows\CurrentVersion\Uninstall"),
                    Microsoft.Win32.Registry.LocalMachine.OpenSubKey(@"SOFTWARE\WOW6432Node\Microsoft\Windows\CurrentVersion\Uninstall")
                };
                foreach (var root in roots.Where(r => r != null)!)
                {
                    foreach (var keyName in root!.GetSubKeyNames())
                    {
                        using var k = root.OpenSubKey(keyName);
                        var name = k?.GetValue("DisplayName")?.ToString();
                        if (string.IsNullOrWhiteSpace(name)) continue;
                        var ver = k?.GetValue("DisplayVersion")?.ToString();
                        var pub = k?.GetValue("Publisher")?.ToString();
                        var dt = k?.GetValue("InstallDate")?.ToString();
                        list.Add(new SoftwareItem(name!, ver, pub, dt));
                    }
                }
            }
            catch { }
            return list;
        }

        static List<ServiceItem> GetServices()
        {
            var list = new List<ServiceItem>();
            try
            {
                foreach (var sc in System.ServiceProcess.ServiceController.GetServices())
                {
                    string startType = "Unknown";
                    try
                    {
                        using var mos = new ManagementObjectSearcher(
                            $"select StartMode,DisplayName,Name from Win32_Service where Name='{sc.ServiceName.Replace("'", "''")}'");
                        foreach (ManagementObject mo in mos.Get())
                            startType = mo["StartMode"]?.ToString() ?? "Unknown";
                    }
                    catch { }
                    list.Add(new ServiceItem(sc.ServiceName, sc.DisplayName, sc.Status.ToString(), startType));
                }
            }
            catch { }
            return list;
        }

        static List<ProcessItem> GetProcesses(int topN)
        {
            var list = new List<ProcessItem>();
            try
            {
                foreach (var p in System.Diagnostics.Process.GetProcesses())
                {
                    long mem = 0;
                    try { mem = p.WorkingSet64; } catch { }
                    list.Add(new ProcessItem(p.Id, p.ProcessName + ".exe", 0, mem));
                }
                // Keep more than topN so server can choose what to display
                list = list.OrderByDescending(x => x.MemBytes).Take(Math.Max(10, topN * 3)).ToList();
            }
            catch { }
            return list;
        }
    }
}

===== END FILE remoteiq-minimal-e2e\agent-windows\RemoteIQ.Agent\Services\Collectors\InventoryCollector.cs =====

===== FILE: remoteiq-minimal-e2e\agent-windows\RemoteIQ.Agent\Services\Collectors\SoftwareCollector.cs (76 lines) =====
//remoteiq-minimal-e2e\agent-windows\RemoteIQ.Agent\Services\Collectors\SoftwareCollector.cs

using Microsoft.Win32;
using RemoteIQ.Agent.Models;
using System;
using System.Collections.Generic;

namespace RemoteIQ.Agent.Services.Collectors
{
    public static class SoftwareCollector
    {
        public static List<InstalledApp> Collect()
        {
            var list = new List<InstalledApp>();
            try
            {
                ReadUninstall(RegistryHive.LocalMachine, RegistryView.Registry64, list);
                ReadUninstall(RegistryHive.LocalMachine, RegistryView.Registry32, list);
            }
            catch { /* ignore */ }

            var seen = new HashSet<string>(StringComparer.OrdinalIgnoreCase);
            var dedup = new List<InstalledApp>();
            foreach (var s in list)
            {
                if (string.IsNullOrWhiteSpace(s.DisplayName)) continue;
                var key = $"{s.DisplayName}|{s.Version}";
                if (seen.Add(key)) dedup.Add(s);
            }
            return dedup;
        }

        private static void ReadUninstall(RegistryHive hive, RegistryView view, List<InstalledApp> output)
        {
            using var baseKey = RegistryKey.OpenBaseKey(hive, view);
            using var uninstall = baseKey.OpenSubKey(@"SOFTWARE\Microsoft\Windows\CurrentVersion\Uninstall");
            if (uninstall == null) return;

            foreach (var sub in uninstall.GetSubKeyNames())
            {
                using var k = uninstall.OpenSubKey(sub);
                if (k == null) continue;

                var name = (k.GetValue("DisplayName") as string)?.Trim();
                if (string.IsNullOrWhiteSpace(name)) continue;

                var version = (k.GetValue("DisplayVersion") as string)?.Trim();
                var publisher = (k.GetValue("Publisher") as string)?.Trim();

                string? installDate = (k.GetValue("InstallDate") as string)?.Trim();
                installDate = NormalizeInstallDate(installDate);

                output.Add(new InstalledApp(
                    DisplayName: name,
                    Version: string.IsNullOrWhiteSpace(version) ? null : version,
                    Publisher: string.IsNullOrWhiteSpace(publisher) ? null : publisher,
                    InstallDate: string.IsNullOrWhiteSpace(installDate) ? null : installDate
                ));
            }
        }

        private static string? NormalizeInstallDate(string? raw)
        {
            if (string.IsNullOrWhiteSpace(raw)) return null;

            if (raw.Length == 8 && int.TryParse(raw, out _))
                return $"{raw[..4]}-{raw.Substring(4, 2)}-{raw.Substring(6, 2)}";

            if (DateTime.TryParse(raw, out var dt))
                return dt.ToString("yyyy-MM-dd");

            return null;
        }
    }
}

===== END FILE remoteiq-minimal-e2e\agent-windows\RemoteIQ.Agent\Services\Collectors\SoftwareCollector.cs =====

